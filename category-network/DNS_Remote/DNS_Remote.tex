ee%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Copyright by Wenliang Du.                                       %%
%%  This work is licensed under the Creative Commons                %%
%%  Attribution-NonCommercial-ShareAlike 4.0 International License. %%
%%  To view a copy of this license, visit                           %%
%%  http://creativecommons.org/licenses/by-nc-sa/4.0/.              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\commonfolder}{../../common-files}

\input{\commonfolder/header}
\input{\commonfolder/copyright}


\newcommand{\dnsFigs}{./Figs}

\lhead{\bfseries SEED Labs -- Laboratorio de Ataque Remoto DNS - DNS cache poisoning}


\def \code#1 {\fbox{\scriptsize{\texttt{#1}}}}

\begin{document}

\begin{center}
{\LARGE Laboratorio del Ataque de Kaminsky}
\end{center}

\seedlabcopyright{2006 - 2020}


% *******************************************
% SECTION
% ******************************************* 
\section{Descripción del Laboratorio}

El objetivo de este laboratorio es que los estudiantes aprendan y experimenten con el ataque remoto al DNS, en particular DNS cache poisoning attack, también llamado el ataque de Kaminsky. 
DNS (Domain Name System o Sistema de nombre de Dominios) es la guía de teléfono de la Internet; se encarga de traducir los hostnames a direcciones IP (y visce versa). Esta traducción se hace a través de la resolución DNS, esta ocurre detrás de escena. Los ataques DNS manipulan este proceso de resolucion en varias maneras, con la intención de desviar a los usuarios a destinos alternativos, que a menudo son maliciosos. 
Este laboratorio se focaliza en una técnica particular de ataque al DNS, llamada {\em DNS Cache Poisoning attack}. 
En otro laboratorio SEED, hemos diseñado actividades para conducir el mismo ataque pero en un entorno de red loocal, es decir servidor DNS al cual tiene acceso el atacante y la víctima se encuentran en la misma red, donde es posible hacer sniffeo de paquetes.
En este laboratorio trataremos el ataque remoto al DNS donde no es posible hacer sniffing, por lo que el ataque se vuelve un poco más complejo y desafiante que el ataque local.
 
Este laboratorio cubre los siguientes tópicos:


\begin{itemize}[noitemsep]
\item DNS y su funcionamiento
\item Setup del servidor DNS
\item Ataque DNS cache poisoning
\item Spoofeando respuestas DNS
\item Spoofeo de Paquetes
\end{itemize}


\paragraph{Lecturas y Videos.}
Para una cobertura más detallada sobre el protocolo DNS y sus ataques puede consultar:

\begin{itemize}
\item Capítulo 18 del libro de SEED, \seedbook
\item Sección 7 del curso de SEED en Udemy, \seedisvideo
\end{itemize}


\paragraph{Entorno de Laboratorio.} \seedenvironmentC


%% Temporarily remove this part, to make the task a little bit simpler
%% during the transition phase (from VM to container)
\begin{comment}
\vspace{0.2in}
\noindent
\fbox{\parbox{\textwidth}{
\noindent
\textbf{Personalización.}
En la descripción de este laboratio usamos el dominio \texttt{attacker32.com} para referirnos al dominio que es controlado por el atacante. Cuando los estudiantes hagan este laboratorio, no se les permitirá usar este nombre; en lugar de esto deben de usar un nombre de dominio que incluya su apellido.
El objetivo de esto es diferenciar el trabajo de cada uno de los estudiantes. Dado que el nombre del dominio es visible solamente dentro del entorno del laboratorio y no por fuera de este, es posible usar este tipo de nombre de forma segura.
}}
\end{comment}




% *******************************************
% SECTION
% ******************************************* 
\section{Setup del Entorno de Laboratorio (Tarea 1)}
\label{sec:environment}

\begin{figure}[htb]
\centering
\includegraphics[width=0.85\textwidth]{\commonfolder/Figs/DNS.pdf}
\caption{Setup del Entorno}
\label{dns:fig:environment}
\end{figure}

El principal objetivo para un ataque de DNS cache poisoning es el servidor de DNS  local. Obviamente es ilegal atacar un servidor real, poor lo que necesitaremos crear y configurar nuestro propio servidor DNS para conducir los ataques en nuestros experimentos. El entorno de laboratorio necesita cuatro máquinas por separado:
una va a ser la máquina víctima, la segunda será el servidor de DNS local y las dos restantes serán las máquinas de los atacantes.
El setup del entorno del laboratorio se ilustra en la Figura \ref{dns:fig:environment}.


%\begin{lstlisting}[backgroundcolor=]
% +------------+   +------------+  +------------+  +---------------+
% | Attack VM  |   |  Container |  |  Container |  |  Container    |
% |            |   |   (user)   |  |  Local DNS |  |attacker32.com |
% |            |   |            |  |   Server   |  |  nameserver   |
% |  10.9.0.1  |   |  10.9.0.5  |  |  10.9.0.53 |  |  10.9.0.153   |
% +-----+------+   +------+-----+  +------+-----+  +------+--------+
%       |                 |               |               |
%       |                 |               |               |
%-------+-----------------+---------------+---------------+-------
%           Network  10.9.0.0/24
%
%\end{lstlisting}

Hemos puesto a todas las máquinas en la misma LAN con el objetivo de facilitar un poco todo.
Los estudiantes no pueden explotar este hecho en sus ataques; ellos deberían de considerar a la máquina del atacante como una máquina remota, es decir, el atacante no puede sniffear paquetes en la LAN.
Esto es diferente al ataque local del DNS.


% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Setup del Contenedor y sus Comandos}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/container/setup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Sobre el Contenedor del Atacante}

Para este laboratorio podemos usar tanto una Máquina Virtual como un contenedor como máquina de ataque. Si observa el archivo Docker Compose, verá que el contenedor de ataque está configurado de forma diferente al resto de los contenedores.


\begin{itemize}
\item \textit{Directorio Compartido.} Cuando usemos el contenedor del atacante para realizar los ataques, necesitamos poner el código de ataque dentro del contenedor.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/container/volumes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\item \textit{Host mode.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/container/host_mode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{itemize}





% -------------------------------------------
% SUBSECTION
% -------------------------------------------
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/DNS/summary_of_config}
\input{\commonfolder/DNS/setup_testing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% *******************************************
% SECTION
% ******************************************* 
\section{Las tareas de ataque}

El principal objetivo de los ataques DNS sobre un usuario es poder redireccionar al usuario hacia una máquina $B$ cuando el usuario intente acceder a una máquina $A$ usando el hostname de $A$. Por ejemplo, cuando un usuario trata de acceder al online banking, los atacantes pueden redireccionarlo a un sitio web malicioso que luce casi igual al sitio oficial del banco, en consecuencia el usuario puede ser engañado y así los atacantes pueden obtener sus credenciales bancarias.

En esta tarea, vamos a usar el nombre de dominio {\tt www.example.com} como nuestro objetivo para hacer el ataque. Cabe señalar que el dominio {\tt www.example.com} está reservado solamente para el uso experimental dentro del contexto de este laboratorio y no para el mundo real. La dirección IP real de {\tt www.example.com} es {\tt 93.184.216.34} y su nameserver es controlado por la Internet Corporation for Assigned Names and Numbers (ICANN).
Cuando el usuario ejecuta el comando {\tt dig} sobre este dominio o usa el navegador para visitarlo, la máquina del usuario envia una consulta DNS a su servidor de DNS local que consultará la dirección IP usando el nameserver de {\tt example.com}.

La meta del ataque es ejecutar un ataque de DNS cache poisoning attack en el servidor de DNS local, de tal forma que cuando el usuario ejecute el comando {\tt dig} para obtener la dirección IP de {\tt www.example.com}, el servidor de DNS local terminará consultando el nameserver del atacante {\tt ns.attacker32.com} y así obtendrá la dirección IP definida por atacante. Como resultado final el usuario será dirigido al sitio web del atacante en lugar del sitio original {\tt www.example.com}.



\begin{figure}[htb]
\centering
\includegraphics[width=0.9\textwidth]{\dnsFigs/DNS_Remote_new1.pdf}
\caption{El proceso de consulta DNS} 
\label{fig:flow_diagram1}
\end{figure}


\begin{figure}[htb]
\centering
\includegraphics[width=0.9\textwidth]{\dnsFigs/DNS_Remote_new2.pdf}
\caption{El Ataque Kaminsky}
\label{fig:flow_diagram2}
\end{figure}



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Como funciona el Ataque de Kaminsky}

En esta tarea, el atacante envía una consulta de petición DNS al servidor DNS de la víctima ({\tt Apollo}), activando una consulta DNS desde {\tt Apollo}.
La consulta puede viajar a través de uno de los servidores DNS raíz, el servidor DNS {\tt .COM} y el resultado final vendrá desde el servidor DNS de {\tt example.com}. Esto se ilustra en la Figura \ref{fig:flow_diagram1}. En caso que la información del nameserver para el dominio {\tt example.com} esté cacheada por {\tt Apollo}, la consulta no irá al servidor raíz o al servidor {\tt .COM}; esto se ilustra en la Figura \ref{fig:flow_diagram2}.
En este laboratorio, la situación representadda en la Figura \ref{fig:flow_diagram2} es la más común, por lo que usaremos esta figura como base para describir el mecanismo de ataque.


While {\tt Apollo} waits for the DNS reply from {\tt example.com}'s name
server, the attacker can send forged replies to {\tt Apollo}, pretending 
that the replies are from {\tt example.com}'s nameserver. If the forged 
replies arrive first, it will be accepted by {\tt Apollo}. The attack will
be successful.


If you have done our local DNS attack lab, you should realize that 
those attacks assume that the attacker and the DNS server are on
the same LAN, i.e., the attacker can observe the DNS query message. 
When the attacker and the DNS server are not on the same LAN,
the cache poisoning attack becomes more difficult.
The difficulty is mainly caused by the fact that the transaction ID
in the DNS response packet must match with that 
in the query packet. Because the transaction ID in the query is 
usually randomly generated, without seeing the query packet,
it is not easy for the attacker to know the correct ID.


Obviously, the attacker can guess the transaction ID. Since the
size of the ID is only 16 bits, if the attacker can forge $K$ 
responses within the attack window (i.e. before the legitimate
response arrives), the probability of success is $K$ over $2^{16}$.
Sending out hundreds of forged responses is not impractical, so
it will not take too many tries before the attacker can succeed. 


However, the above hypothetical attack has overlooked the cache effect.
In reality, if the attacker is not fortunate enough to make a correct guess before
the real response packet arrives, correct information will be cached 
by the DNS server for a while. This caching effect makes it impossible
for the attacker to forge another response regarding the same 
name, because the DNS server will not send out another DNS query for 
this name before the cache times out.
To forge another response on the same name, the attacker has to 
wait for another DNS query on this name, which means he/she has to
wait for the cache to time out. The waiting period can be hours or days.


\paragraph{The Kaminsky Attack.} 
Dan Kaminsky came up with an elegant technique to defeat the caching
effect~\cite{dns:Kaminsky}.
With the Kaminsky attack, attackers will be able to continuously attack
a DNS server on a domain name, without the need for waiting, so
attacks can succeed within a very short period of time.
Details of the attacks are described in~\cite{dns:Kaminsky,seedbook}. 
In this task, we will try this attack method. The following steps with reference to 
Figure~\ref{fig:flow_diagram2} outlines the attack. 

\begin{enumerate}
\item The attacker queries the DNS Server {\tt Apollo} for a non-existing name in 
{\tt example.com}, such as {\tt twysw.example.com},
where {\tt twysw} is a random name. 

\item Since the mapping is unavailable in {\tt Apollo}'s DNS cache, 
{\tt Apollo} sends a DNS query to the nameserver of
the {\tt example.com} domain.

\item While {\tt Apollo} waits for the reply, 
the attacker floods {\tt Apollo} with a stream of spoofed DNS response,
each trying a different transaction ID, hoping one is correct.
In the response, not only does the attacker provide an IP resolution
for {\tt twysw.example.com}, the attacker 
also provides an ``Authoritative Nameservers'' record, indicating 
{\tt ns.attacker32.com} as the nameserver for the {\tt example.com} domain.
If the spoofed response beats the actual responses and
the transaction ID matches with that in the query, 
{\tt Apollo} will accept and cache the spoofed answer, and
and thus {\tt Apollo}'s DNS cache is poisoned.  

\item Even if the spoofed DNS response fails (e.g.
the transaction ID does not match or it comes too late),
it does not matter, because the next time, the attacker will query
a different name, so {\tt Apollo} has to send out another query, 
giving the attack another chance to do the spoofing attack. 
This effectively defeats the caching effect.


\item If the attack succeeds, in {\tt Apollo}'s DNS cache, the
nameserver for {\tt example.com} will be replaced by the attacker's
nameserver {\tt ns.attacker32.com}.
To demonstrate the success of this attack, students need to show that such a record 
is in {\tt Apollo}'s DNS cache. 

\end{enumerate}


\paragraph{Task overview.} Implementing the Kaminsky attack is quite challenging, 
so we break it down into several sub-tasks. 
In Task 2, we construct the DNS request for a random hostname 
in the \texttt{example.com} domain. In Task 3, we construct a spoofed 
DNS reply from \texttt{example.com}'s nameserver.
In Task 4, we put everything together to launch the 
Kaminsky attack. Finally in Task 5, we verify the impact of the attack. 


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 2: Construyendo una petición DNS} 

This task focuses on sending out DNS requests. 
In order to complete the attack, attackers need to trigger the target 
DNS server to send out DNS queries, so they have a chance 
to spoof DNS replies. Since attackers need to try many times before they 
can succeed, it is better to automate the process using a program. 

Students need to write a program to send out DNS queries to the target DNS 
server (i.e., the local DNS server in our setup). 
Students' job is to write this program
and demonstrate (using Wireshark) that their queries can
trigger the target DNS server to send out corresponding DNS queries.
The performance requirement for this task is not high, so
students can use C or Python (using Scapy) to write this code. 
A Python code snippet is provided in the following (the 
\texttt{+++}'s are placeholders; students need to replace them
with actual values): 

\begin{lstlisting}
Qdsec  = DNSQR(qname='www.example.com')
dns    = DNS(id=0xAAAA, qr=0, qdcount=1, ancount=0, nscount=0,
             arcount=0, qd=Qdsec)

ip  = IP(dst='+++', src='+++')
udp = UDP(dport=+++, sport=+++, chksum=0)
request = ip/udp/dns
\end{lstlisting}
 


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 3: Spoofeando respuestas DNS.}   

In this task, we need to spoof DNS replies in the Kaminsky attack. 
Since our target is \texttt{example.com}, we need to spoof
the replies from this domain's nameserver. Students first need to 
find out the IP addresses of \texttt{example.com}'s legitimate 
nameservers (it should be noted that there are multiple 
nameservers for this domain).

Students can use Scapy to implement this task. The following 
code snippet constructs a DNS response packet that includes 
a question section, an answer section, and an NS section. 
In the sample code, we use \texttt{+++} as placeholders; 
students need to replace them with the correct values 
that are needed in the Kaminsky attack. Students need to explain
why they pick those values. 

\begin{lstlisting}
name   = '+++'  
domain = '+++'  
ns     = '+++'

Qdsec  = DNSQR(qname=name)
Anssec = DNSRR(rrname=name,   type='A',  rdata='1.2.3.4', ttl=259200)
NSsec  = DNSRR(rrname=domain, type='NS', rdata=ns, ttl=259200)
dns    = DNS(id=0xAAAA, aa=1, rd=1, qr=1,
             qdcount=1, ancount=1, nscount=1, arcount=0,
             qd=Qdsec, an=Anssec, ns=NSsec)

ip    = IP(dst='+++', src='+++')
udp   = UDP(dport=+++, sport=+++, chksum=0)
reply = ip/udp/dns
\end{lstlisting}
 

Since this reply by itself will not be able to lead to a successful 
attack, to demonstrate this task, students need to 
use Wireshark to capture the spoofed DNS replies, and 
show that the spoofed packets are valid. 


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 4: Ejecutar el Ataque de Kaminsky}   

Now we can put everything together to conduct the Kaminsky attack. 
In the attack, we need to send out many spoofed DNS replies, hoping 
one of them hits the correct transaction number and arrives sooner
than the legitimate replies. Therefore, speed is essential: the more packets 
we can send out, the higher the success rate is. If we use 
Scapy to send the spoofed DNS replies like what we did in the 
previous task, the success rate is too low. Students can use 
C, but constructing DNS packets in C is non-trivial. 
We introduce a hybrid approach using both Scapy and C (see the SEED
book for details). 


With the hybrid approach, we first use Scapy to generate 
a DNS packet template, which is stored in a file. 
We then load this template into a C program, and make 
small changes to some of the fields, and then send 
out the packet. 
We have included a skeleton C code
in \path{Labsetup/Files/attack.c}. 
Students can make changes
in the marked areas. Detailed explanation
of the code is given in the 
guideline section.


\paragraph{Check the DNS cache.}
To check whether the attack is successful or not, we need to 
check the {\tt dump.db} file to see whether our spoofed DNS
response has been successfully accepted by the DNS server. 
The following commands dump the DNS cache, and search whether
the cache contains the word \texttt{attacker} (in our 
attack, we used \texttt{attacker32.com} as the attacker's 
domain; if students use a different domain name, they should 
search for a different word).  

\begin{lstlisting}
# rndc dumpdb -cache && grep attacker /var/cache/bind/dump.db
\end{lstlisting}
 

% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Task 5: Result Verification}

If the attack is successful, in the local DNS server's DNS cache, 
the {\tt NS} record for \texttt{example.com} will become 
\texttt{ns.attacker32.com}.
When this server receives a DNS query for any hostname
inside the \texttt{example.com} domain,  it will
send a query to \texttt{ns.attacker32.com}, instead of 
sending to the domain's legitimate nameserver. 


To verify whether your attack is successful or not, 
go to the User machine, run the following two
\texttt{dig} commands. In the responses, the IP addresses for 
\texttt{www.example.com} should be the same for both 
commands, and it should be whatever you have included
in the zone file on the Attacker nameserver. 

\begin{lstlisting}
// Ask the local DNS server to do the query
$ dig www.example.com

// Directly query the attacker32 nameserver
$ dig @ns.attacker32.com www.example.com
\end{lstlisting}
 
Please include your observation (screenshots) in the lab 
report, and explain why you think your attack is successful. 
In particular, when you run the first \texttt{dig} commands,
use Wireshark to capture the network traffic, and 
point out what packets are triggered by this
\texttt{dig} command. Use the packet trace to 
prove that your attack is successful. Note that DNS results
may be cached on the local DNS server after the first
\texttt{dig} command is run. This could influence the
results if you run the first \texttt{dig} command before using
Wireshark. You can clear the cache using \texttt{"sudo rndc flush"} 
on the local DNS server, but that will 
require you to redo the attack.



% *******************************************
% SECTION
% ******************************************* 
\section{Guidelines} 

To implement the Kaminsky attack, we can use Scapy to do the packet spoofing. Unfortunately,
the speed of Python is too slow; the number of packets generated per second is too low to
make the attack successful. It is better to use a C program. This could
be quite challenging to many students, because constructing DNS packets using C is not very
easy. I have developed a hybrid method, and have experimented with it in my own class. Using
this approach, students' time spent on coding can be significantly reduced, so they can spend
more time focusing on the actual attack.


The idea is to leverage the strength of both Scapy and C: Scapy is much more convenient in
creating DNS packets than C, but C is much faster. Therefore we simply
use Scapy to create the spoofed DNS packet, and save it to a file.
We then load the packet into a C program. Even though we need to send a 
lot of different DNS packets
during the Kaminsky attack, these packets are mostly the same, except for a few fields. 
Therefore, we can
use the packet generated from Scapy as the basis, find the offsets where
changes need to be made (e.g., the transaction ID field),
and directly make changes. This will be much easier than
creating the entire DNS packets in C.
After the changes are made, we can use the raw socket to send out the packets.
Details of such a hybrid method are provided in
the Packet Sniffing and Spoofing chapter 
of the SEED book~\cite{seedbook}.
The following Scapy program creates a simple DNS reply packet, 
and saves it into a file.


\begin{lstlisting}[caption={\texttt{generate\_dns\_reply.py}}]
#!/usr/bin/env python3
from scapy.all import *

# Construct the DNS header and payload
name   = 'twysw.example.com'
Qdsec  = DNSQR(qname=name)
Anssec = DNSRR(rrname=name, type='A', rdata='1.1.2.2', ttl=259200)
dns    = DNS(id=0xAAAA, aa=1, rd=0, qr=1, 
             qdcount=1, ancount=1, nscount=0, arcount=0, 
             qd=Qdsec, an=Anssec)

# Construct the IP, UDP headers, and the entire packet
ip  = IP(dst='10.0.2.7', src='1.2.3.4', chksum=0)
udp = UDP(dport=33333, sport=53, chksum=0)
pkt = ip/udp/dns

# Save the packet to a file
with open('ip.bin', 'wb') as f:
  f.write(bytes(pkt))
\end{lstlisting}

In a C program, we load the packet from the file \texttt{ip.bin}, and use
it as our packet template, based on which we create many similar packets,
and flood the target local DNS servers with these spoofed replies. For each
reply, we change three places: the transaction ID and the name
\texttt{twysw} occurred in two places (the question section and the answer
section).  The transaction ID is at a fixed place (offset  \texttt{28} from
the beginning of our IP packet), but the offset for the name \texttt{twysw}
depends on the length of the domain name. We can use a binary editor
program, such as \texttt{bless}, to view the binary file \texttt{ip.bin}
and find the two offsets of \texttt{twysw}. In our packet, they are at
offsets \texttt{41} and \texttt{64}.


The following code snippet shows how we make change to these fields. We change
the name in our reply to \texttt{bbbbb.example.com}, and then send out a
spoofed DNS replies, with transaction ID being \texttt{1000}.
In the code, the variable \texttt{ip} points to the beginning of the IP packet.  

\begin{lstlisting}
  // Modify the name in the question field (offset=41)
  memcpy(ip+41, "bbbbb" , 5);

  // Modify the name in the answer field (offset=64)
  memcpy(ip+64, "bbbbb" , 5);

  // Modify the transaction ID field (offset=28)
  unsigned short id = 1000;
  unsigned short id_net_order = htons(id);
  memcpy(ip+28, &id_net_order, 2);
\end{lstlisting}



\paragraph{Generate random names.} In the Kaminsky attack, we need to 
generate random hostnames. There are many ways to do so. The following 
code snippet shows how to generate a random name consisting of 
5 characters. 

\begin{lstlisting}
char a[26]="abcdefghijklmnopqrstuvwxyz";

// Generate a random name of length 5
char name[6];
name[5] = 0;
for (int k=0; k<5; k++)  
   name[k] = a[rand() % 26];
\end{lstlisting}
 



% *******************************************
% SECTION
% ******************************************* 
\section{Informe del Laboratorio}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/submission}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% *******************************************
% SECTION
% *******************************************
\section*{Agradecimientos}

\input{\commonfolder/acknowledgments}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\thispagestyle{empty}
\bibliographystyle{plain}
\def\baselinestretch{1}
\bibliography{BibDNS}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\end{document}




