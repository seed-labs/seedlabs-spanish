ee%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Copyright by Wenliang Du.                                       %%
%%  This work is licensed under the Creative Commons                %%
%%  Attribution-NonCommercial-ShareAlike 4.0 International License. %%
%%  To view a copy of this license, visit                           %%
%%  http://creativecommons.org/licenses/by-nc-sa/4.0/.              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\commonfolder}{../../common-files}

\input{\commonfolder/header}
\input{\commonfolder/copyright}


\newcommand{\dnsFigs}{./Figs}

\lhead{\bfseries SEED Labs -- Laboratorio de Ataque Remoto DNS - DNS cache poisoning}


\def \code#1 {\fbox{\scriptsize{\texttt{#1}}}}

\begin{document}

\begin{center}
{\LARGE Laboratorio del Ataque de Kaminsky}
\end{center}

\seedlabcopyright{2006 - 2020}


% *******************************************
% SECTION
% ******************************************* 
\section{Descripción del Laboratorio}

El objetivo de este laboratorio es que los estudiantes aprendan y experimenten con el ataque remoto al DNS, en particular DNS cache poisoning attack, también llamado el ataque de Kaminsky. 
DNS (Domain Name System o Sistema de nombre de Dominios) es la guía de teléfono de la Internet; se encarga de traducir los hostnames a direcciones IP (y visce versa). Esta traducción se hace a través de la resolución DNS, esta ocurre detrás de escena. Los ataques DNS manipulan este proceso de resolucion en varias maneras, con la intención de desviar a los usuarios a destinos alternativos, que a menudo son maliciosos. 
Este laboratorio se focaliza en una técnica particular de ataque al DNS, llamada {\em DNS Cache Poisoning attack}. 
En otro laboratorio SEED, hemos diseñado actividades para conducir el mismo ataque pero en un entorno de red loocal, es decir servidor DNS al cual tiene acceso el atacante y la víctima se encuentran en la misma red, donde es posible hacer sniffeo de paquetes.
En este laboratorio trataremos el ataque remoto al DNS donde no es posible hacer sniffing, por lo que el ataque se vuelve un poco más complejo y desafiante que el ataque local.
 
Este laboratorio cubre los siguientes tópicos:


\begin{itemize}[noitemsep]
\item DNS y su funcionamiento
\item Setup del servidor DNS
\item Ataque DNS cache poisoning
\item Spoofeando respuestas DNS
\item Spoofeo de Paquetes
\end{itemize}


\paragraph{Lecturas y Videos.}
Para una cobertura más detallada sobre el protocolo DNS y sus ataques puede consultar:

\begin{itemize}
\item Capítulo 18 del libro de SEED, \seedbook
\item Sección 7 del curso de SEED en Udemy, \seedisvideo
\end{itemize}


\paragraph{Entorno de Laboratorio.} \seedenvironmentC


%% Temporarily remove this part, to make the task a little bit simpler
%% during the transition phase (from VM to container)
\begin{comment}
\vspace{0.2in}
\noindent
\fbox{\parbox{\textwidth}{
\noindent
\textbf{Personalización.}
En la descripción de este laboratio usamos el dominio \texttt{attacker32.com} para referirnos al dominio que es controlado por el atacante. Cuando los estudiantes hagan este laboratorio, no se les permitirá usar este nombre; en lugar de esto deben de usar un nombre de dominio que incluya su apellido.
El objetivo de esto es diferenciar el trabajo de cada uno de los estudiantes. Dado que el nombre del dominio es visible solamente dentro del entorno del laboratorio y no por fuera de este, es posible usar este tipo de nombre de forma segura.
}}
\end{comment}




% *******************************************
% SECTION
% ******************************************* 
\section{Setup del Entorno de Laboratorio (Tarea 1)}
\label{sec:environment}

\begin{figure}[htb]
\centering
\includegraphics[width=0.85\textwidth]{\commonfolder/Figs/DNS.pdf}
\caption{Setup del Entorno}
\label{dns:fig:environment}
\end{figure}

El principal objetivo para un ataque de DNS cache poisoning es el servidor de DNS  local. Obviamente es ilegal atacar un servidor real, poor lo que necesitaremos crear y configurar nuestro propio servidor DNS para conducir los ataques en nuestros experimentos. El entorno de laboratorio necesita cuatro máquinas por separado:
una va a ser la máquina víctima, la segunda será el servidor de DNS local y las dos restantes serán las máquinas de los atacantes.
El setup del entorno del laboratorio se ilustra en la Figura \ref{dns:fig:environment}.


%\begin{lstlisting}[backgroundcolor=]
% +------------+   +------------+  +------------+  +---------------+
% | Attack VM  |   |  Container |  |  Container |  |  Container    |
% |            |   |   (user)   |  |  Local DNS |  |attacker32.com |
% |            |   |            |  |   Server   |  |  nameserver   |
% |  10.9.0.1  |   |  10.9.0.5  |  |  10.9.0.53 |  |  10.9.0.153   |
% +-----+------+   +------+-----+  +------+-----+  +------+--------+
%       |                 |               |               |
%       |                 |               |               |
%-------+-----------------+---------------+---------------+-------
%           Network  10.9.0.0/24
%
%\end{lstlisting}

Hemos puesto a todas las máquinas en la misma LAN con el objetivo de facilitar un poco todo.
Los estudiantes no pueden explotar este hecho en sus ataques; ellos deberían de considerar a la máquina del atacante como una máquina remota, es decir, el atacante no puede sniffear paquetes en la LAN.
Esto es diferente al ataque local del DNS.


% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Setup del Contenedor y sus Comandos}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/container/setup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Sobre el Contenedor del Atacante}

Para este laboratorio podemos usar tanto una Máquina Virtual como un contenedor como máquina de ataque. Si observa el archivo Docker Compose, verá que el contenedor de ataque está configurado de forma diferente al resto de los contenedores.


\begin{itemize}
\item \textit{Directorio Compartido.} Cuando usemos el contenedor del atacante para realizar los ataques, necesitamos poner el código de ataque dentro del contenedor.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/container/volumes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\item \textit{Host mode.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/container/host_mode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{itemize}





% -------------------------------------------
% SUBSECTION
% -------------------------------------------
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/DNS/summary_of_config}
\input{\commonfolder/DNS/setup_testing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% *******************************************
% SECTION
% ******************************************* 
\section{Las tareas de ataque}

El principal objetivo de los ataques DNS sobre un usuario es poder redireccionar al usuario hacia una máquina $B$ cuando el usuario intente acceder a una máquina $A$ usando el hostname de $A$. Por ejemplo, cuando un usuario trata de acceder al online banking, los atacantes pueden redireccionarlo a un sitio web malicioso que luce casi igual al sitio oficial del banco, en consecuencia el usuario puede ser engañado y así los atacantes pueden obtener sus credenciales bancarias.

En esta tarea, vamos a usar el nombre de dominio {\tt www.example.com} como nuestro objetivo para hacer el ataque. Cabe señalar que el dominio {\tt www.example.com} está reservado solamente para el uso experimental dentro del contexto de este laboratorio y no para el mundo real. La dirección IP real de {\tt www.example.com} es {\tt 93.184.216.34} y su nameserver es controlado por la Internet Corporation for Assigned Names and Numbers (ICANN).
Cuando el usuario ejecuta el comando {\tt dig} sobre este dominio o usa el navegador para visitarlo, la máquina del usuario envia una consulta DNS a su servidor de DNS local que consultará la dirección IP usando el nameserver de {\tt example.com}.

La meta del ataque es ejecutar un ataque de DNS cache poisoning attack en el servidor de DNS local, de tal forma que cuando el usuario ejecute el comando {\tt dig} para obtener la dirección IP de {\tt www.example.com}, el servidor de DNS local terminará consultando el nameserver del atacante {\tt ns.attacker32.com} y así obtendrá la dirección IP definida por atacante. Como resultado final el usuario será dirigido al sitio web del atacante en lugar del sitio original {\tt www.example.com}.



\begin{figure}[htb]
\centering
\includegraphics[width=0.9\textwidth]{\dnsFigs/DNS_Remote_new1.pdf}
\caption{El proceso de consulta DNS} 
\label{fig:flow_diagram1}
\end{figure}


\begin{figure}[htb]
\centering
\includegraphics[width=0.9\textwidth]{\dnsFigs/DNS_Remote_new2.pdf}
\caption{El Ataque Kaminsky}
\label{fig:flow_diagram2}
\end{figure}



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Como funciona el Ataque de Kaminsky}

En esta tarea, el atacante envía una consulta de petición DNS al servidor DNS de la víctima ({\tt Apollo}), activando una consulta DNS desde {\tt Apollo}.
La consulta puede viajar a través de uno de los servidores DNS raíz, el servidor DNS {\tt .COM} y el resultado final vendrá desde el servidor DNS de {\tt example.com}. Esto se ilustra en la Figura \ref{fig:flow_diagram1}. En caso que la información del nameserver para el dominio {\tt example.com} esté cacheada por {\tt Apollo}, la consulta no irá al servidor raíz o al servidor {\tt .COM}; esto se ilustra en la Figura \ref{fig:flow_diagram2}.
En este laboratorio, la situación representadda en la Figura \ref{fig:flow_diagram2} es la más común, por lo que usaremos esta figura como base para describir el mecanismo de ataque.

Mientras {\tt Apollo} espera por la respuesta DNS del nameserver de  {\tt example.com}, el atacante puede enviar respuestas falsificadas/spoofeadas a {\tt Apollo}, fingiendo que las respuesta provienen del nameserver de {\tt example.com}. Si la respuesta falsificada llega primero, será aceptada por {\tt Apollo}. Podemos decir que el ataque fue exitoso.

Si ud. ha hecho el laboratorio de Ataque de DNS local, debería de saber que esos ataques asumen que el atacante y el servidor DNS están en la misma LAN, es decir el atacante puede observar el mensaje de una consulta DNS.
Cuando el atacante y el servidor DNS no se encuentran en la misma LAN, el ataque de cache poisoning se vuelve un poco más difícil.
La dificultad es causada por el hecho que el ID de transacción en el paquete de respuesta DNS debe de coincidir con el del paquete de la consulta. Dado que el ID de transacción en la consulta es generado de forma aleatoria, sin poder observar el paquete de consulta, no es fácil para un atacante saber el ID correcto.

Obviamente, el atacante puede adivinar el ID de transacción, dado que el tamaño de este ID es de sólo 16 bits, si el atacante puede falsificar/spoofear $K$ respuestas dentro de la ventana de ataque (es decir antes que la respuesta legítima llegue a destino), la probabilidad de suceso de $K$ es de $2^{16}$. 
Enviar cientos de respuestas falsas no es poco práctico, por lo que
no serán necesarios muchos intentos antes de que el atacante pueda tener éxito.

Sin embargo, el hipotético ataque que se planteó anteriormente ha pasado por alto el efecto de la caché.
En realidad, si el atacante no es lo suficientemente afortunado en su trabajo de adivinar el ID correcto antes de que el paquete de la respuesta original llegue a su destino, la información correcta será cacheada por un período de tiempoo en el servidor DNS. Este efecto de almacenamiento en la caché, hace imposible que el atacante pueda falsificar otra respuesta con respecto al mismo nombre, dado que el servidor DNS no enviará otra consulta DNS para este nombre hasta que expiré la caché para este nombre.
Para falsificar la respuesta sobre el mismo nombre, el atacante tiene que esperar por otra consulta DNS sobre este nombre, lo que significa que debe de esperar que la caché expire. El tiempo de expiración puede estar en el orden de la horas o de los días.


\paragraph{El Ataque de Kaminsky.} 
Dan Kaminsky ideó una técnica para evadir este efecto del almacenamiento en la caché \cite{dns:Kaminsky}.
Con el ataque de Kaminsky, los atacantes tienen la posibilidad de atacar continuamente un servidor DNS en un nombre de dominio específico sin la necesidad de esperar que la caché expire, por lo que los ataques pueden ser exitosos en un tiempo relativamente corto. 
Los detalles del ataque son descriptos en \cite{dns:Kaminsky,seedbook}. 
En esta tarea, usaremos este ataque. Los siguientes pasos que hacen referencia a la Figura \ref{fig:flow_diagram2} que describe el ataque.


\begin{enumerate}

\item El atacante consulta el servidor DNS {\tt Apollo} por un nombre no existente en {\tt example.com} por ejemplo {\tt twysw.example.com}, donde {\tt twysw} es un nombre aleatorio.
 
\item Dado que este mapeo no está disponible en la cache del DNS de {\tt Apollo},
{\tt Apollo} envía una consulta DNS al nameserver del dominio  {\tt example.com}.

\item Mientras que {\tt Apollo} espera por la respuesta, el atacante  inunda {\tt Apollo} con un flujo de respuesta DNS falsificadas, en cada una de estas respuestas se prueba un ID de transacción diferente esperando que alguna sea correcta.
En la respuesta, el atacante no solo proporciona una resolución de IP
para {\tttwysw.example.com}, el atacante también proporciona un registro de ``Authoritative Nameservers'', indicando a {\tt ns.attacker32.com} como nameserver para el dominio {\tt example.com}.
Si la respuesta falsificada supera a las respuestas reales y el ID de transacción coincide con el de la consulta, {\tt Apollo} va a aceptarla y cacheará la respuesta falsificada por lo que la caché DNS de {\tt Apollo} está envenenada (poisoned)

\item Incluso si la respuesta DNS que se falsificó/spoofeo falla (por ejemplo el ID de transacción no coincide o llega tarde), no importa, porque la próxima vez, el atacante consultará un nombre diferente, por lo que {\tt Apollo} deberá de enviar otra consulta dándole al atacante otra chance de hacer un ataque de este tipo.
Definitivamente este ataque evade el efecto del almacenamiento en la caché.

\item Si el ataque funciona, en la caché DNS de {\tt Apollo}, el nameserver para {\tt example.com} será reemplazado con el que proporciona el atacante {\tt ns.attacker32.com}.
Para demostrar que el ataque funciona, los estudiantes deben de mostrar que tal registro se encuentra dentro de la caché DNS de {\tt Apollo}.

\end{enumerate}


\paragraph{Descripción de la Tarea.} La implementación del ataque de Kaminsky es algo desafiante, por lo que la hemos separado en varias sub-tareas.
En la Tarea 2, construíremos petición DNS para un hostname aleatorio usando el dominio \texttt{example.com}. En la Tarea 3, construíremos spoofearemos las respuestas provenientes del nameserver en \texttt{example.com}. En la Tarea 4, pondremos todo junto para lanzar el ataque de Kaminsky y finalmente en la Tarea 5, verificaremos el impacto del ataque.

% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 2: Construyendo una petición DNS} 

Esta tarea se centra en el envío de peticiones DNS.
Para completar el ataque, los atacantes necesitan hacer que el servidor DNS envié consultas, de esta forma tendrán las chances necesarias para empezar a falsificar respuestas DNS. Dado que los atacantes necesitan intentar varias veces antes de que el ataque sea exitoso, es mejor automatizar el proceso usando un programa.

Los estudiantes deben escribir un programa para enviar consultas DNS al servidor DNS objetivo (es decir, el servidor de DNS local de nuestro setup).
La tarea de los estudiantes es escribir este programa y demostrar (usando Wireshark) que sus consultas hacen que el servidor DNS objetivo esté enviando las consultas DNS correspondientes.
Los requerimientos de performance para esta tarea no son altos, por lo que lo estudiantes pueden usar C o Python (con Scapy) para desarrollar el código del programa.
A continuación se muestra un fragmento de código (los \texttt{+++} son placeholders; los estudiantes deben de reemplazarlos con los valores pertinentes):


\begin{lstlisting}
Qdsec  = DNSQR(qname='www.example.com')
dns    = DNS(id=0xAAAA, qr=0, qdcount=1, ancount=0, nscount=0,
             arcount=0, qd=Qdsec)

ip  = IP(dst='+++', src='+++')
udp = UDP(dport=+++, sport=+++, chksum=0)
request = ip/udp/dns
\end{lstlisting}
 


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 3: Spoofeando respuestas DNS.}   

En esta tarea, necesitamos spoofear las respuestas DNS en el ataque de Kaminsky.
Dado que nuestro objetivo es  \texttt{example.com}, necesitamos spoofear las respuesta del nameserver para este dominio. Los estudiantes primero necesitarán descubrir la dirección IP de los nameservers originales de  \texttt{example.com} (cabe señalar que existen multiples nameservers para este dominio).

Los estudiantes pueden usar Scapy para implementar esta tarea. El siguiente fragmento de código, construye un paquete que representa una respuesta DNS que incluye la sección Question, una sección Answer y una sección NS.
En este código deejemplo, usarmos \texttt{+++} como placeholders; los estudiantes deben de reemplazar estos placeholders con los valores correctos que son necesarios para el ataqu de Kaminsky. Los estudiantes deben de explicar porque escogieron esos valores.


\begin{lstlisting}
name   = '+++'  
domain = '+++'  
ns     = '+++'

Qdsec  = DNSQR(qname=name)
Anssec = DNSRR(rrname=name,   type='A',  rdata='1.2.3.4', ttl=259200)
NSsec  = DNSRR(rrname=domain, type='NS', rdata=ns, ttl=259200)
dns    = DNS(id=0xAAAA, aa=1, rd=1, qr=1,
             qdcount=1, ancount=1, nscount=1, arcount=0,
             qd=Qdsec, an=Anssec, ns=NSsec)

ip    = IP(dst='+++', src='+++')
udp   = UDP(dport=+++, sport=+++, chksum=0)
reply = ip/udp/dns
\end{lstlisting}
 
Dado que esta respuesta por sí sóla no será capaz de conducir a un ataque exitoso, para demostrar lo hecho en esta tarea, los estudiantes deberán de usar Wireshark para capturar las respuestas DNS spoofeadas y mostrar que los paquetes spoofeados son válidos.


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 4: Lanzar el Ataque de Kaminsky}   

Ahora que hemos puesto todo junto, estamos listos para realizar el ataque de Kaminsky.
En este ataque, necesitamos enviar muchas respuestas DNS spoofeadas, con la esperanza de que alguna de ellas entre en el número correcto de transacción y llegue antes que la respuesta original.
La velocidad es esencial en este asunto: mientras más paquetes enviemos, más posibilidades tendremos de que el ataque sea exitoso.
Si usamos Scapy para enviar respuestas DNS spoofeadas como hicimos en las tareas anteriores, la taza de exito será baja. Los estudiantes pueden usar C, pero construir paquetes DNS en C es algo no trivial.
Vamos a introducir un enfoque híbrido usando Scapy y C (vea el libro de SEED para más detalles)

Con este enfoque híbrido, primero usaremos Scapy para generar un paquete DNS que sirva como planilla, esta será guardada en un archivo.
Luego, cargaremos esta planilla dentro de un programa en C, y le haremos unos pequeños cambios a algunos de sus campos y por último enviaremos este paquete.
Hemos incluído un código base en C dentro de  \path{Labsetup/Files/attack.c}. 
Los estudiantes pueden realizar cambios en las áreas que están marcadas. Para una explicación mas detallada consulte la sección Guías.



\paragraph{Chequear la caché DNS.}
Para chequear si el ataque fue exitoso o no, necesitamos chequear el archivo  {\tt dump.db} para ver si nuestra respuesta DNS spoofeada fue aceptada por el servidor DNS.
El siguiente comando hace un dump de la caché DNS y se encarga de buscar si la palabra \texttt{attacker} se encuentra dentro de la caché (en nuestro ataque hemos usado \texttt{attacker32.com} como el dominio del atacante, si los estudiantes desean usar un nombre diferente, deberían de buscar por una palabra difernte)

\begin{lstlisting}
# rndc dumpdb -cache && grep attacker /var/cache/bind/dump.db
\end{lstlisting}
 

% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 5: Verificación del Resultado}

Si el ataque es exitoso, veremos en la caché del servidor de DNS local, el registro {\tt NS} para \texttt{example.com} será \texttt{ns.attacker32.com}.
Cuando este servidor recibe una consulta DNS para cualquier hostname dentro del dominio \texttt{example.com}, este enviará una consulta a \texttt{ns.attacker32.com}, en lugar de enviarla al nameserver original del dominio.

Para verificar si el ataque fue exitoso o no, vaya a la máquina de usuario y corra los siguientes dos comandos usando \texttt{dig}. En las respuesta, la direcciones IP para \texttt{www.example.com} deberían de ser las mismas para ambos comandos, y debería de ser lo que haya incluído en el archivo de la zona del nameserver del atacante.

\begin{lstlisting}
// Ask the local DNS server to do the query
$ dig www.example.com

// Directly query the attacker32 nameserver
$ dig @ns.attacker32.com www.example.com
\end{lstlisting}
 
Por favor incluya su observación (capturas de pantalla) en el informe del laboratorio y explique porque ud. piensa que su ataque fue exitoso.
En particular, cuando corra el primer comando \texttt{dig} use Wireshark para capturar el tráfico de red y señalar que paquetes son disparados por este comando  \texttt{dig}. Use el trackeo del paquete para probar que su ataque es exitoso. Note que los resultados en el servidor de DNS local pueden estar cacheados después de que correr por primera vez el comando \texttt{dig}. Esto puede influenciar en los resultados si ud. corre el comando \texttt{dig} antes de usar Wireshark. Puede limpiar la caché usando  \texttt{"sudo rndc flush"}  en el servidor de DNS local, pero esto requerirá que ud. lance nuevamente el ataque.


% *******************************************
% SECTION
% ******************************************* 
\section{Guías} 

To implement the Kaminsky attack, we can use Scapy to do the packet spoofing. Unfortunately,
the speed of Python is too slow; the number of packets generated per second is too low to
make the attack successful. It is better to use a C program. This could
be quite challenging to many students, because constructing DNS packets using C is not very
easy. I have developed a hybrid method, and have experimented with it in my own class. Using
this approach, students' time spent on coding can be significantly reduced, so they can spend
more time focusing on the actual attack.


The idea is to leverage the strength of both Scapy and C: Scapy is much more convenient in
creating DNS packets than C, but C is much faster. Therefore we simply
use Scapy to create the spoofed DNS packet, and save it to a file.
We then load the packet into a C program. Even though we need to send a 
lot of different DNS packets
during the Kaminsky attack, these packets are mostly the same, except for a few fields. 
Therefore, we can
use the packet generated from Scapy as the basis, find the offsets where
changes need to be made (e.g., the transaction ID field),
and directly make changes. This will be much easier than
creating the entire DNS packets in C.
After the changes are made, we can use the raw socket to send out the packets.
Details of such a hybrid method are provided in
the Packet Sniffing and Spoofing chapter 
of the SEED book~\cite{seedbook}.
The following Scapy program creates a simple DNS reply packet, 
and saves it into a file.


\begin{lstlisting}[caption={\texttt{generate\_dns\_reply.py}}]
#!/usr/bin/env python3
from scapy.all import *

# Construct the DNS header and payload
name   = 'twysw.example.com'
Qdsec  = DNSQR(qname=name)
Anssec = DNSRR(rrname=name, type='A', rdata='1.1.2.2', ttl=259200)
dns    = DNS(id=0xAAAA, aa=1, rd=0, qr=1, 
             qdcount=1, ancount=1, nscount=0, arcount=0, 
             qd=Qdsec, an=Anssec)

# Construct the IP, UDP headers, and the entire packet
ip  = IP(dst='10.0.2.7', src='1.2.3.4', chksum=0)
udp = UDP(dport=33333, sport=53, chksum=0)
pkt = ip/udp/dns

# Save the packet to a file
with open('ip.bin', 'wb') as f:
  f.write(bytes(pkt))
\end{lstlisting}

In a C program, we load the packet from the file \texttt{ip.bin}, and use
it as our packet template, based on which we create many similar packets,
and flood the target local DNS servers with these spoofed replies. For each
reply, we change three places: the transaction ID and the name
\texttt{twysw} occurred in two places (the question section and the answer
section).  The transaction ID is at a fixed place (offset  \texttt{28} from
the beginning of our IP packet), but the offset for the name \texttt{twysw}
depends on the length of the domain name. We can use a binary editor
program, such as \texttt{bless}, to view the binary file \texttt{ip.bin}
and find the two offsets of \texttt{twysw}. In our packet, they are at
offsets \texttt{41} and \texttt{64}.


The following code snippet shows how we make change to these fields. We change
the name in our reply to \texttt{bbbbb.example.com}, and then send out a
spoofed DNS replies, with transaction ID being \texttt{1000}.
In the code, the variable \texttt{ip} points to the beginning of the IP packet.  

\begin{lstlisting}
  // Modify the name in the question field (offset=41)
  memcpy(ip+41, "bbbbb" , 5);

  // Modify the name in the answer field (offset=64)
  memcpy(ip+64, "bbbbb" , 5);

  // Modify the transaction ID field (offset=28)
  unsigned short id = 1000;
  unsigned short id_net_order = htons(id);
  memcpy(ip+28, &id_net_order, 2);
\end{lstlisting}



\paragraph{Generar Nombres Aleatorios.} In the Kaminsky attack, we need to 
generate random hostnames. There are many ways to do so. The following 
code snippet shows how to generate a random name consisting of 
5 characters. 

\begin{lstlisting}
char a[26]="abcdefghijklmnopqrstuvwxyz";

// Generate a random name of length 5
char name[6];
name[5] = 0;
for (int k=0; k<5; k++)  
   name[k] = a[rand() % 26];
\end{lstlisting}
 



% *******************************************
% SECTION
% ******************************************* 
\section{Informe del Laboratorio}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/submission}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% *******************************************
% SECTION
% *******************************************
\section*{Agradecimientos}

\input{\commonfolder/acknowledgments}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\thispagestyle{empty}
\bibliographystyle{plain}
\def\baselinestretch{1}
\bibliography{BibDNS}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\end{document}




