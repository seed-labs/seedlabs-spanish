ee%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Copyright by Wenliang Du.                                       %%
%%  This work is licensed under the Creative Commons                %%
%%  Attribution-NonCommercial-ShareAlike 4.0 International License. %%
%%  To view a copy of this license, visit                           %%
%%  http://creativecommons.org/licenses/by-nc-sa/4.0/.              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\commonfolder}{../../common-files}

\input{\commonfolder/header}
\input{\commonfolder/copyright}


\newcommand{\dnsFigs}{./Figs}

\lhead{\bfseries SEED Labs -- Laboratorio de Ataque Remoto DNS - DNS cache poisoning}


\def \code#1 {\fbox{\scriptsize{\texttt{#1}}}}

\begin{document}

\begin{center}
{\LARGE Laboratorio del Ataque de Kaminsky}
\end{center}

\seedlabcopyright{2006 - 2020}


% *******************************************
% SECTION
% ******************************************* 
\section{Descripción del Laboratorio}

El objetivo de este laboratorio es que los estudiantes aprendan y experimenten con el ataque remoto al DNS, en particular DNS cache poisoning attack, también llamado el ataque de Kaminsky. 
DNS (Domain Name System o Sistema de nombre de Dominios) es la guía de teléfono de la Internet; se encarga de traducir los hostnames a direcciones IP (y visce versa). Esta traducción se hace a través de la resolución DNS, esta ocurre detrás de escena. Los ataques DNS manipulan este proceso de resolucion en varias maneras, con la intención de desviar a los usuarios a destinos alternativos, que a menudo son maliciosos. 
Este laboratorio se focaliza en una técnica particular de ataque al DNS, llamada {\em DNS Cache Poisoning attack}. 
En otro laboratorio SEED, hemos diseñado actividades para conducir el mismo ataque pero en un entorno de red loocal, es decir servidor DNS al cual tiene acceso el atacante y la víctima se encuentran en la misma red, donde es posible hacer sniffeo de paquetes.
En este laboratorio trataremos el ataque remoto al DNS donde no es posible hacer sniffing, por lo que el ataque se vuelve un poco más complejo y desafiante que el ataque local.
 
Este laboratorio cubre los siguientes tópicos:


\begin{itemize}[noitemsep]
\item DNS y su funcionamiento
\item Setup del servidor DNS
\item Ataque DNS cache poisoning
\item Spoofeando respuestas DNS
\item Spoofeo de Paquetes
\end{itemize}


\paragraph{Lecturas y Videos.}
Para una cobertura más detallada sobre el protocolo DNS y sus ataques puede consultar:

\begin{itemize}
\item Capítulo 18 del libro de SEED, \seedbook
\item Sección 7 del curso de SEED en Udemy, \seedisvideo
\end{itemize}


\paragraph{Entorno de Laboratorio.} \seedenvironmentC


%% Temporarily remove this part, to make the task a little bit simpler
%% during the transition phase (from VM to container)
\begin{comment}
\vspace{0.2in}
\noindent
\fbox{\parbox{\textwidth}{
\noindent
\textbf{Personalización.}
En la descripción de este laboratio usamos el dominio \texttt{attacker32.com} para referirnos al dominio que es controlado por el atacante. Cuando los estudiantes hagan este laboratorio, no se les permitirá usar este nombre; en lugar de esto deben de usar un nombre de dominio que incluya su apellido.
El objetivo de esto es diferenciar el trabajo de cada uno de los estudiantes. Dado que el nombre del dominio es visible solamente dentro del entorno del laboratorio y no por fuera de este, es posible usar este tipo de nombre de forma segura.
}}
\end{comment}




% *******************************************
% SECTION
% ******************************************* 
\section{Setup del Entorno de Laboratorio (Tarea 1)}
\label{sec:environment}

\begin{figure}[htb]
\centering
\includegraphics[width=0.85\textwidth]{\commonfolder/Figs/DNS.pdf}
\caption{Setup del Entorno}
\label{dns:fig:environment}
\end{figure}

El principal objetivo para un ataque de DNS cache poisoning es el servidor de DNS  local. Obviamente es ilegal atacar un servidor real, poor lo que necesitaremos crear y configurar nuestro propio servidor DNS para conducir los ataques en nuestros experimentos. El entorno de laboratorio necesita cuatro máquinas por separado:
una va a ser la máquina víctima, la segunda será el servidor de DNS local y las dos restantes serán las máquinas de los atacantes.
El setup del entorno del laboratorio se ilustra en la Figura \ref{dns:fig:environment}.


%\begin{lstlisting}[backgroundcolor=]
% +------------+   +------------+  +------------+  +---------------+
% | Attack VM  |   |  Container |  |  Container |  |  Container    |
% |            |   |   (user)   |  |  Local DNS |  |attacker32.com |
% |            |   |            |  |   Server   |  |  nameserver   |
% |  10.9.0.1  |   |  10.9.0.5  |  |  10.9.0.53 |  |  10.9.0.153   |
% +-----+------+   +------+-----+  +------+-----+  +------+--------+
%       |                 |               |               |
%       |                 |               |               |
%-------+-----------------+---------------+---------------+-------
%           Network  10.9.0.0/24
%
%\end{lstlisting}

Hemos puesto a todas las máquinas en la misma LAN con el objetivo de facilitar un poco todo.
Los estudiantes no pueden explotar este hecho en sus ataques; ellos deberían de considerar a la máquina del atacante como una máquina remota, es decir, el atacante no puede sniffear paquetes en la LAN.
Esto es diferente al ataque local del DNS.


% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Setup del Contenedor y sus Comandos}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/container/setup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Sobre el Contenedor del Atacante}

Para este laboratorio podemos usar tanto una Máquina Virtual como un contenedor como máquina de ataque. Si observa el archivo Docker Compose, verá que el contenedor de ataque está configurado de forma diferente al resto de los contenedores.


\begin{itemize}
\item \textit{Directorio Compartido.} Cuando usemos el contenedor del atacante para realizar los ataques, necesitamos poner el código de ataque dentro del contenedor.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/container/volumes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\item \textit{Host mode.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/container/host_mode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{itemize}





% -------------------------------------------
% SUBSECTION
% -------------------------------------------
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/DNS/summary_of_config}
\input{\commonfolder/DNS/setup_testing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% *******************************************
% SECTION
% ******************************************* 
\section{Las tareas de ataque}

El principal objetivo de los ataques DNS sobre un usuario es poder redireccionar al usuario hacia una máquina $B$ cuando el usuario intente acceder a una máquina $A$ usando el hostname de $A$. Por ejemplo, cuando un usuario trata de acceder al online banking, los atacantes pueden redireccionarlo a un sitio web malicioso que luce casi igual al sitio oficial del banco, en consecuencia el usuario puede ser engañado y así los atacantes pueden obtener sus credenciales bancarias.

En esta tarea, vamos a usar el nombre de dominio {\tt www.example.com} como nuestro objetivo para hacer el ataque. Cabe señalar que el dominio {\tt www.example.com} está reservado solamente para el uso experimental dentro del contexto de este laboratorio y no para el mundo real. La dirección IP real de {\tt www.example.com} es {\tt 93.184.216.34} y su nameserver es controlado por la Internet Corporation for Assigned Names and Numbers (ICANN).
Cuando el usuario ejecuta el comando {\tt dig} sobre este dominio o usa el navegador para visitarlo, la máquina del usuario envia una consulta DNS a su servidor de DNS local que consultará la dirección IP usando el nameserver de {\tt example.com}.

La meta del ataque es ejecutar un ataque de DNS cache poisoning attack en el servidor de DNS local, de tal forma que cuando el usuario ejecute el comando {\tt dig} para obtener la dirección IP de {\tt www.example.com}, el servidor de DNS local terminará consultando el nameserver del atacante {\tt ns.attacker32.com} y así obtendrá la dirección IP definida por atacante. Como resultado final el usuario será dirigido al sitio web del atacante en lugar del sitio original {\tt www.example.com}.



\begin{figure}[htb]
\centering
\includegraphics[width=0.9\textwidth]{\dnsFigs/DNS_Remote_new1.pdf}
\caption{El proceso de consulta DNS} 
\label{fig:flow_diagram1}
\end{figure}


\begin{figure}[htb]
\centering
\includegraphics[width=0.9\textwidth]{\dnsFigs/DNS_Remote_new2.pdf}
\caption{El Ataque Kaminsky}
\label{fig:flow_diagram2}
\end{figure}



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Como funciona el Ataque de Kaminsky}

En esta tarea, el atacante envía una consulta de petición DNS al servidor DNS de la víctima ({\tt Apollo}), activando una consulta DNS desde {\tt Apollo}.
La consulta puede viajar a través de uno de los servidores DNS raíz, el servidor DNS {\tt .COM} y el resultado final vendrá desde el servidor DNS de {\tt example.com}. Esto se ilustra en la Figura \ref{fig:flow_diagram1}. En caso que la información del nameserver para el dominio {\tt example.com} esté cacheada por {\tt Apollo}, la consulta no irá al servidor raíz o al servidor {\tt .COM}; esto se ilustra en la Figura \ref{fig:flow_diagram2}.
En este laboratorio, la situación representadda en la Figura \ref{fig:flow_diagram2} es la más común, por lo que usaremos esta figura como base para describir el mecanismo de ataque.

Mientras {\tt Apollo} espera por la respuesta DNS del nameserver de  {\tt example.com}, el atacante puede enviar respuestas falsificadas/spoofeadas a {\tt Apollo}, fingiendo que las respuesta provienen del nameserver de {\tt example.com}. Si la respuesta falsificada llega primero, será aceptada por {\tt Apollo}. Podemos decir que el ataque fue exitoso.

Si ud. ha hecho el laboratorio de Ataque de DNS local, debería de saber que esos ataques asumen que el atacante y el servidor DNS están en la misma LAN, es decir el atacante puede observar el mensaje de una consulta DNS.
Cuando el atacante y el servidor DNS no se encuentran en la misma LAN, el ataque de cache poisoning se vuelve un poco más difícil.
La dificultad es causada por el hecho que el ID de transacción en el paquete de respuesta DNS debe de coincidir con el del paquete de la consulta. Dado que el ID de transacción en la consulta es generado de forma aleatoria, sin poder observar el paquete de consulta, no es fácil para un atacante saber el ID correcto.

Obviamente, el atacante puede adivinar el ID de transacción, dado que el tamaño de este ID es de sólo 16 bits, si el atacante puede falsificar/spoofear $K$ respuestas dentro de la ventana de ataque (es decir antes que la respuesta legítima llegue a destino), la probabilidad de suceso de $K$ es de $2^{16}$. 
Enviar cientos de respuestas falsas no es poco práctico, por lo que
no serán necesarios muchos intentos antes de que el atacante pueda tener éxito.

Sin embargo, el hipotético ataque que se planteó anteriormente ha pasado por alto el efecto de la caché.
En realidad, si el atacante no es lo suficientemente afortunado en su trabajo de adivinar el ID correcto antes de que el paquete de la respuesta original llegue a su destino, la información correcta será cacheada por un período de tiempoo en el servidor DNS. Este efecto de almacenamiento en la caché, hace imposible que el atacante pueda falsificar otra respuesta con respecto al mismo nombre, dado que el servidor DNS no enviará otra consulta DNS para este nombre hasta que expiré la caché para este nombre.
Para falsificar la respuesta sobre el mismo nombre, el atacante tiene que esperar por otra consulta DNS sobre este nombre, lo que significa que debe de esperar que la caché expire. El tiempo de expiración puede estar en el orden de la horas o de los días.


\paragraph{El Ataque de Kaminsky.} 
Dan Kaminsky ideó una técnica para evadir este efecto del almacenamiento en la caché \cite{dns:Kaminsky}.
Con el ataque de Kaminsky, los atacantes tienen la posibilidad de atacar continuamente un servidor DNS en un nombre de dominio específico sin la necesidad de esperar que la caché expire, por lo que los ataques pueden ser exitosos en un tiempo relativamente corto. 
Los detalles del ataque son descriptos en \cite{dns:Kaminsky,seedbook}. 
En esta tarea, usaremos este ataque. Los siguientes pasos que hacen referencia a la Figura \ref{fig:flow_diagram2} que describe el ataque.


\begin{enumerate}

\item El atacante consulta el servidor DNS {\tt Apollo} por un nombre no existente en {\tt example.com} por ejemplo {\tt twysw.example.com}, donde {\tt twysw} es un nombre aleatorio.
 
\item Dado que este mapeo no está disponible en la cache del DNS de {\tt Apollo},
{\tt Apollo} envía una consulta DNS al nameserver del dominio  {\tt example.com}.

\item Mientras que {\tt Apollo} espera por la respuesta, el atacante  inunda {\tt Apollo} con un flujo de respuesta DNS falsificadas, en cada una de estas respuestas se prueba un ID de transacción diferente esperando que alguna sea correcta.
En la respuesta, el atacante no solo proporciona una resolución de IP
para {\tttwysw.example.com}, el atacante también proporciona un registro de ``Authoritative Nameservers'', indicando a {\tt ns.attacker32.com} como nameserver para el dominio {\tt example.com}.
Si la respuesta falsificada supera a las respuestas reales y el ID de transacción coincide con el de la consulta, {\tt Apollo} va a aceptarla y cacheará la respuesta falsificada por lo que la caché DNS de {\tt Apollo} está envenenada (poisoned)

\item Incluso si la respuesta DNS que se falsificó/spoofeo falla (por ejemplo el ID de transacción no coincide o llega tarde), no importa, porque la próxima vez, el atacante consultará un nombre diferente, por lo que {\tt Apollo} deberá de enviar otra consulta dándole al atacante otra chance de hacer un ataque de este tipo.
Definitivamente este ataque evade el efecto del almacenamiento en la caché.

\item Si el ataque funciona, en la caché DNS de {\tt Apollo}, el nameserver para {\tt example.com} será reemplazado con el que proporciona el atacante {\tt ns.attacker32.com}.
Para demostrar que el ataque funciona, los estudiantes deben de mostrar que tal registro se encuentra dentro de la caché DNS de {\tt Apollo}.

\end{enumerate}


\paragraph{Descripción de la Tarea.} La implementación del ataque de Kaminsky es algo desafiante, por lo que la hemos separado en varias sub-tareas.
En la Tarea 2, construíremos petición DNS para un hostname aleatorio usando el dominio \texttt{example.com}. En la Tarea 3, construíremos spoofearemos las respuestas provenientes del nameserver en \texttt{example.com}. En la Tarea 4, pondremos todo junto para lanzar el ataque de Kaminsky y finalmente en la Tarea 5, verificaremos el impacto del ataque.

% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 2: Construyendo una petición DNS} 

Esta tarea se centra en el envío de peticiones DNS.
Para completar el ataque, los atacantes necesitan hacer que el servidor DNS envié consultas, de esta forma tendrán las chances necesarias para empezar a falsificar respuestas DNS. Dado que los atacantes necesitan intentar varias veces antes de que el ataque sea exitoso, es mejor automatizar el proceso usando un programa.

Los estudiantes deben escribir un programa para enviar consultas DNS al servidor DNS objetivo (es decir, el servidor de DNS local de nuestro setup).
La tarea de los estudiantes es escribir este programa y demostrar (usando Wireshark) que sus consultas hacen que el servidor DNS objetivo esté enviando las consultas DNS correspondientes.
Los requerimientos de performance para esta tarea no son altos, por lo que lo estudiantes pueden usar C o Python (con Scapy) para desarrollar el código del programa.
A continuación se muestra un fragmento de código (los \texttt{+++} son placeholders; los estudiantes deben de reemplazarlos con los valores pertinentes):


\begin{lstlisting}
Qdsec  = DNSQR(qname='www.example.com')
dns    = DNS(id=0xAAAA, qr=0, qdcount=1, ancount=0, nscount=0,
             arcount=0, qd=Qdsec)

ip  = IP(dst='+++', src='+++')
udp = UDP(dport=+++, sport=+++, chksum=0)
request = ip/udp/dns
\end{lstlisting}
 


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 3: Spoofeando respuestas DNS.}   

In this task, we need to spoof DNS replies in the Kaminsky attack. 
Since our target is \texttt{example.com}, we need to spoof
the replies from this domain's nameserver. Students first need to 
find out the IP addresses of \texttt{example.com}'s legitimate 
nameservers (it should be noted that there are multiple 
nameservers for this domain).

Students can use Scapy to implement this task. The following 
code snippet constructs a DNS response packet that includes 
a question section, an answer section, and an NS section. 
In the sample code, we use \texttt{+++} as placeholders; 
students need to replace them with the correct values 
that are needed in the Kaminsky attack. Students need to explain
why they pick those values. 

\begin{lstlisting}
name   = '+++'  
domain = '+++'  
ns     = '+++'

Qdsec  = DNSQR(qname=name)
Anssec = DNSRR(rrname=name,   type='A',  rdata='1.2.3.4', ttl=259200)
NSsec  = DNSRR(rrname=domain, type='NS', rdata=ns, ttl=259200)
dns    = DNS(id=0xAAAA, aa=1, rd=1, qr=1,
             qdcount=1, ancount=1, nscount=1, arcount=0,
             qd=Qdsec, an=Anssec, ns=NSsec)

ip    = IP(dst='+++', src='+++')
udp   = UDP(dport=+++, sport=+++, chksum=0)
reply = ip/udp/dns
\end{lstlisting}
 

Since this reply by itself will not be able to lead to a successful 
attack, to demonstrate this task, students need to 
use Wireshark to capture the spoofed DNS replies, and 
show that the spoofed packets are valid. 


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 4: Lanzar el Ataque de Kaminsky}   

Now we can put everything together to conduct the Kaminsky attack. 
In the attack, we need to send out many spoofed DNS replies, hoping 
one of them hits the correct transaction number and arrives sooner
than the legitimate replies. Therefore, speed is essential: the more packets 
we can send out, the higher the success rate is. If we use 
Scapy to send the spoofed DNS replies like what we did in the 
previous task, the success rate is too low. Students can use 
C, but constructing DNS packets in C is non-trivial. 
We introduce a hybrid approach using both Scapy and C (see the SEED
book for details). 


With the hybrid approach, we first use Scapy to generate 
a DNS packet template, which is stored in a file. 
We then load this template into a C program, and make 
small changes to some of the fields, and then send 
out the packet. 
We have included a skeleton C code
in \path{Labsetup/Files/attack.c}. 
Students can make changes
in the marked areas. Detailed explanation
of the code is given in the 
guideline section.


\paragraph{Check the DNS cache.}
To check whether the attack is successful or not, we need to 
check the {\tt dump.db} file to see whether our spoofed DNS
response has been successfully accepted by the DNS server. 
The following commands dump the DNS cache, and search whether
the cache contains the word \texttt{attacker} (in our 
attack, we used \texttt{attacker32.com} as the attacker's 
domain; if students use a different domain name, they should 
search for a different word).  

\begin{lstlisting}
# rndc dumpdb -cache && grep attacker /var/cache/bind/dump.db
\end{lstlisting}
 

% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Task 5: Result Verification}

If the attack is successful, in the local DNS server's DNS cache, 
the {\tt NS} record for \texttt{example.com} will become 
\texttt{ns.attacker32.com}.
When this server receives a DNS query for any hostname
inside the \texttt{example.com} domain,  it will
send a query to \texttt{ns.attacker32.com}, instead of 
sending to the domain's legitimate nameserver. 


To verify whether your attack is successful or not, 
go to the User machine, run the following two
\texttt{dig} commands. In the responses, the IP addresses for 
\texttt{www.example.com} should be the same for both 
commands, and it should be whatever you have included
in the zone file on the Attacker nameserver. 

\begin{lstlisting}
// Ask the local DNS server to do the query
$ dig www.example.com

// Directly query the attacker32 nameserver
$ dig @ns.attacker32.com www.example.com
\end{lstlisting}
 
Please include your observation (screenshots) in the lab 
report, and explain why you think your attack is successful. 
In particular, when you run the first \texttt{dig} commands,
use Wireshark to capture the network traffic, and 
point out what packets are triggered by this
\texttt{dig} command. Use the packet trace to 
prove that your attack is successful. Note that DNS results
may be cached on the local DNS server after the first
\texttt{dig} command is run. This could influence the
results if you run the first \texttt{dig} command before using
Wireshark. You can clear the cache using \texttt{"sudo rndc flush"} 
on the local DNS server, but that will 
require you to redo the attack.



% *******************************************
% SECTION
% ******************************************* 
\section{Guidelines} 

To implement the Kaminsky attack, we can use Scapy to do the packet spoofing. Unfortunately,
the speed of Python is too slow; the number of packets generated per second is too low to
make the attack successful. It is better to use a C program. This could
be quite challenging to many students, because constructing DNS packets using C is not very
easy. I have developed a hybrid method, and have experimented with it in my own class. Using
this approach, students' time spent on coding can be significantly reduced, so they can spend
more time focusing on the actual attack.


The idea is to leverage the strength of both Scapy and C: Scapy is much more convenient in
creating DNS packets than C, but C is much faster. Therefore we simply
use Scapy to create the spoofed DNS packet, and save it to a file.
We then load the packet into a C program. Even though we need to send a 
lot of different DNS packets
during the Kaminsky attack, these packets are mostly the same, except for a few fields. 
Therefore, we can
use the packet generated from Scapy as the basis, find the offsets where
changes need to be made (e.g., the transaction ID field),
and directly make changes. This will be much easier than
creating the entire DNS packets in C.
After the changes are made, we can use the raw socket to send out the packets.
Details of such a hybrid method are provided in
the Packet Sniffing and Spoofing chapter 
of the SEED book~\cite{seedbook}.
The following Scapy program creates a simple DNS reply packet, 
and saves it into a file.


\begin{lstlisting}[caption={\texttt{generate\_dns\_reply.py}}]
#!/usr/bin/env python3
from scapy.all import *

# Construct the DNS header and payload
name   = 'twysw.example.com'
Qdsec  = DNSQR(qname=name)
Anssec = DNSRR(rrname=name, type='A', rdata='1.1.2.2', ttl=259200)
dns    = DNS(id=0xAAAA, aa=1, rd=0, qr=1, 
             qdcount=1, ancount=1, nscount=0, arcount=0, 
             qd=Qdsec, an=Anssec)

# Construct the IP, UDP headers, and the entire packet
ip  = IP(dst='10.0.2.7', src='1.2.3.4', chksum=0)
udp = UDP(dport=33333, sport=53, chksum=0)
pkt = ip/udp/dns

# Save the packet to a file
with open('ip.bin', 'wb') as f:
  f.write(bytes(pkt))
\end{lstlisting}

In a C program, we load the packet from the file \texttt{ip.bin}, and use
it as our packet template, based on which we create many similar packets,
and flood the target local DNS servers with these spoofed replies. For each
reply, we change three places: the transaction ID and the name
\texttt{twysw} occurred in two places (the question section and the answer
section).  The transaction ID is at a fixed place (offset  \texttt{28} from
the beginning of our IP packet), but the offset for the name \texttt{twysw}
depends on the length of the domain name. We can use a binary editor
program, such as \texttt{bless}, to view the binary file \texttt{ip.bin}
and find the two offsets of \texttt{twysw}. In our packet, they are at
offsets \texttt{41} and \texttt{64}.


The following code snippet shows how we make change to these fields. We change
the name in our reply to \texttt{bbbbb.example.com}, and then send out a
spoofed DNS replies, with transaction ID being \texttt{1000}.
In the code, the variable \texttt{ip} points to the beginning of the IP packet.  

\begin{lstlisting}
  // Modify the name in the question field (offset=41)
  memcpy(ip+41, "bbbbb" , 5);

  // Modify the name in the answer field (offset=64)
  memcpy(ip+64, "bbbbb" , 5);

  // Modify the transaction ID field (offset=28)
  unsigned short id = 1000;
  unsigned short id_net_order = htons(id);
  memcpy(ip+28, &id_net_order, 2);
\end{lstlisting}



\paragraph{Generate random names.} In the Kaminsky attack, we need to 
generate random hostnames. There are many ways to do so. The following 
code snippet shows how to generate a random name consisting of 
5 characters. 

\begin{lstlisting}
char a[26]="abcdefghijklmnopqrstuvwxyz";

// Generate a random name of length 5
char name[6];
name[5] = 0;
for (int k=0; k<5; k++)  
   name[k] = a[rand() % 26];
\end{lstlisting}
 



% *******************************************
% SECTION
% ******************************************* 
\section{Informe del Laboratorio}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/submission}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% *******************************************
% SECTION
% *******************************************
\section*{Agradecimientos}

\input{\commonfolder/acknowledgments}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\thispagestyle{empty}
\bibliographystyle{plain}
\def\baselinestretch{1}
\bibliography{BibDNS}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\end{document}




