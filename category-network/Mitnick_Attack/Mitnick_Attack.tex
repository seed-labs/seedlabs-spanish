%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Copyright by Wenliang Du.                                       %%
%%  This work is licensed under the Creative Commons                %%
%%  Attribution-NonCommercial-ShareAlike 4.0 International License. %%
%%  To view a copy of this license, visit                           %%
%%  http://creativecommons.org/licenses/by-nc-sa/4.0/.              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\commonfolder}{../../common-files}

\input{\commonfolder/header}
\input{\commonfolder/copyright}


\lhead{\bfseries SEED Labs -- Laboratorio del Ataque de Mitnick}
\newcommand{\mitnickFigs}{./Figs}

\newcommand{\rsh}{\texttt{rsh}\xspace}

\begin{document}



\begin{center}
{\LARGE  Laboratorio del Ataque de Mitnick}
\end{center}

\seedlabcopyright{2020}


% *******************************************
% SECTION
% ******************************************* 
\section{Descripción}

Kevin Mitnick es probablemente uno de los hackers más conocidos en USA.
Estuvo en la lista de los criminales más buscados del FBI. Mientras huía, se interesó en el hackeo de redes de telefonía celular y tenía la necesidad de un software especializado que lo ayude en esta tarea. Eso lo llevó a Tsutomu Shimomura, un investigador que trabajaba en el San Diego Supercomputer Center y quien era uno de los investigadores principales en la seguridad de las redes de telefonía celular.
Tsutomu Shimomura tenía el código que Mitnick estaba necesitando.

En 1994, Mitnick ejecutó un ataque exitoso en la computadora de Shimomura, explotando vulnerabilidades en el protocolo TCP y la relación de confianza entre dos computadores de Shimomura. Este ataque desencadenó una pesecución que eventualmente llevó al arresto de Mitnick. Este suceso fue plasmado en muchos libros y películas de Hollywood tiempo después.
Este ataque es conocido como el Ataque de Mitnick, que es un tipo especial de TCP session hijacking.

El objetivo de este laboratorio es recrear el clásico ataque de Mitnick, de esta forma los estudiantes podrán tener experiencia en tal ataque.
Emularemos la configuración original de la computadora de Shimomura y lanzaremos el ataque de Mitnick para crear una sesión TCP falsificada entre las dos computadoras de Shimomura. Si el ataque es exitoso, deberíamos de poder correr cualquier comando en la computadora de Shimomura.

Este laboratorio cubre los siguientes tópicos:

\begin{itemize}[noitemsep]
\item TCP session hijacking
\item El Protocolo TCP three-way handshake 
\item El Ataque de Mitnick
\item Shell Remota \rsh
\item Sniffing y Spoofing de Paquetes
\end{itemize}


\paragraph{Lecturas y Videos.}
Para una cobertura más detallada sobre  TCP session hijacking puede consultar:

\begin{itemize}
\item Capítulo 16 del libro de SEED, \seedbook
\item Sección 6 del curso de SEED en Udemy, \seedisvideo
\end{itemize}

\paragraph{Entorno de Laboratorio.} \seedenvironmentC



% *******************************************
% SECTION
% ******************************************* 
\section{Como funciona el Ataque de Mitnick}

El ataque de Mitnick es un caso especial de un ataque de TCP session hijacking.
En vez de hacer hijacking sobre una conexión TCP entre una víctima A y otra B, el ataque de Mitnick primero crea una conexión TCP entre A y B en su nombre y luego procede a hacer el hijacking de la conexión.

En el ataque de Mitnick real, el host A fue llamado la X-Terminal y era el objetivo. Mitnick quería loguearse dentro de X-Terminal y ejecutar comandos dentro de este host.
El Host B era un servidor de confianza, que permitía loguear dentro X-Terminal sin usar un password.
Para loguearse dentro de X-Terminal, Mitnick tuvo que impersonar el servidor de confianza, para que así no tenga que ingresar ningun password. La Figura \ref{tcp:mitnick} ilustra a grosso modo el ataque.
Existen cuatro pasos primarios en este ataque.


\begin{figure}[htb]
\centering
\includegraphics[width=0.8\textwidth]{\mitnickFigs/mitnick_attack.pdf}
\caption{Ilustración del Ataque de Mitnick}
\label{tcp:mitnick}
\end{figure}


\paragraph{Paso 1: Predicción del Número de Secuencia.} 
Antes del ataque, Mitnick necesitaba aprender el patrón del inicio de los números de secuencia (ISN) de la X-Terminal (en esos días los ISN no eran aleatorios).
Mitnick enviaba peticiones SYN a la X-Terminal y recibia respuestas SYN+ACK, entonces enviaba un paquete RESET a la X-Terminal, para así limpiar la cola de half-open connections en esta máquina (esto lo hacía para prevenir que la cola se llene). Después de repetir esto veinte veces. Encontro que había un patrón entre dos TCP ISNs sucesivos. Esto le permitió a Mitnick predecir ISNs, que era un elemento esencial para el ataque.


\paragraph{Paso 2: Ataque de SYN flooding en el Servidor de Confianza.}
Para enviar una petición de conexión desde el Servidor de Confianza hacia la X-Terminal, Mitnick necesitaba enviar un paquete SYN desde el Servidor de Confianza hacia la X-Terminal. Entonces la X-Terminal respondería un paquete SYN+ACK que se enviaría al Servidor de Confianza. Dado que este Servidor de Confianza no era el que iniciaba la petición, enviaría un paquete RESET a la X-Terminal para detener el protcolo de 3-way handshake. Este comportamiento era problemático para el ataque de Mitnick.
Para resolver este problema. Mitnick debía de silenciar al Servidor de Confianza.
Para esto, antes de hacer el spoofing, Mitnick lanzaba un ataque de SYN flooding sobre el servidor. En esa época los servidores eran mucho más vulnerables a este tipo de ataques. El ataque podría dejar a la máquina fuera de servicio, silenciándola por completo.


\paragraph{Paso 3: Spoofear la Conexión TCP.}
Mitnick quería usar \rsh (shell remota o remote shell) para ejecutar un comando a modo de backdoor en la X-Terminal; una vez que el backdoor haya sido instalado, podría loguearse dentro de la X-Terminal.
Para correr una shell remota en la X-Terminal, Mitnick necesitaba poder autenticarse, es de cir necesitaba tener una cuenta válida en la X-Terminal y saber su password. Obviamente, no tenía esta información.

Shimomura solía loguearse a menudo dentro de la X-Terminal desde el Servidor de Confianza. Para evitar tipear el password cada vez que entraba, agregó alguna información en el archivo \texttt{.rhosts}  dentro de la X-Terminal, por lo que al loguearse dentro de la X-Terminal desde el Servidor de Confianza, no se le pediría ningún password. En ese entonces esta era una práctica común. En este escenario Shimomura podía correr cualquier comando en la X-Terminal desde el Servidor de Confianza usando \rsh, or corriendo \texttt{rlogin} para loguearse en la X-Terminal, sin la necesidad de tipear un password.
Mitnick quería explotar esta brecha.

Mitnick necesitaba crear una conexión TCP entre el servidor de confianza y la X-Terminal y luego correr  \rsh dentro de esta conexión
Primero envió una petición SYN hacia la X-Terminal, usando la dirección IP del servidor de confianza como la dirección IP de origen.
La X-Terminal respondió con un SYN+ACK hacia el servidor. Dado que el servidor se encontraba fuera de servicio, no enviaría un RESET para cerrar la conexión. 

Para completar el proceso de 3-way handshake, Mitnick necesitaba spoofear un paquete ACK, que debía de confirmar el número de secuencia en el paquete SYN+ACK de la X-Terminal. Desafortunadamente la respuesta SYN+ACK sólo iba hacia el servidor de confianza y no hacia Mitnick, él no podía ver cual era este número de secuencia. Sin embargo, debido a investigaciones previas, Mitnick podía predecir cual podría ser este número, por lo que podía enviar un paquete ACK spoofeado hacia la X-Terminal para completar el 3-way handshake de forma exitosa.


\paragraph{Paso 4: Correr una shell remota.} 
Usando la conexión TCP establecida entre el servidor de confianza y la X-Terminal, Mitnick podía enviar una petición de shell remota a la X-Terminal, con el objetivo de ejecutar un comando. Usando este comando, Mitnick quería plantar un backdoor en la X-Terminal que le otorgará una shell de forma persistente para no tener que volver a repetir el flujo de ataque.

Todo lo que necesitaba era agregar \texttt{"+ +"} en el archivo \texttt{.rhosts} dentro la X-Terminal.
Pudo hacerlo ejecutando el siguiente comando usando \rsh en la X-Terminal:  {\tt "echo + + > .rhosts"}. 
Dado que los programas \rsh y \texttt{rlogin} usaban el archivo \texttt{.rhosts} para autenticación, con este agregado de Mitnick, X-Terminal confiaría en cualquier petición \rsh y \texttt{rlogin} sin importar de quien sea.


% *******************************************
% SECTION
% ******************************************* 
\section{Setup del Entorno de Laboratorio usando Contenedores}



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Setup del Contenedor}

En este laboratorio, necesitamos tres máquinas, una para la X-Terminal, la otra para el Servidor de Confianza y la otra será la del atacante.
En el escenario real del ataque de Mitnick, la máquina del atacante era una máquina remota.
En este laboratorio, por un tema de simplicidad, hemos puesto estas tres máquinas en la misma red.
Los estudiantes pueden usar tres máquina virtuales por separado para hacer el laboratorio, pero es mucho mas conveniente usar los contenedores. 
El entorno de laboratorio se muestra en la Figura \ref{mitnick:fig:labsetup}.


\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.8\textwidth]{\commonfolder/Figs/Mitnick_onelan.pdf}
\end{center}
\caption{Setup del Entorno de Laboratorio}
\label{mitnick:fig:labsetup}
\end{figure}
 

%\begin{lstlisting}[backgroundcolor=]
%            +------------+      +--------------+  +----------------+  
%            |     VM     |      |   Container  |  |    Container   |  
%            | (attacker) |      | (X-Terminal) |  |(Trusted Server)|  
%            |  10.9.0.1  |      |   10.9.0.5   |  |    10.9.0.6    |  
%            +----+-------+      +-------+------+  +--------+-------+  
%                 | br-<id>             | eth0          | eth0   
%                 |                     |               |        
%           ------+---------------------+---------------+--------------
%           Network  10.9.0.0/24
%
%\end{lstlisting}



% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Setup del Contenedor y sus Comandos}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/container/setup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Sobre el Contenedor del Atacante}

I
Para este laboratorio podemos usar tanto una Máquina Virtual como un contenedor como máquina de ataque. Si observa el archivo Docker Compose, verá que el contenedor de ataque está configurado de forma
diferente al resto de los contenedores.

\begin{itemize}
\item \textit{Directorio Compartido.} Cuando usemos el contenedor del atacante para realizar los ataques, necesitamos poner el código de ataque dentro del contenedor.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/container/volumes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item \textit{Host Mode.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/container/host_mode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\item \textit{Privileged Mode.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/container/privileged_mode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{itemize}


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Instalando \rsh}

The remote shell \rsh is a command line program that can execute shell commands
remotely. Although we will use \rsh in this task, we should know that 
\rsh and \texttt{rlogin} programs are not secure, and they 
are not used any more. They have been replaced by
more secured programs, such as \texttt{ssh}.   
That is why in the modern Linux operating systems, the \rsh command 
is actually a symbolic link to the \texttt{ssh} program. 

\begin{lstlisting}
$ ls -al /etc/alternatives | grep rsh
lrwxrwxrwx   1 root root    12 Jul 25  2017 rsh -> /usr/bin/ssh
\end{lstlisting}


To recreate the Mitnick attack, we need to install the unsecure version
of the \rsh program. Obviously, the old version of 
the \rsh no longer works, but an open-source project
re-implements the remote shell clients and servers. 
It is called \texttt{rsh-redone}. 
We can use the following commands to install \rsh server and client. 
\textbf{Note:} The \rsh programs are already installed in  
the X-Terminal and Trusted Server containers (see the \texttt{Dockerfile} 
inside the container image folder). 

\begin{lstlisting}
$ sudo apt-get install rsh-redone-client
$ sudo apt-get install rsh-redone-server
\end{lstlisting}




% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Configuración}
\label{subsec:configuration}

The \rsh server program uses two files for authentication, 
\texttt{.rhosts} and \texttt{/etc/hosts.equiv}.
Every time the server receives a remote command request, it will check
the \texttt{/etc/hosts.equiv}. If the request comes from a hostname stored in the file, the
server will accept it without asking for passwords. 
If \texttt{/etc/hosts.equiv} does not exist or
do not have that hostname, \rsh  will check the \texttt{.rhosts} file 
on the user's home directory. 

Shimomura often needed to run remote commands on X-Terminal
from the trusted server. To avoid typing passwords, he
created a \texttt{.rhosts} file on host X-Terminal and put the trusted
server's IP address into the file.
Note that the \texttt{.rhosts} file must reside at the top level of a user's home directory and
can be written \textbf{only by the owner/user}.


Please use the following commands on X-Terminal to set up the \texttt{.rhosts} file.
It should be noted when we get into a container, we will be in the root 
account. In this lab, we need to switch to a normal user account called seed, which
is already created inside the container: 

\begin{lstlisting}
# su seed          (*@\reflectbox{\ding{217}}@*) Switch to the seed account
$ cd               (*@\reflectbox{\ding{217}}@*) Go to seed's home directory
$ touch .rhosts    (*@\reflectbox{\ding{217}}@*) Create an empty file 
$ echo [Server's IP address] > .rhosts
$ chmod 644 .rhosts
\end{lstlisting}

To verify your configuration, try running the following command on the trusted server.
\begin{lstlisting}
# su seed          (*@\reflectbox{\ding{217}}@*) Switch to the seed account
$ rsh [X-Terminal's IP] date
\end{lstlisting}

If the command prints the current date and time, your configuration is working now. If you
see ``Authentication Failure'', something in your setup may not be correct. 
One of the common mistakes is the permission on the \texttt{.rhosts} file:
you should make sure it is only writable to the owner.


\paragraph{Allow all.} To allow users to execute commands on X-Terminal from 
all IP addresses, we just need to put two plus signs (\texttt{"+ +"})
in the \texttt{.rhosts} file. This is very dangerous, and nobody should 
do that. But if you are an attacker, this is a convenient way
to set up a backdoor. As we have mentioned before, this is what has been used in
the Mitnick attack. 



% *******************************************
% SECTION
% ******************************************* 
\section{Task 1: Simulated SYN flooding}

The operating systems at the time of the Mitnick Attack were vulnerable to SYN
flooding attacks, which could mute the target machine or even shut it down. 
However, SYN flooding can no longer cause such a damage for modern operating systems. 
We will simulate this effect. 

We can manually stop the trusted server container, but that is not enough.
When X-Terminal receives a SYN packet from the trusted server, it will respond with
a SYN+ACK packet. Before sending out this packet, 
it needs to know the MAC address of the trusted server. 
The ARP cache will be checked first. If there is no entry
for the trusted server, X-Terminal will send out an ARP request packet 
to ask for the MAC address. Since the trusted server has been
muted, no one is going to answer the ARP request, hence 
X-Terminal cannot send out the response. As a result, the
TCP connection will not be established. 

In the real attack, the trusted server's MAC address was actually in X-Terminal's ARP
cache. Even if it was not, before silencing the trusted server, 
we could simply spoof an ICMP echo request from the trusted 
server to X-Terminal, that would trigger X-Terminal to reply to 
the trusted server, and hence would get the trusted server's MAC address, and 
save it to the cache. 


To simplify the task, before stopping the trusted server, 
we will simply ping it from X-Terminal once, and then use 
the \texttt{arp} command to check and make sure that
the MAC address is in the cache. It should be noted that 
cache entry may be deleted by the operating system if 
the OS fails to reach a destination using 
the cached MAC address. To simply your attack, 
you can run the following command on X-Terminal to
permanently add an entry to the ARP cache (it needs to
run in the root account):

\begin{lstlisting}
# arp -s [Server's IP] [Server's MAC]
\end{lstlisting}



% *******************************************
% SECTION
% ******************************************* 
\section{Task 2: Spoof TCP Connections and \rsh Sessions}
\label{sec:task2}

Now that we have ``brought down'' the trusted server, we can impersonate the trusted
server, and try to launch a \rsh session  
with X-Terminal. Since \rsh runs on top of TCP, we first need to 
establish a TCP connection between the trusted server and X-Terminal,
and then run the \rsh in this TCP connection.  


One of the difficulties in the Mitnick attack is to predict the TCP sequence numbers. 
It was possible back then when TCP sequence numbers were not randomized. 
However, modern operating systems now randomize their TCP sequence numbers
(as a countermeasure against TCP session hijacking attacks), so
predicting the numbers becomes infeasible.
To simulate the situation of the original Mitnick attack, we 
allow students to sniff packets, so
they can get the sequence numbers, instead of guessing them.  

\paragraph{Restriction.} To simulate the original Mitnick attack
as closely as we can, even though students can sniff
the TCP packets from X-Terminal, they cannot use all the 
fields in captured packets, because in the real attacks,
Mitnick could not sniff packets. When students write their 
attack programs, they can only use the 
following fields from the captured packets. Penalty will be 
applied if other fields are used.

\begin{itemize}
\item \textbf{The TCP sequence number field} (this does not include the acknowledgment
field).

\item \textbf{The TCP flag field}. This allows us to know the types of the 
captured TCP packets. In the actual Mitnick attack, Mitnick knew
exactly what type of packets were sent out by X-Terminal, because 
they are part of the TCP three-way handshake protocol. 
We allow students to use this field for task simplification. 


\item \textbf{All the length fields}, including IP header length, IP total length,
and TCP header length. These pieces of information are not necessary 
for the attacks. In the actual Mitnick attack, Mitnick knew exactly what their
values are. We allow students to use these fields for task simplification. 
\end{itemize}


\paragraph{The behavior of \rsh.} 
To create a spoofed \rsh session between the trusted server and X-Terminal,
we need to understand the behavior of \rsh. Let us start a 
\rsh session from Trusted Server to X-Terminal, and then use Wireshark
to capture the packets between them (note: we will run Wireshark
on the attacker VM; make sure to select the correct network
interface corresponding to the \texttt{10.9.0.0/24} network). 
We use the following command to
run the \texttt{date} command on Host B from Host A via the \rsh  
remote shell.


\begin{lstlisting}
// On Trusted Server
$ rsh 10.9.0.5 date
\end{lstlisting}
 
The packet trace in this \rsh session is shown in the following. 
Here \texttt{10.9.0.6} is the Trusted Server's IP address, 
and \texttt{10.9.0.5} is X-Terminal's IP address.
If a packet does not carry any TCP data, the length information (i.e.
\texttt{Len=0}) is omitted. 

\begin{lstlisting}[caption={Packet trace of a \rsh session},
                  label={listing:rsh}]
# The first connection
   SRC IP    DEST IP   TCP Header
1  10.9.0.6  10.9.0.5  1023 -> 514 [SYN] Seq=778933536 
2  10.9.0.5  10.9.0.6  514 -> 1023 [SYN,ACK] Seq=10879102 Ack=778933537 
3  10.9.0.6  10.9.0.5  1023 -> 514 [ACK] Seq=778933537 Ack=10879103 
4  10.9.0.6  10.9.0.5  1023 -> 514 [ACK] Seq=778933537 Ack=10879103 Len=20
                       RSH Session Establishment
                       Data: 1022\x00seed\x00seed\x00date\x00
5  10.9.0.5  10.9.0.6  514 -> 1023 [ACK] Seq=10879103 Ack=778933557

# The second connection
6  10.9.0.5  10.9.0.6  1023 -> 1022 [SYN] Seq=3920611526 
7  10.9.0.6  10.9.0.5  1022 -> 1023 [SYN,ACK] Seq=3958269143 Ack=3920611527 
8  10.9.0.5  10.9.0.6  1023 -> 1022 [ACK] Seq=3920611527 Ack=3958269144 


# Going back to the first connection
9  10.9.0.5  10.9.0.6  514 -> 1023 [ACK] Seq=10879103 Ack=778933557 Len=1
                       Data: \x00
10 10.9.0.6  10.9.0.5  1023 -> 514 [ACK] Seq=778933557 Ack=10879104 
11 10.9.0.5  10.9.0.6  514 -> 1023 [ACK] Seq=10879104 Ack=778933557 Len=29
                       Data: Sun Feb 16 13:41:17 EST 2020
\end{lstlisting}


We can observe that a \rsh session consists of two TCP connections.  
The first connection is initiated by Host A (the client). 
An \texttt{rshd} process on Host B is listening to connection requests at port 514. 
Packets 1 to 3 are for the three-way handshake protocol. 
After the connection has been established, the client 
send \rsh data (including user IDs and commands) to the Host B (Packet 4).
The \texttt{rshd} process will authenticate the user, and 
if the user is authenticated, \texttt{rshd} initiates a
separate TCP connection with the client. 


The second connection is used for sending error messages. 
In the trace above, since there was no error, the connection was never used, 
but the connection must be successfully established, or \texttt{rshd} 
will not continue. Packets 6 to 7 are for the three-way handshake protocol
of the second connection. 


After the second connection has been established, 
Host B will send a zero byte to the client (using the first connection),
Host A will acknowledge the packet. After that, \texttt{rshd} on Host B
will run the command sent by the client, and the
output of the command will be sent back to the client, all via the 
first connection. 
Students can use Wireshark to capture a \rsh session, and study its
behaviors, before launching the Mitnick attack. 
We divide the attack task into two sub-tasks, each one focusing on one connection. 



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Task 2.1: Spoof the First TCP Connection}
\label{sec:first-conn}

The first TCP connection is initiated by the attacker via a spoofed SYN packet. As you can see
in Figure~\ref{fig:first-conn}, after X-Terminal receives the SYN packet, it will in turn send
a SYN+ACK packet to the trusted server. Since the server has been brought down, it will not
reset the connection. The attacker, which is on the same network, can sniff the packet and get
the sequence number.

\begin{figure}[htb]
\centering
\includegraphics[width=0.6\textwidth]{\mitnickFigs/mitnick-diagram-1.pdf}
\caption{First Connection}
\label{fig:first-conn}
\end{figure}


\paragraph{Step 1: Spoof a SYN packet.}
Students should write a program to spoof a SYN packet 
from the trusted server to X-Terminal (see Packet 1 in Listing~\ref{listing:rsh}). 
There are six standard 
TCP code bits, and they can be set in the flag field of the TCP header. 
The following code examples show how to set the flag field
and how to check whether certain bits are set in
the flag field. 

\begin{lstlisting}
# 'U': URG bit
# 'A': ACK bit
# 'P': PSH bit
# 'R': RST bit
# 'S': SYN bit
# 'F': FIN bit

tcp = TCP()

# Set the SYN and ACK bits
tcp.flags = "SA"

# Check whether the SYN and ACK are the only bits set
if tcp.flags == "SA": 

# Check whether the SYN and ACK bits are set
if 'S' in tcp.flags and 'A' in tcp.flags: 
\end{lstlisting}

It should be noted that the source port of the SYN packet 
must be from port \texttt{1023}. If a different port 
is used, \rsh will reset the connection 
after the connection is established.  If this step is successful, 
from Wireshark, we should be
able to see a SYN+ACK packet coming out of 
X-Terminal (see Packet 2 in Listing~\ref{listing:rsh}).


\paragraph{Step 2: Respond to the SYN+ACK packet.}
After X-Terminal sends out a SYN+ACK, the trusted server needs 
to send out an ACK packet to complete the three-way handshake protocol. 
The acknowledge number in the packet should be \texttt{S+1}, where 
\texttt{S} is the sequence number contained in the SYN+ACK packet. 
See Packet 3 in Listing~\ref{listing:rsh}.

In the actual Mitnick attack, the attacker could not see the SYN+ACK packet, because
it was sent to the trusted server, not to the attacker. 
That is why Mitnick had to guess the value of the sequence number.
In this lab, we allow students to get 
the sequence number via packet sniffing. 

Students need to write a sniff-and-spoof program using \texttt{Scapy} and run it
on the attacker's machine. Here is a skeleton of a sniff-and-spoof program that might be
useful. Please make sure to follow the restrictions described at the
beginning of the section, or you will get a penalty. 


\begin{lstlisting}
#!/usr/bin/python3
from scapy.all import *

x_ip      = "10.9.0.5"  # X-Terminal
x_port    = 514         # Port number used by X-Terminal

srv_ip    = "10.9.0.6"  # The trusted server
srv_port  = 1023        # Port number used by the trusted server

# Add 1 to the sequence number used in the spoofed SYN
seq_num     = 0x1000 + 1


def spoof(pkt):
  global seq_num   # We will update this global variable in the function

  old_ip  = pkt[IP]
  old_tcp = pkt[TCP]

  # Print out debugging information
  tcp_len = old_ip.len - old_ip.ihl*4 - old_tcp.dataofs*4  # TCP data length
  print("{}:{} -> {}:{}  Flags={} Len={}".format(old_ip.src, old_tcp.sport,
                         old_ip.dst, old_tcp.dport, old_tcp.flags, tcp_len))



  # Construct the IP header of the response
  ip = IP(src=srv_ip, dst=x_ip)

  # Check whether it is a SYN+ACK packet or not;
  #   if it is, spoof an ACK packet

  # ... Add code here ...

myFilter = 'tcp'   # You need to make the filter more specific
sniff(iface='br-****', filter=myFilter, prn=spoof)
                  (*@\reflectbox{\ding{218}} \textbf{You need to set the correct value here.}@*)   
\end{lstlisting}




\paragraph{Step 3: Spoof the \rsh data packet.}
Once the connection is established, the attacker needs to 
send \rsh data to X-Terminal.
The structure of the \rsh data is shown below.

\begin{lstlisting}
[port number]\x00[uid_client]\x00[uid_server]\x00[your command]\x00
\end{lstlisting}

The data has four parts: a port number, client's user ID, server's user ID,
and a command.
The port number will be used for the second connection (see Task 2.2). 
Both client and server's user ID is \texttt{seed} in our container. 
The four fields are separated by a byte 0.
Note that there is also a byte 0 at the end of the \rsh data. An example is given in the
following. In this example, we tell X-Terminal that we are going to listen on port 9090 for the
second connection and the command we want to run is \texttt{"touch /tmp/xyz"}. 

\begin{lstlisting}
data = '9090\x00seed\x00seed\x00touch /tmp/xyz\x00'
send(IP()/TCP()/data, verbose=0)
\end{lstlisting}
 

Students should modify the sniff-and-spoof program written in Step 2, so
an \rsh data packet is sent to X-Terminal (see Packet 4 
in Listing~\ref{listing:rsh}). 
If this step is successful, from Wireshark, we can see
that X-Terminal is going to initiate a TCP connection to the trusted server's port
\texttt{9090}, which is the port number specified in our \rsh data.  

In your report, please describe whether the \texttt{touch} command 
has been executed on X-Terminal or not. Please also 
include snapshots of your Wireshark. 


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Task 2.2: Spoof the Second TCP Connection}
\label{sec:second-conn}

\begin{figure}[htb]
\centering
\includegraphics[width=0.6\textwidth]{\mitnickFigs/mitnick-diagram-2.pdf}
\caption{Second Connection}
\label{fig:second-conn}
\end{figure}


After the first connection has been established, X-Terminal will initiate 
the second connection. This connection is used by \texttt{rshd} to send 
out error messages. In our attack, we will not use this connection, but
if this connection is not established, \texttt{rshd} will stop without 
executing our command. Therefore, we need to use spoofing 
to help X-Terminal and the trusted server finish establishing this connection. 
See Figure~\ref{fig:second-conn}. 


Students need to write another sniff-and-spoof program, which
sniffs the TCP traffic going to the port 9090 of the trusted server (assuming
\texttt{9090} is used in Task 2.1). When it sees a SYN packet,
it should respond with a SYN+ACK packet. See Packet 7 
in Listing~\ref{listing:rsh} for an example.

If both connections have been successfully established, \texttt{rshd} 
will execute the command contained in the \rsh data packet. Please 
check the \texttt{/tmp} folder and see whether \texttt{/tmp/xyz} is created
and whether its timestamp matches the present time. Please 
include your evidence in your report. 



% *******************************************
% SECTION
% ******************************************* 
\section{Task 3: Set Up a Backdoor}

In Task 2, we only run a \texttt{touch} command in the attack to prove that we can
successfully run a command on X-Terminal. If we want to run
more commands later, we can always launch the same attack. That is quite inconvenient. 

Mitnick did plan to come back to X-Terminal. Instead of launching the attack
again and again, he planted a backdoor in X-Terminal after his initial attack. 
This backdoor allowed him to log into X-Terminal normally anytime he wanted, without 
typing any password. 
To achieve this goal, as we have discussed in 
Section~\ref{subsec:configuration}, 
all we need to do is to add the string \texttt{"+ +"} to
the \texttt{.rhosts} file (in a single line). We can
include the following command in our \rsh data.

\begin{lstlisting}
echo + + > .rhosts
\end{lstlisting}

Students should replace the \texttt{touch} command in Task 2 with
the \texttt{echo} command above, and then repeat the attack.   
If the attack succeeds, the attacker should be able to 
remotely log into X-Terminal using the following command,
and no password is needed: 

\begin{lstlisting}
$ rsh [X-Terminal's IP]
\end{lstlisting}

The \texttt{rsh} program may have not been installed on the attacker container, 
but you can easily install it using the following commands:

\begin{lstlisting}
# apt-get update && apt-get -y install rsh-redone-client 
\end{lstlisting}


% *******************************************
% SECTION
% ******************************************* 
\section{Informe del Laboratorio}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/submission}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Agradecimientos}

\input{\commonfolder/acknowledgments}




\end{document}



