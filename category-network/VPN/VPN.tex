%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Copyright by Wenliang Du.                                       %%
%%  This work is licensed under the Creative Commons                %%
%%  Attribution-NonCommercial-ShareAlike 4.0 International License. %%
%%  To view a copy of this license, visit                           %%
%%  http://creativecommons.org/licenses/by-nc-sa/4.0/.              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\commonfolder}{../../common-files}

\input{\commonfolder/header}
\input{\commonfolder/copyright}


\usepackage{longtable}
\usepackage{enumitem}
\usepackage{stackengine}
\newcommand\xrowht[2][0]{\addstackgap[.5\dimexpr#2\relax]{\vphantom{#1}}}



\newcommand{\miniVPN}{{\tt MiniVPN}\xspace}
\newcommand{\hostu}{{\tt U}\xspace}
\newcommand{\hostv}{{\tt V}\xspace}


\newcommand{\vpnFigs}{./Figs}

\lhead{\bfseries SEED Labs -- Laboratorio de VPN}


\begin{document}

\begin{center}
{\LARGE Laboratorio de VPN}
\end{center}

\seedlabcopyright{2006 - 2016}



% *******************************************
% SECTION
% ******************************************* 
\section{Descripción}

Una Virtual Private Network (VPN) o Red Privada Virtual se usa para crear un ámbito privado de comunicación entre computadoras o para proveer ua extensión segura de una red privada dentro de una red insegura tal como Internet. VPN es una tecnología ampliamente usada. Una VPN puede ser construída sobre IPSec o TLS/SSL (Transport Layer Security/Secure Socket Layer). 
Son dos estrategias diferentes para construir VPNs. En este laboratorio, nos centramos en VPNs basadas en  TLS/SSL. Este tipo de VPNs son conocidas como VPNs TLS/SSL.

El objetivo de este laboratorio es que los estudiantes profundizen los conocimientos en redes y la tecnologías que hacen seguras a las VPNs. Para lograr este cometido, se les pedirá a los estudiantes que implementen una simple VPN TLS/SSL.
Aunque esta VPN es sencilla, esta cinluya todos los elementos esenciales de una VPN. El diseño y la implementación de una las VPNs TLS/SSL ejemplifican
una serie de principios de seguridad, incluidos los siguientes:

\begin{itemize}[noitemsep]
\item Virtual Private Network (VPN)
\item TUN/TAP, and IP tunneling 
\item Enrutamiento
\item Certificados Public-key cryptography, PKI, y X.509 
\item Programación TLS/SSL
\item Autenticación
\end{itemize}


\paragraph{Lecturas y Videos.}
Para una cobertura más detallada sobre VPN, PKI, y TLS puede consultar:

\begin{itemize}
\item Capítulos 19, 24, y 25 de libro de SEED, \seedbook
\item Sección 8 del curso de SEED en Udemy, \seedisvideo
\end{itemize}


\paragraph{Laboratorios Relacionados.}
Tenemos un laboratorio separado sobre PKI y otro sobre TLS. Se recomienda a los estudiantes terminar esos laboratorios de criptografía antes de empezar a trabjar con este laboratorio. Si los estudiantes están solamente interesados en la sección de VPN Tunneling (sin incluir la parte de criptografía), deberían de consultar el laboratario de VPN Tunneling en su lugar, en vez de este.

\paragraph{Entorno de Laboratorio.} 
\seedenvironmentB
Necesitamos usar el paquete \openssl en este laboratorio. Este paquete incluye los archivos de encabezado, librerías y comandos. Este paquete está instalado en nuestra imagen de la Máquina Virtual.




\newpage
% *******************************************
% SECTION
% ******************************************* 
\section{Tareas del Laboratorio}

En este laboratorio, los estudiantes deberán de implementar una VPN simple para \linux. La llamaremos {\tt miniVPN}. 


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 1: Setup de la Máquina Virtual}

Crearemos un Túnel VPN entre la máquina cliente y el gateway, permitiéndole a la máquina el acceso seguro a la red privada a través del gateway.
Necesitaremos al menos tres Máquinas Virtuales: el cliente VPN (también usado como Host U), el servidor VPN (gateway), y el host en la red privada (Host V).
El setup de esta red es ilustrado en la Figura \ref{vpn:fig:host2gateway}.

\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.9\textwidth]{\vpnFigs/Host2Gateway.pdf}
\end{center}
\caption{VM setup for this lab}
\label{vpn:fig:host2gateway}
\end{figure}
 

En la práctiva, el cliente VPN y el servidor VPN estarán conectados vía Internet.
Para no complicar las cosas, conectaremos estas dos máquinas a la misma LAN, es decir la LAN simulará la Internet.
Usaremos el adaptador ``NAT Network'' para esta LAN.
La tercera máquina, Host V, es una máquina dentro de la red privada. Los usuarios en el Host U (fuera de la red privada) quieren comunicarse con el Host V usando el Túnel VPN. Para simular esta configuración, conectaremos el Host V al servidor VPN (también será el gateway) a través de una  ``Internal Network''. En este escenario de configuración, el Host V no es accesible directamente desde Internet; o desde el Host U.

Note que si una máquina virtual usa el modo ``Internal Network'', VirtualBox no ofrece DHCP a esta, por lo que la máquina virtual debe ser configurada de forma estática. Para hacer esto haga click en el ícono de network en la esquina derecha superior del escritorio y seleccione \texttt{"Edit Connections"}. Verá una lista de \texttt{"Wired connections"}, una por cada adaptador de red usado por la máquina virtual.
Para el Host V, hay sólo una conexión pero para el servidor VPN, usaremos dos. Para asegurarse que ud. selecciona el correcto que corresponde al adaptador de ``Internal Network'', puede chequear la dirección MAC mostrada en el pop-up después de haber elejido editar la conexión.
Compare esta dirección MAC con la que ud. obtiene de  \texttt{ifconfig}, y así sabrá si es la correcta o no.

Después de haber seleccionado la conexión que se debe de editar, seleecione el tab que dice \texttt{"ipv4 Settings"} y elija el método Manual, en vez del que se usa por defecto que es \texttt{"Automatic (DHCP)"}. Haga click en el botón de \texttt{"Add"}  para configurar la dirección IP para la máquina virtual. Para más detalles vea la Figura  \ref{vpn:fig:internalnetwork}.



\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.8\textwidth]{\vpnFigs/InternalNetwork.pdf}
\end{center}
\caption{Configuración Manual de la IP para el adaptador \texttt{"Internal Network"} del servidor VPN.}
\label{vpn:fig:internalnetwork}
\end{figure}
 


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 2: Creando un Túnel VPN usando TUN/TAP}

Activar la tecnología para las VPNs TLS/SLL es TUN/TAP, las cuales son ampliamente implementadas en los sistemas operativos modernos.
TUN y TAP son drivers del kernel de redes virtuales; implementan un dispositivo de red que es soportado por el software.
TAP simula un dispositivo ethernet y opera con paquetes de capa 2 como Frames Ethernet; TUN simula un dispositivo de capa red y opera con paquetes de capa 3 como paquetes IP.
Con TUN/TAP, podemos crear interfaces de red virtuales.

Un programa en el espacio de usuario está frecuentemente atachada a una interfaz de red virtual TUN/TAP.
Los paquetes enviados por el sistema operativo usando la interfaz de red TUN/TAP son entregados al programa en espacio de usuario. Por otro lado los paquetes enviados por el programa usando la interfaz de red TUN/TAP son inyectados dentro del stack de red del sistema operativo, y hace parecer que los paquetes provienen de un origen externo a través de la interfaz de red virtual.

Cuando un programa se atacha a la interfaz TUN/TAP, los paquetes IP que envía la máquina a esta interfaz serán canalizados dentro del programa; por otro lado, los paquetes IP que el programa envía a la interfaz serán canalizado dentro de la máquina, como si ellos hubieran venido de afuera de la red a través de esta red de interfaz virtual. El programa puede usar las llamadas al sistema estandar  {\tt read()} y {\tt write()} para recibir estos paquetes desde la interfaz virtual o para enviarlos a través de la misma.

Hemos creado un cliente VPN de ejempolo llamado (\texttt{vpnclient}) y un servidor  (\texttt{vpnserver}), ambos pueden ser descargados del sitio oficial del laboratorio.
Los programas son explicados en detalle en el Capítulo 16 del libro de SEED llamado \textit{Computer \& Internet Security: A Hands-on Approach, 2nd Edition}; este Capítulo también explica como funciona TUN/TAP y como usarlos para crear una VPN.


\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.9\textwidth]{\vpnFigs/ClientServerTunnel.pdf}
\end{center}
\caption{Cliente y Servidor VPN}
\label{vpn:fig:client_server}
\end{figure}

Los programas \texttt{vpnclient} y \texttt{vpnserver} son los dos puntos finales del Túnel VPN. Ellos se comunican entre sí por medio TCP o UDP a través de sockets, esto es ilustrado en la Figura \ref{vpn_firewall:fig:client_server}. En nuestro código de ejemplo, elegimos usar UDP por un tema de simplicidad. La línea punteada entre el cliente y el servidor demarca el camino para el Túnel VPN.
Los programas del cliente y servidor VPN se conectan al sistema de hosting a través de la interfaz TUN, a través de la cual ellos hacen dos cosas: (1) obtienes los paquetes IP del sistema de hosting, por lo que los paquetes pueden ser enviados a través del Túnel, (2) obtiene los paquetes IP desde el Túnel y los forwardea hacia el sistema de hosting, el cual forwardeará los paquetes hacia su destino final.
El siguiente procedimiento describe como crear un Túnel VPN usando los programas \texttt{vpnclient} y \texttt{vpnserver}.


\paragraph{Paso 1: Iniciar el Servidor VPN.} 
Primer iniciamos el servidor VPN ejecutando \texttt{vpnserver} en la máquina virtual del servidor.
Después de que el programa se ejecute, aparecerá una interfaz virtual de red TUN en el sistema (puede verla usando el comando \texttt{"ifconfig -a"}; en la mayoría de los sistema el nombre de esta interfaz será \texttt{tun0} pero puede ser que sea diferente, sea como sea será \texttt{tunX} donde \texttt{X} es un número).
Esta nueva interfaz no está configurada todavía, por lo que necesitamos hacerlo, asignándole una dirección IP. Usaremos \texttt{192.168.53.1} para esta interfaz, pero puede usar otra IP.

Ejecute los siguientes comandos. El primer comando iniciará el programa servidor, el segundo comando asignará la dirección IP a la interfaz \texttt{tun0} y la activará. Debería de notar que el primer comando bloqueará y se quedará a la espera por conexiones, por lo que debemos de correr el segundo comando en una nueva ventana.

\begin{lstlisting}
$ sudo ./vpnserver

Run the following command in another window:
$ sudo ifconfig tun0 192.168.53.1/24 up
\end{lstlisting}

Al menos que se configura de una forma especial, una máquina actuará como host y no como gateway. El servidor VPN necesita forwardear los paquetes hacia otros destinos, por lo que necesita funcionar como un gateway. Necesitamos activar el IP forwarding para que la máquina se comporte como un gateway.
IP Forwarding puede ser activado usando el siguiente comando:

\begin{lstlisting}
$ sudo sysctl net.ipv4.ip_forward=1
\end{lstlisting}



\paragraph{Paso 2: Iniciar el Cliente VPN.}
Procederemos a ejecutar el cliente VPN en la máquina virtual cliente. Correremos el siguiente comando en la máquina. El primer comando se encargará de conectar al cliente con el servidor VPN (la IP del servidor está hardcodeada dentro del programa, ud. debe de cambiarla a la que corresponde). Este comando será bloqueante por lo que necesitamos abrir otra ventana para configurar la interfaz \texttt{tun0} creada por el cliente VPN.
A la interfaz \texttt{tun0} le asignaremos la IP \texttt{192.168.53.5}.


\begin{lstlisting}
On VPN Client VM:
$ sudo ./vpnclient 

Run the following command in a different window
$ sudo ifconfig tun0 192.168.53.5/24 up
\end{lstlisting}



\paragraph{Paso 3: Configurar el Enrutamiento en las máquinas del Cliente VPN y el Servidor VPN:} 
After the above two steps, the tunnel will be established. 
Before we can use the tunnel, we need to set up routing 
paths on both client and server machines to direct the intended traffic through
the tunnel. On the client machine, we need to direct all the packets going
to the private network ({\tt 192.168.60.0/24}) towards the \texttt{tun0}
interface, from where the packets can be forwarded through the VPN tunnel.
Without this setup, we will not be able to access the private network at
all. We can use the \texttt{route} command to add an routing entry. The
following example shows how to route the \texttt{10.20.30.0/24}-bound
packets to the interface \texttt{eth0}. 

\begin{lstlisting}
$ sudo route add -net 10.20.30.0/24 eth0
\end{lstlisting}


On both client and server machines, we also need to 
set up a routing entry so all the traffic going to the \texttt{192.168.53.0/24}
network are directed to the \texttt{tun0} interface. This entry will usually be 
automatically added when we assign \texttt{192.169.53.X} to
the \texttt{tun0} interface.  If for some reasons it is not added, 
we can use the \texttt{route}  command to add it.




\paragraph{Paso 4: Configurar el Enrutamiento en Host V.} 
When Host V replies to a packet sent from Host U, it needs to route the
packets to the VPN Server VM, from where, it can be fed into
the VPN tunnel toward the other end. You need to find out what entry to
add, and then use  the \texttt{route} command to add the routing entry. 
Hint: when Host V receives a packet from Host U (via the tunnel), you need to know what the
source IP is in the packet; in the reply packet, the source IP becomes the
destination IP, which will be used by the routing table. Therefore, you
need to figure out the source IP of the packets from U to V. It is your
task to figure this out and set the routing correctly in this step.


\paragraph{Paso 5: Testeando el Túnel VPN.:} After everything is set up, we can 
access Host V from Host U via the tunnel. 
Please conduct the following tests using \texttt{ping} and \texttt{telnet}; 
please  report your results. You should use Wireshark to 
capture the network traffics on all the interfaces on the client VM, 
and pinpoint which packets are part of the tunnel traffic, and
which packets are not the tunnel traffic. 

\begin{lstlisting}
On Host U:
$ ping 192.168.60.101
$ telnet 192.168.60.101
\end{lstlisting}


\paragraph{Paso 6: Hacer un Test Breaking del Túnel.} 
On Host U, \texttt{telnet} to \texttt{Host V}. While keeping the
\texttt{telnet} connection alive, we break the VPN tunnel. We then type something
in the \texttt{telnet} window, and report what you observe. 
We then reconnect the VPN tunnel. What is going to happen to the
\texttt{telnet} connection? Will it be broken or resumed?
Please describe and explain your observations. 



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 3: Encriptando el Túnel}


At this point, we have created an IP tunnel, but our tunnel is not protected. 
Only after we have secured this tunnel, can we call it a VPN tunnel. 
This is what we are going to achieve in this task. 
To secure this tunnel, we need to achieve two 
goals, confidentiality and integrity. 
The confidentiality is achieved using encryption, i.e.,
the contents that go through the tunnel is encrypted. 
The integrity goal ensures that nobody can tamper with 
the traffic in the tunnel or launch a replay attack. 
Integrity can be achieved using 
Message Authentication Code (MAC). 
Both goals can be achieved using Transport Layer Protocol (TLS). 


TLS is typically built on top of TCP. The sample VPN client and server 
programs in Task 2 use UDP, so we first need to 
replace the UDP channel in the sample code with a TCP channel, and then establish a
TLS session between the two ends of the tunnel.  A sample TLS client
and server program (\texttt{tlsclient} and \texttt{tlsserver})   
is provided in a zip file that can be downloaded from the website. 
Instructions on how to compile and run the code
is provided in the README file included in the zip file. 
For detailed explanation of the sample
code, please read Chapter 25 of the SEED book (\textit{Computer \& Internet Security: A
Hands-on Approach, 2nd Edition}). In your demonstration, you need to use Wireshark to
capture the traffic inside the VPN tunnel, and show that the traffic is
indeed encrypted. 



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 4: Autenticando el Servidor VPN}


Before a VPN is established, the VPN client must authenticate
the VPN server, making sure that the server is not a fraudulent 
one. On the other hand, the VPN server must authenticate the
client (i.e. user), making sure that the user has 
the permission to access the private network. 
In this task, we implement the server authentication; 
the client authentication is in the next task. 

A typical way to authenticate servers is to use public-key
certificates. The VPN server needs to first get a public-key 
certificate from a Certificate Authority (CA).
When a client makes a connection to the VPN 
server, the server will use the certificate to prove it 
is the intended server.  
The HTTPS protocol uses this approach to 
authenticate web servers, ensuring that you are talking to 
an intended web server, not a fake one. 


In this lab, \miniVPN should use such a method to authenticate the
VPN server. We can implement an authentication protocol (such
as TLS/SSL) from the scratch, but fortunately, \texttt{openssl} has 
taken care most of the work for us. We just need to configure 
our TLS session properly, so \texttt{openssl} can conduct the authentication
automatically for us.  

There are three important steps in server authentication: (1) verifying that
the server certificate is valid, (2) verifying that the server 
is the owner of the certificate, and (3) verifying that the server is
the intended server (for example, if the user intends to visit 
\texttt{example.com}, we need to ensure that the server is indeed 
\texttt{example.com}, not another site). Please point out what lines of the
code in your program carry out the above verifications. 
In your demonstration, you need to demonstrate two different cases regarding the 
third verification: a successful server authentication where the 
server is the intended server, and a failed server authentication where 
the server is not the intended server. 


\paragraph{Note:} Our \miniVPN program should be able to communicate with
VPN servers on different machines, so you cannot hardcode the hostname of 
the VPN server in the program. The hostname needs to be typed in from the
command line. This name represents the user's intention, so it should be
used in the verification. This name should also be used to find the IP
address of the server. Section~\ref{vpn:subsec:hostnametoip} provides a sample 
program to show you how to get the IP address for a given hostname. 


\paragraph{Our sample TLS client and server programs.} Server authentication
is implemented in the sample programs provided by us. Part of the authentication requires the
certificate of the CA who issues the server certificate. 
We have put two CA certificates in the \texttt{./ca\_client} folder: one is the 
CA that issues our server's certificate (the hostname of the server
is \url{vpnlabserver.com}), 
and the other is the CA that issues Google's certificate. 
Therefore, the sample TLS client program can talk to 
our own server, as well as Google's HTTPS server: 

\begin{lstlisting}
$ ./tlsclient vpnlabserver.com 4433
$ ./tlsclient www.google.com 443
\end{lstlisting}


\textbf{It should be noted} that students should not use 
\texttt{vpnlabserver.com} from the sample code as their VPN server name;
instead, \textbf{they should include their last name} in the server 
name. Students should generate their own CA in order to create 
server certificates. The objective of this requirement is to differentiate
student's work.


To use our client to talk to an HTTPS server, we need to get its CA's certificate, 
save the certificate in the \texttt{./ca\_client} folder, and create a symbolic link to it~(or
rename it) using the hash value generated from its subject field.
For example, to enable our client to talk to Google, who gets 
its certificate from a root CA called ``GeoTrust Global CA'', we
get this root CA's certificate (\texttt{GeoTrustGlobalCA.pem})  
from the Firefox browser,
and run the following command to get its hash and then set up the symbolic link:

\begin{lstlisting}
$ openssl x509 -in GeoTrustGlobalCA.pem -noout -subject_hash
(*@\textbf{2c543cd1}@*)

$ ln -s GeoTrustGlobalCA.pem (*@\textbf{2c543cd1.0}@*)
$ ls -l
lrwxrwxrwx 1 ... 2c543cd1.0 -> GeoTrustGlobalCA.pem
lrwxrwxrwx 1 ... 9b58639a.0 -> cacert.pem
-rw-r--r-- 1 ... cacert.pem
-rw-r--r-- 1 ... GeoTrustGlobalCA.pem
\end{lstlisting}






% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Task 5: Authenticating the VPN Client}

Accessing the machines inside a private network is a privilege that is only
granted to authorized users, not to everybody. Therefore, only authorized
users are allowed to establish a VPN tunnel with the VPN server. 
In this task, authorized users are those who have a valid account on the VPN server.
We will therefore use the standard password authentication to authenticate
users. Basically, when a user tries to establish a VPN tunnel 
with the VPN server, the user will be asked to provide a user name and a
password. The server will check its shadow file (\texttt{/etc/shadow}); 
if a matching record is found, the user is authenticated, and the 
VPN tunnel will be established. If there is no match, the server will
break its connection with the user, and thus no tunnel will be established. 
See Section~\ref{vpn:subsec:auth} for 
sample code on how to authenticate users using the shadow file.


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Task 6: Supporting Multiple Clients}


In the real world, one VPN server often supports multiple VPN tunnels. 
Namely, the VPN server allows more than one clients to 
connect to it simultaneously, with each client having its own VPN tunnel (and thus
its own TLS session). Our \miniVPN should support 
multiple clients. 


\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.8\textwidth]{\vpnFigs/MultiClient.pdf}
\end{center}
\caption{Supporting multiple VPN clients}
\label{vpn:fig:MultiClient}
\end{figure}
 

In a typical implementation, the VPN server process (the parent
process) will create a child process for each tunnel (see  
Figure~\ref{vpn:fig:MultiClient}).
When a packet comes from the tunnel, its corresponding child process 
will get the packet, and forward it to the TUN interface. 
This direction is the same regardless of whether multiple clients are 
supported or not. It is the other direction that becomes challenging. 
When a packet arrives at the TUN interface (from the private network), 
the parent process will get the packet, now it needs to figure out which
tunnel this packet should go to. You need to think about how to implement
this decision-making logic. 

Once the decision is made and a tunnel is selected, the parent process
needs to send the packet to the child process, to which
the selected tunnel is attached. This calls for IPC (Inter-Process Communication). A
typical approach is to use pipes. We provide a sample program in
Section~\ref{vpn:subsec:pipe} to demonstrate how to use pipes for IPC.


Child processes need to monitor this pipe interface, and read data from it if there 
are data. Since child processes also need to watch out for data coming from the socket
interface, they need to simultaneously monitor multiple interfaces.    
Section~\ref{vpn:subsec:select} shows how to achieve that. 




% *******************************************
% SECTION
% ******************************************* 
\section{Guidelines}



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Displaying TLS Traffic in Wireshark}

Wireshark identifies TLS/SSL traffic based on port numbers. It knows 
\texttt{443} is the default port number for HTTPS, but our VPN server listens to a different
and non-standard
port number. We need to let Wireshark know that; otherwise, Wireshark will not label our 
traffic as SSL/TLS traffic. Here is what we can do: 
go to the \texttt{Edit} menu in Wireshark, and 
click  \texttt{Preferences}, \texttt{Protocols}, \texttt{HTTP}, and 
then find the \texttt{"SSL/TLS Ports"} entry. Add your SSL
server port. For example, we can change the content 
of the entry to  \texttt{443,4433}, where \texttt{4433} is the port used by our SSL server. 


\paragraph{Displaying decrypted traffic.} The approach shown above only 
gets Wireshark to recognize the traffic as TLS/SSL traffic; Wireshark cannot 
decrypt the encrypted traffic. For debugging purposes, we would like to see the decrypted
traffic. Wireshark provides such a feature; all we need to do is to provide the 
server's private key to Wireshark, and Wireshark will automatically 
derive the session keys from the TLS/SSL handshake protocol, and use these
keys to decrypt traffic. To provide the server's private key
to Wireshark, do the following:


\begin{lstlisting}
 Click Edit -> Preferences -> Protocols -> SSL 
 Find the "RSA key list", and click the Edit button
 Provide the required information about the server, see this example:
      IP Address: 10.0.2.65
      Port:       4433
      Protocol:   ssl
      Key File:   /home/seed/vpn/server-key.pem  (privat key file)
      Password:   deesdees
\end{lstlisting}


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Getting IP Address from Hostname}
\label{vpn:subsec:hostnametoip}


Given a hostname, we can get the IP address for this name. 
In our sample \texttt{tlsclient} program, we use
the \texttt{gethostbyname()} function to get the IP address. However, this
function is obsolete because it does not support IPV6. 
Applications should use \texttt{getaddrinfo()} instead. The following 
example shows to how to use this function to get IP addresses. 


\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>

struct addrinfo  hints, *result;

int main() {

  hints.ai_family = AF_INET; // AF_INET means IPv4 only addresses

  int error = getaddrinfo("www.example.com", NULL, &hints, &result);
  if (error) {
      fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(error));
      exit(1);
  }

  // The result may contain a list of IP address; we take the first one.
  struct  sockaddr_in*  ip = (struct sockaddr_in *) result->ai_addr;
  printf("IP Address: %s\n", (char *)inet_ntoa(ip->sin_addr));

  freeaddrinfo(result);
  return 0;
}
\end{lstlisting}
 


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Authentication Using the Shadow File}
\label{vpn:subsec:auth}


The following program shows how to authenticate a user using 
the account information stored in the shadow file.
The program uses \texttt{getspnam()} to get 
a given user's account information from the shadow file, including the 
hashed password. It then uses \texttt{crypt()} to 
hash a given password and see whether the result matches with
the values fetched from the shadow file. If so, the user name and the password match, 
and the authentication is successful. 


\begin{lstlisting}
#include <stdio.h>
#include <string.h>
#include <shadow.h>
#include <crypt.h>

int login(char *user, char *passwd)
{
    struct spwd *pw;
    char *epasswd;

    pw = getspnam(user);
    if (pw == NULL) {
        return -1;
    }

    printf("Login name: %s\n", pw->sp_namp);
    printf("Passwd    : %s\n", pw->sp_pwdp);

    epasswd = crypt(passwd, pw->sp_pwdp);
    if (strcmp(epasswd, pw->sp_pwdp)) {
        return -1;
    }

    return 1;
}

void main(int argc, char** argv)
{
   if (argc < 3) {
       printf("Please provide a user name and a password\n");
       return;
   }

   int r = login(argv[1], argv[2]);
   printf("Result: %d\n", r);
}
\end{lstlisting}


We can compile the code above and run it with a user name and a password. 
It should be noted that the root privilege is needed when reading from the 
shadow file. See the following commands for compilation and execution.

\begin{lstlisting}
$ gcc login.c -lcrypt
$ sudo ./a.out seed dees
\end{lstlisting}
 
It should be noted that we use \texttt{-lcrypt} in the above compilation;
we used \texttt{-lcrypto} when compiling our TLS programs. The
\texttt{crypt} and \texttt{crypto} are two different libraries, so this is
not a typo.


\vspace{0.2in}
% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Inter-Process Communication Using Pipe}
\label{vpn:subsec:pipe}

The following program shows how a parent process sends data to its child process using 
pipe. The parent process creates a pipe using \texttt{pipe()} in Line~\ding{192}. 
Each pipe has two ends: the input end's file descriptor is \texttt{fd[0]}, and 
the output end's file descriptor is \texttt{fd[1]}. 

After the pipe is created, a child process is spawned using \texttt{fork()}. 
Both parent and child processes have the
file descriptors associated with the pipe. They can send data to each other using the 
the pipe, which is bi-directional. However, we will only use this pipe to send data from the
parent process to the child process, and the parent will not read anything from the pipe, so 
we close the input end \texttt{fd[0]} in the parent process. Similarly, the child does not
send anything via the pipe, so it closes the output end \texttt{fd[1]}.  
At this point, we have established a uni-directional pipe from the parent process to the child process. 
To send data via the pipe, the parent process writes to \texttt{fd[1]} (see Line~\ding{193});
to receive data from the pipe, the child process reads from \texttt{fd[0]} (see
Line~\ding{194}).  



\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main(void)
{
  int     fd[2], nbytes;
  pid_t   pid;
  char    string[] = "Hello, world!\n";
  char    readbuffer[80];

  pipe(fd);                                                  (*@\ding{192}@*)
        
  if((pid = fork()) == -1) {
       perror("fork");
       exit(1);
  }

  if(pid>0) { //parent process 
       close(fd[0]); // Close the input end of the pipe. 

       // Write data to the pipe.
       write(fd[1], string, (strlen(string)+1));             (*@\ding{193}@*)
       exit(0);
  }
  else { //child process
       close(fd[1]); // Close the output end of the pipe.

       // Read data from the pipe.
       nbytes = read(fd[0], readbuffer, sizeof(readbuffer)); (*@\ding{194}@*)
       printf("Child process received string: %s", readbuffer);
  }
  return(0);
}
\end{lstlisting}
 



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Using \texttt{select} to Monitor Multiple Input Interfaces}
\label{vpn:subsec:select}

Our VPN program needs to monitor multiple interfaces, including the TUN interface, the socket
interface, and sometimes, the pipe interface.   
All these interfaces are represented by file descriptors, so we need to 
monitor them to see whether there are data coming from them. 
One way to do that is to keep polling them, and
see whether there are data on each of the interfaces. The performance of this approach is
undesirable, because the process has to keep running in an idle loop when there is no data.
Another way is to read from an interface.  By default, read is blocking, i.e., the process will
be suspended if there are no data. When data become available, the process will be unblocked,
and its execution will continue. This way, it does not waste CPU time when there is no data.

The read-based blocking mechanism works well for one interface. If a process is waiting on
multiple interfaces, it cannot block on just one of the interfaces. It has to block on all of
them altogether.  \linux has a system call called \texttt{select()}, which
allows a program to monitor multiple file descriptors simultaneously.
To use \texttt{select()}, we need to store all the file descriptors to be monitored in a set
using the \texttt{FD\_SET} macro~(see Lines~\ding{192} and~\ding{193} in
the code below).  We then give the set to the \texttt{select()} system
call~(Line~\ding{194}), which will block the process until data are available on one of the
file descriptors in the set.  We can then use the \texttt{FD\_ISSET} macro to figure out which
file descriptor has received data. In the following code example, 
we use \texttt{select()} to monitor a \texttt{TUN} and a socket file
descriptor.


\begin{lstlisting}
fd_set readFDSet;
int ret, sockfd, tunfd;

FD_ZERO(&readFDSet);
FD_SET(sockfd, &readFDSet);                                (*@\ding{192}@*)
FD_SET(tunfd, &readFDSet);                                 (*@\ding{193}@*)
ret = select(FD_SETSIZE, &readFDSet, NULL, NULL, NULL);    (*@\ding{194}@*)

if (FD_ISSET(sockfd, &readFDSet){
        // Read data from sockfd, and do something.
}

if (FD_ISSET(tunfd, &readFDSet){
        // Read data from tunfd, and do something. 
}
\end{lstlisting}



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{An example: using {\tt telnet} in our VPN} 

To help you fully understand how packets from an application flow to its destination
through our \miniVPN, we have drawn two figures to illustrate the complete 
packet flow path when users run {\tt telnet 10.0.20.100} from a host machine,
which is the Point A of a host-to-gateway VPN. The other end of the VPN is 
on a gateway, which is connected to the {\tt 10.0.20.0/24} network, where 
our {\tt telnet} server {\tt 10.0.20.100} resides. 


Figure~\ref{fig:example1_host_2_gateway} shows how a packet flow 
from the {\tt telnet} client to the server. 
Figure~\ref{fig:example2_host_2_gateway} shows how a packet flow 
from the {\tt telnet} server back to the client. 
We will only describe the path in Figure~\ref{fig:example1_host_2_gateway}
in the following. The return path is self-explained from
Figure~\ref{fig:example2_host_2_gateway} once you have understood 
the path in Figure~\ref{fig:example1_host_2_gateway}. 
\begin{enumerate}
\item The data of the packet starts from the {\tt telnet} program. 
\item The kernel will construct an IP packet, with the destination
      IP address being {\tt 10.0.20.100}. 
\item The kernel needs to decide which network interface the packet should 
      be routed through: {\tt eth1} or {\tt tun0}. You need to set up your routing
      table correctly for the kernel to pick {\tt tun0}. Once the decision is 
      made, the kernel will set the source IP address of the packet using
      the IP address of the network interface, which is {\tt 10.0.4.1}.

\item The packet will reach our VPN program (Point A) through the virtual 
      interface {\tt tun0}, then it will be encrypted, and then be sent back
      to the kernel through a UDP port (not through the {\tt tun0} interface).
      This is because our VPN program use the UDP as our tunnel.
      
\item The kernel will treat the encrypted IP packet as UDP data, construct
      a new IP packet, and put the entire encrypted IP packet as its UDP
      payload. The new IP's destination address will be the other end of the
      tunnel (decided by the VPN program we write); in the figure, the 
      new IP's destination address is {\tt 128.230.208.97}.


\item You need to set up your routing table correctly, so the new packet 
      will be routed through the interaface {\tt eth1}; therefore, the 
      source IP address of this new packet should be {\tt 209.164.131.32}.


\item The packet will now flow through the Internet, with the original 
      {\tt telnet} packet being entirely encrypted, and carried in the 
      payload of the packet. This is why it is called a {\em tunnel}.

\item The packet will reach our gateway {\tt 128.230.208.97} through
      its interface {\tt eth1}.


\item The kernel will give the UDP payload (i.e. the encrypted IP packet)
      to the VPN program (Point B), which is waiting for UDP data. 
      This is through the UDP port.


\item The VPN program will decrypt the payload, and then feed the decrypted
      payload, which is the original {\tt telnet} packet,
      back to the kernel through the virtual network interface {\tt tun0}.

\item Since it comes through a network interface, the kernel will treat
      it as an IP packet (it is indeed an IP packet), look at its destination
      IP address, and decide where to route it. Remember, the destination
      IP address of this packet is {\tt 10.0.20.100}.
      If your routing table is 
      set up correctly, the packet should be routed through {\tt eth2},
      because this is the interface that connects to the {\tt 10.0.20.0/24}
      network. 

\item The {\tt telnet} packet will now be delivered to its final 
      destination {\tt 10.0.20.100}.




\end{enumerate}

\begin{figure*}
\centering
\begin{tabular}[t]{c}
\subfigure[An Example of packet flow from telnet client to server in Host-to-Gateway Tunnel]
{
   \label{fig:example1_host_2_gateway}
   \includegraphics*[viewport=0.7in 1.7in 8.7in 7.3in,width=6.0in]{\vpnFigs/vpn_h2g_details.pdf}
}
\\
\subfigure[An Example of packet flow from telnet server to client in Host-to-Gateway Tunnel]
{
    \label{fig:example2_host_2_gateway}
    \includegraphics*[viewport=1.6in 1.6in 9.6in 7.2in,width=6.0in]{\vpnFigs/vpn_h2g_details_reply.pdf}
}
\end{tabular}
\caption{An Example of Packet Flow in VPN.}
\label{fig:example_packetflow}
\end{figure*}





% *******************************************
% SECTION
% ******************************************* 
\section{Informe del Laboratorio y Demostraciones}
\input{demo}



% *******************************************
% SECTION
% ******************************************* 
\section{Checklist de la Demostración}


During the COVID-19 outbreak, we cannot do in-person demo. Although doing demo
online is an option, we decide to experiment with a different approach: asking students to 
record their demo and submit the video file. To help them conduct a self-guided demo,
we provide a checklist in Table~\ref{vpn:table:checklist}. Even if we do in-person demo, this checklist 
is still quite useful. 

\input{Demo_Checklist}


\section*{Agradecimientos}

\input{\commonfolder/acknowledgments}


\end{document}


