%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Copyright by Wenliang Du.                                       %%
%%  This work is licensed under the Creative Commons                %%
%%  Attribution-NonCommercial-ShareAlike 4.0 International License. %%
%%  To view a copy of this license, visit                           %%
%%  http://creativecommons.org/licenses/by-nc-sa/4.0/.              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\commonfolder}{../../common-files}

\input{\commonfolder/header}
\input{\commonfolder/copyright}


\lhead{\bfseries SEED Labs -- Laboratorio de Race Condition}

\def \code#1 {\fbox{\scriptsize{\texttt{#1}}}}

\begin{document}

\begin{center}
{\LARGE Laboratorio de Race Condition}
\end{center}


\seedlabcopyright{2006 - 2020}



% *******************************************
% SECTION
% ******************************************* 
\section{Descripción General}

El objetivo de este laboratorio es que el estudiante gane experiencia en vulnerabilidades de Race Condition, pudiendo pasar de la teoría a la práctica.
Una vulnerabilidad de Race Condition ocurre cuando múltiples procesos quieren acceder y manipular un determinado dato al mismo tiempo, el resultado de la ejecución será indeterminado, ya que estará dado por el orden en que esos procesos realizaron el acceso. Si un programa tiene una vulnerabilidad del tipo Race Condition, un atacante puede correr un conjunto de procesos en paralelo para hacer un ``race'' contra el programa vulnerable, con la intención de alterar el comportamiento del programa.

Para este laboratorio, los estudiantes tendrán disponible un programa con una vulnerabilidad del tipo Race Condition; La tarea será desarrollar un exploit para explotar esta vulnerabilidad y obtener privilegios de root. A su vez cada uno de los estudiantes serán guiados a fin de que puedan atravesar diferentes tipos mitigaciones que son usadas para contrarrestar los ataques de Race Condition.
Los estudiantes necesitarán evaluar en que situaciones sus ataques serán exitosos y en cuales no, así también explicando el porque de este resultado. 
Este laboratorio cubre los siguientes tópicos:

\begin{itemize}[noitemsep]
\item Vulnerabilidad de Race condition
\item Protecciones: Sticky symlink
\item Principio del menor privilegio
\end{itemize}




\paragraph{Lecturas y Videos.}
Los ataques de race condition son abordados en más detalle en los siguientes recursos:

\begin{itemize}
\item Capítulo 7 del Libro de SEED, \seedbook
\item Sección 6 del curso de SEED en Udemy, \seedcsvideo
\end{itemize}


\paragraph{Tópicos relacionados.}
Existen tres laboratorios relacionados a Race Condition. Uno es el laboratorio de Dirty COW, que explota una vulnerabilidad de Race Condition dentro del kernel del sistema operativo (El Capítulo 8 del libro de SEED cubre este ataque). Los otros dos son los laboratorios de Meltdown y Spectre (Capítulos 13 y 14 del libro de SEED). Estos últimos explotan una vulnerabilidad de Race Condition dentro del CPU. Estos cuatro laboratorios proveen una cobertura integral del problema de la vulnerabilidad de Race Condition en diferentes niveles: a nivel aplicación, a nivel kernel y finalmente a nivel hardware.


\paragraph{Entorno de Laboratorio.} \seedenvironmentC


% *******************************************
% SECTION
% ******************************************* 
\section{Configuración del Entorno de Laboratorio}

% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Desactivando las Contramedidas}

Ubuntu viene con mecanismos para proteger a los programas frente a los ataques de Race Condition. Uno de ellos funciona restringiendo el acceso a los links simbólicos dentro de  directorios con el bit sticky activado (por ejemplo {\tt /tmp}) permitiendo el acceso solamente al creador del link si el directorio no fue creado por quién es el dueño de este link simbólico.
Otro mecanismo de seguridad que fue implementado en Ubuntu 20.04, evita que el usuario root escriba archivos dentro del directorio \texttt{/tmp}, que no fueron creados por este usuario (es decir el usuario root).
Como primer paso necesitamos desactivar estas protecciones, ejecutando los siguientes comandos:

\begin{lstlisting}
// On Ubuntu 20.04, use the following:
$ sudo sysctl -w fs.protected_symlinks=0
$ sudo sysctl fs.protected_regular=0

// On Ubuntu 16.04, use the following:
$ sudo sysctl -w fs.protected_symlinks=0

// On Ubuntu 12.04, use the following:
$ sudo sysctl -w kernel.yama.protected_sticky_symlinks=0
\end{lstlisting}


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{El Programa Vulnerable}

El siguiente programa es en apariencia inofensivo. Pero contiene una vulnerabilidad de Race Condition.

\begin{lstlisting}[caption={The vulnerable program (\texttt{vulp.c})}]
#include <stdio.h>
#include<unistd.h>

int main()
{
   char* fn = "/tmp/XYZ";
   char buffer[60];
   FILE* fp;

   /* get user input */
   scanf("%50s", buffer );

   if(!access(fn, W_OK)){                 (*@\ding{192}@*)
      fp = fopen(fn, "a+");               (*@\ding{193}@*)
      fwrite("\n", sizeof(char), 1, fp);
      fwrite(buffer, sizeof(char), strlen(buffer), fp);
      fclose(fp);
   }
   else printf("No permission \n");
}
\end{lstlisting}

El programa de arriba tiene como dueño al usuario root y es un programa \setuid; Este programa agrega una cadena ingresada como input por parte del usuario al final del archivo temporal {\tt /tmp/XYZ}. Dado que este programa corre con privilegios de root (es decir su effective user ID es cero), puede sobreescribir cualquier archivo. Para evitar que  accidentalmente sobreescriba los archivos de otros usuarios, lo primero que hace este programa es chequear si el real user ID tiene permisos sobre el archivo {\tt /tmp/XYZ}; para este propósito se usa la función {\tt access()} en la línea \ding{192}. Si el real user ID es el correcto y puede acceder al archivo, el programa abre el archivo (Línea \ding{193}) y procede a escribir la cadena que ingresó el usuario como input.

A primera vista el programa parece no tener ningún tipo de problemas. Sin embargo contiene una vulnerabilidad de Race Condition: Debido a que existe una ventana de tiempo entre el chequeo realizado por la función ({\tt access}) y el uso de ({\tt fopen}), existe la posibilidad que el archivo usado en la función {\tt access()} difiera del usado por la función {\tt fopen()}, aunque ambos sean el mismo {\tt /tmp/XYZ}. Si un atacante malicioso dentro de esa ventana de tiempo de alguna forma logra modificar el link simbólico de {\tt /tmp/XYZ} a un archivo privilegiado como lo es \texttt{/etc/passwd}, podría alterar su contenido con el input ingresado en el programa, obteniendo así privilegios de root. Esto es posible debudo a que el programa vulnerable corre con los privilegios del usuario root.


\paragraph{Configurando nuestro programa \setuid}
Primero debemos compilar el código dado a continuación y activar el bit de \setuid en nuestro programa cuyo dueño será el usuario root.
Para lograr esto deben ejecutar los siguientes comandos:

\begin{lstlisting}
$ gcc vulp.c -o vulp
$ sudo chown root vulp
$ sudo chmod 4755 vulp
\end{lstlisting}



% *******************************************
% SECTION
% *******************************************
\section{Tarea 1: Eligiendo nuestro Target}

Para proceder a explotar la vulnerabilidad de Race Condition dentro del programa, vamos a elegir el archivo \texttt{/etc/passwd} como nuestro target, este archivo no puede ser escrito por usuarios no privilegiados. Explotando esta vulnerabilidad nuestro objetivo final será agregar un registro en este archivo, que será un usuario que tendrá privilegios dde root.
Dentro del archivo \texttt{/etc/passwd}, cada línea del mismo es una entrada y cadda entrada representa un usuario del sistema, cada usuario tiene tiene campos que están separados por el caracter de dos puntos (:). La entrada para el usuario root se muestra a continuación:

\begin{lstlisting}
root:x:0:0:root:/root:/bin/bash
\end{lstlisting}

En esta entrada, el tercer campo de este usuario (el campo de user ID) tiene un valor de cero. Esto significa que cada vez que este usuario se loguee en el sistema su id de proceso será siempre cero y es el valor de cero lo que le otorgará privilegios de root. Dicho de otro modo no es el nombre de usuario el que determina sus privilegios sino su user ID. Si quisieramos crear un usuario con privilegios de root, debemos de poner un cero en este campo.

Cada entrada de este archivo, contiene un campo de password, este es el segundo campo. En el ejemplo anterior este campo tiene el valor de \texttt{"x"} lo que indica que el password para este usuario esta siendo guardado en otro archivo llamado \texttt{/etc/shadow} (shadow file). Si somos fieles a este ejemplo entonces al aprovecharnos de la vulnerabilidad de Race Condition, deberíamos de modifiar dos archivos, el archivo password y el archivo shadow, lo cual no es difícil de hacer pero existe una forma más sencilla. En vez de poner el valor \texttt{"x"} en el campo de la entrada que corresponde al usuario, podemos poner un password de esta manera el sistema operativo no irá a buscarlo al archivo shadow.

El campo de password no contiene el password actual; este contiene el password hasheado a través de un algoritmo de hashing de una sóla vía (one-way hashing). Para obtener este valor, se puede agregar un usuario nuevo al sistema usando el comando  \texttt{adduser} y obtener su hash correspondiente desde el archivo shadow o podríamos simplemente copiar el valor de la entrada del usuario \texttt{seed} ya que sabemos que su password es  \texttt{dees}.
Hay algo interesante para mencionar, existe un valor mágico para las cuentas sin password que es usado por \ubuntu al ser booteado usando el modo live CD, este valor mágico es \texttt{U6aMy0wojraho} (no confundir el sexto caracter con la letra \texttt{O} ya que es un cero). Si se coloca este valor en el campo del password para un usuario cualquiera, estaríamos usando un usuario sin password, de forma tal que podríamos loguearnos con un enter al momento que el prompt del sistema nos pregunte por el password.

Para verificar si el password mágico funciona o no. Necesitamos agregar siguiente  entrada como usuario privilegiado al final del archivo \texttt{/etc/passwd}.
\paragraph{Tarea.} Para verificar si el password mágico funciona o no. Necesitamos agregar siguiente  entrada como usuario privilegiado al final del archivo \texttt{/etc/passwd}.
Por favor reporte si puede loguearse en el sistema usando el usuario  \texttt{test} sin tipear ningún password y si tiene privilegios de root.

\begin{lstlisting}
test:U6aMy0wojraho:0:0:test:/root:/bin/bash
\end{lstlisting}

Después de hacer esta tarea, elimine la entrada agregada anteriormente en el archivo \texttt{/etc/passwd}. En la próxima tarea, haremos que esta entrada sea agregada como un usuario normal y no como un usuario privilegiado. Claramente esto no será posible, pero lo lograremos explotando la vulnerabilidad de Race Condition de nuestro programa vulnerable que correrá con privilegios de root.


\paragraph{Advertencia.}
En el pasado, muchos estudiantes han vaciado accidentalmente el archivo {\tt /etc/passwd} durante el ataque (esto puede ocurrir porque se pueden race conditions a nivel kernel). Si Ud. pierde este archivo, no podrá loguearse en el sistema. Para evitar esta situación, recomendamos que se haga una copia del archivo original o se realize un snapshot de la Máquina Virtual, de esta manera habrá forma de recuperar el estado anterior del sistema ante cualquier problema que pueda surgir.



% *******************************************
% SECTION
% *******************************************
\section{Tarea 2: Lanzando el Ataque de Race Condition}

El objetivo de este ataque es explotar la vulnerabilidad de Race Condition de nuestro programa vulnerable con el bit de \setuid activado que ya hemos mencionado anteriormente. La meta final es obtener privilegios de root. La parte más crítica de este ataque es hacer que el archivo \texttt{/tmp/XYZ} apunte al archivo de password, dentro de la ventana tiempo que existe entre la invocación de las funciones \texttt{access} y \texttt{fopen}.

% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Tarea 2.A: Simular una Máquina Lenta} 

Let us pretend that the machine is very slow, and there is a 10-second time window between
the \texttt{access()} and \texttt{fopen()} calls. To simulate that, we 
add a \texttt{sleep(10)} between them. The program will look like the following:

\begin{lstlisting}
if (!access(fn, W_OK)) {
     sleep(10);
     fp = fopen(fn, "a+");
     ...
\end{lstlisting}
 
With this addition, the \texttt{vulp} program (when re-compiled)
will pause and yield control to the operating system for 10 seconds.
Your job is to manually do something, so when the program resumes
after 10 seconds, the program can help you
add a root account to the system. Please 
demonstrate how you would achieve this. 

You won't be able to modify the file name \texttt{/tmp/XYZ}, because 
it is hardcoded in the program, but you can use symbolic links to 
change the meaning of this name. For example, you can make 
\texttt{/tmp/XYZ} a symbolic link to the \texttt{/dev/null} file. 
When you write to \texttt{/tmp/XYZ}, the actual content will be written
to \texttt{/dev/null}. See the following example (the \texttt{"f"} option 
means that if the link exists, remove the old one first): 

\begin{lstlisting}
$ ln -sf /dev/null /tmp/XYZ
$ ls -ld /tmp/XYZ
lrwxrwxrwx 1 seed seed 9 Dec 25 22:20 /tmp/XYZ -> /dev/null
\end{lstlisting}
 
% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 2.B: El Ataque Real}

In the previous task, we have kind of ``cheated'' by asking the vulnerable program
to slow down, so we can launch the attack. This is definitely not a real attack.
In this task, we will launch the real attack. 
Before doing this task, make sure that the \texttt{sleep()} statement is removed 
from the \texttt{vulp} program. 


The typical strategy in race condition attacks is to run the attack
program in parallel to the target program, 
hoping to be able to do the critical step within that time window.
Unfortunately, perfect timing is very hard to achieve, so 
the success of attack is only probabilistic.
The probability of a successful attack might be quite low if the window
is small, but we can run the attack many many times. 
We just need to hit the race condition window once.  


\paragraph{Writing the attack program.} In the simulated attack,
we use the \texttt{"ln -s"} command to make/change symbolic links.
Now we need to do it in a program.
We can use {\tt symlink()} in C to create symbolic links.
Since \linux does not allow one to create a link if the link already exists,
we need to delete the old link first.
The following C code snippet shows how to remove a link and then make
{\tt /tmp/XYZ} point to {\tt /etc/passwd}. Please write your attack 
program.

\begin{lstlisting}
unlink("/tmp/XYZ");
symlink("/etc/passwd","/tmp/XYZ");
\end{lstlisting}



\paragraph{Running the vulnerable program and monitoring results.}
Since we need to run the vulnerable program for many
times, we will write a program to automate this process. 
To avoid manually typing an input to the vulnerable program \texttt{vulp}, 
we can use input redirection. Namely, we save our input in a file, and ask
\texttt{vulp} to get the input from this file using \texttt{"vulp <
inputFile"}. We can also use pipe (an example will be given later). 

It may take a while before our attack can successfully modify the
password file, so we need a way to automatically detect whether the attack is
successful or not. There are many ways to do that; an easy way 
is to monitor the timestamp of the file.
The following shell script runs the \texttt{"ls -l"} command, which
outputs several piece of information about a
file, including the last modified time. By comparing the outputs of the
command with the ones produced previously, we can tell
whether the file has been modified or not. 

The following shell script runs the vulnerable program (\texttt{vulp}) in a loop,
with the input given by the \texttt{echo} command (via a pipe).  
You need to decide what should be the actual input. 
If the attack is successful, i.e.,
the \texttt{passwd} is modified, the shell script will stop. 
You do need to be a little bit patient. 
Normally, you should be able to succeed within 5 minutes. 

\begin{lstlisting}
#!/bin/bash

CHECK_FILE="ls -l /etc/passwd"
old=$($CHECK_FILE)
new=$($CHECK_FILE)
while [ "$old" == "$new" ]    (*@\reflectbox{\ding{217}} \textbf{Check if /etc/passwd is modified}@*)
do
   echo "your input" | ./vulp (*@\reflectbox{\ding{217}} \textbf{Run the vulnerable program}@*)
   new=$($CHECK_FILE)
done
echo "STOP... The passwd file has been changed"
\end{lstlisting}

\paragraph{Verifying success}
When your script terminates,
test the success of your exploit by logging in as the test user and
verifying root privileges.  Then terminate the attack program by 
pressing \texttt{Ctrl-C} in the Terminal window in which you started the program.


\paragraph{Nota.}
If after 10 minutes, your attack is still not 
successful, you can stop the attack, and check the ownership
of the \texttt{/tmp/XYZ} file. If the owner of this file
becomes root, manually delete this file, and try your 
attack again, until your attack becomes successful. 
Please document this observation in your lab report. 
In Task 2.C, we will explain the reason and provide
an improved attack method. 



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 2.C: Mejorando el Método de Ataque}

In Task 2.B, if you have done everything correctly, but still could not succeed
in the attack, check the ownership of \texttt{/tmp/XYZ}. You will find out    
that \texttt{/tmp/XYZ}'s owner has become root (normally, it should be \texttt{seed}). 
If this happens, your attack will never succeed, because your attack
program, running with the \texttt{seed} privilege, can no longer remove or
\texttt{unlink()} it.  
This is because the \texttt{/tmp}
folder has a ``sticky'' bit on, meaning that only the owner of the file can
delete the file, even though the folder is world-writable. 


In Task 2.B, we let you use the root's privilege to delete \texttt{/tmp/XYZ}, 
and then try your attack again. The undesirable condition happens randomly,
so by repeating the attack (with the ``help'' from root), you will eventually
succeed in Task 2.B. Obviously, getting help from root is not a real attack. 
We would like to get rid of that, and do it without root's help.


The main reason for that undesirable situation is that 
our attack program has a problem, a race condition problem, the exact problem that
we are trying to exploit in the victim program. How ironic!  
In the past, when we saw that problem, we simply advised students to 
delete the file and try the attack again. Thanks to one of my students, 
who was determined to figure out what the problem was. Because of his effort,
we finally understand why and have an improved solution. 


The main reason for the situation to happen is that the attack program is 
context switched out right after it removes {\tt /tmp/XYZ} (i.e., \texttt{unlink()}),
but before it links the name to another file (i.e., \texttt{symlink()}. 
Remember, the action to remove the existing 
symbolic link and create a new one is not atomic (it involves two 
separate system calls), so if the context switch occurs in the middle
(i.e., right after the removal of {\tt /tmp/XYZ}),
and the target \setuid program gets a chance to run its 
{\tt fopen(fn, "a+")} statement, it will create a new file with root being the owner.
After that, your attack program can no longer make changes to {\tt /tmp/XYZ}.


Basically, using the \texttt{unlink()} and \texttt{symlink()} approach, 
we have a race condition in our attack program. Therefore, while we 
are trying to exploit the race condition in the target program,
the target program may accidentally ``exploit'' the race condition
in our attack program, defeating our attack.  


To solve this problem, we need to make 
\texttt{unlink()} and \texttt{symlink()} atomic. Fortunately, there 
is a system call that allows us to achieve that. More accurately,
it allows us to atomically swap two symbolic links. 
The following program first makes two symbolic links \texttt{/tmp/XYZ}
and \texttt{/tmp/ABC}, and then using the
\texttt{renameat2} system call to atomically switch them. 
This allows us to change what \texttt{/tmp/XYZ} points to
without introducing any race condition. 

\begin{lstlisting}
#define _GNU_SOURCE
  
#include <stdio.h>
#include <unistd.h>
int main()
{
   unsigned int flags = RENAME_EXCHANGE;

   unlink("/tmp/XYZ"); symlink("/dev/null",   "/tmp/XYZ");
   unlink("/tmp/ABC"); symlink("/etc/passwd", "/tmp/ABC");

   renameat2(0, "/tmp/XYZ", 0, "/tmp/ABC", flags);
   return 0;
}
\end{lstlisting}


\paragraph{Tasks.} Please revise your attack program using 
this new strategy, and try your attack again. If everything 
is done correctly, your attack should be able to succeed. 



% *******************************************
% SECTION
% *******************************************
\section{Tarea 3: Contramedidas}



% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Tarea 3.A: Aplicando el Principio del menor Privilegio}

The fundamental problem of the vulnerable program in this lab is 
the violation of the {\em Principle of Least Privilege}. 
The programmer does understand that the user who runs the program 
might be too powerful, so he/she introduced {\tt access()} to limit the user's 
power. However, this is not the proper approach. A better
approach is to apply the {\em Principle of Least Privilege}; 
namely, if users do not need certain privilege, the privilege
needs to be disabled.

We can use {\tt seteuid{}} system call to temporarily disable
the root privilege, and later enable it if necessary. Please use 
this approach to fix the vulnerability in the program, and then
repeat your attack. Will you be able to succeed? Please report your
observations and provide explanation.



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 3.B: Usando las protecciones nativas de \ubuntu}

Ubuntu 10.10 and later come with a built-in protection scheme against race condition
attacks. In this task, you need to turn the protection back on using the
following commands:

\begin{lstlisting}
// On Ubuntu 16.04 and 20.04, use the following command:
$ sudo sysctl -w fs.protected_symlinks=1

// On Ubuntu 12.04, use the following command:
$ sudo sysctl -w kernel.yama.protected_sticky_symlinks=1
\end{lstlisting}

Conduct your attack after the protection is turned on.  
Please describe your observations. Please also explain
the followings: (1) How does this protection scheme work?
(2) What are the limitations of this scheme?






% *******************************************
% SECTION
% *******************************************
\section{Informe del Laboratorio}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/submission}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\end{document}
