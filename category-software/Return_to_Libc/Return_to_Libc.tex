%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Copyright by Wenliang Du.                                       %%
%%  This work is licensed under the Creative Commons                %%
%%  Attribution-NonCommercial-ShareAlike 4.0 International License. %%
%%  To view a copy of this license, visit                           %%
%%  http://creativecommons.org/licenses/by-nc-sa/4.0/.              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\commonfolder}{../../common-files}

\input{\commonfolder/header}
\input{\commonfolder/copyright}


\lhead{\bfseries SEED Labs -- Laboratorio del Ataque Return-to-libc}

\newcommand{\retFigs}{./Figs}

\def \code#1 {\fbox{\scriptsize{\texttt{#1}}}}

\begin{document}

\begin{center}
{\LARGE Laboratorio del Ataque Return-to-libc }
\end{center}

\seedlabcopyright{2006 - 2020}


% *******************************************
% SECTION
% ******************************************* 
\section{Descripción General}

El objetivo de este laboratorio es que los estudiantes aprendan y ganen experiencia en un tipo de variante de ataque a los buffer overflow; este ataque puede bypassear un mecanismo de protección existente que es implementando en la mayoría de los sistemas operativos Linux. La forma tradicional de explotar una vulnerabilidad de buffer overflow es desbordar el buffer con un shellcode malicioso y hacer que el programa explotado haga un salto (jump) al shellcode dentro del stack. Para prevenir este tipo de ataques, algunos sistemas operativos hacen que su stack no sea ejecutable; lo que hará que falle la ejecución del shellcode dentro del mismo.

Desafortunadamente, esta protección no es infalible. Existe una variante para atacar esta vulnerabilidad dadas en los buffer overflows llamada  \textit{Return-to-libc}, que no necesita que el stack sea ejecutable; es más, no usa un shellcode. En su lugar hace que el programa salte (jump) a algún código que ya existe como puede ser la función \texttt{system()} de la librería \texttt{libc}, la cual es cargada en el espacio de memoria del proceso.

En este laboratorio, los estudiantes contarán con un programa con una vulnerabilidad de buffer overflow; su tarea será usar el ataque Return-to-libc para explotar la vulnerabilidad de este programa y finalmente obtener privilegios de root.
Además de esto, los estudiantes serán instruidos en otros tipos de mecanismos de protección implementados en Ubuntu para prevenir ataques de buffer overflow.
Este laboratorio cubre los siguientes tópicos:

\begin{itemize}[noitemsep]
\item Vulnerabilidad de Buffer overflow
\item El Stack Layout en la invocación a una función y el Non-executable stack 
\item Ataque de Return-to-libc y Return-Oriented Programming (ROP)
\end{itemize}


\paragraph{Lecturas y Videos.}
Para una cobertura más detallada en el ataque de return-to-libc puede consultar

\begin{itemize}
\item Capítulos 5 del libro de SEED, \seedbook
\item Sección 5 del curso de SEED en Udemy, \seedcsvideo
\end{itemize}


\paragraph{Entorno de Laboratorio.} \seedenvironmentC


\paragraph{Nota para instructores.}
Los instructores pueden personalizar este laboratorio eligiendo determinados valores para el tamaño del buffer que es usado en el programa vulnerable.
Para más detalles vea la Sección \ref{sec:vulnerable_program}.


% *******************************************
% SECTION
% ******************************************* 
\section{Configuración del Entorno de Laboratorio}


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Nota sobre las arquitecturas x86 y x64}

El ataque de return-to-libc es mucho más difícil de realizar usando la arquitectura x64 (64-bits) que usando la arquitectura x86 (32-bits).
Aunque la Máquina Virtual Ubuntu 20.04 de SEED es de 64-bits, se decidió usar programas de 32-bits (la arquitectura x64 es compatible con x86, por lo que programas de 32-bits pueden correr sin problemas en máquinas de 64-bits). En un futuro haremos una versión para 64-bits de este laboratorio.
Para asegurarnos de estar trabajando con un programa de 32-bits, al momento de compilar nuestro programa con \texttt{gcc} usaremos el parámetro \texttt{-m32} que generará un archivo binario de 32-bits.



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Desactivando las Contramedidas}

Antes de ejecutar las tareas de los laboratorios en la Máquina Virtual de Ubuntu, hay que tener en cuenta que las distribuciones de Linux implementan diferentes contramedidas para prevenir ataques de buffer overflow, en consecuencia esto dificulta el proceso de explotación de los mismos.
Para simplificar nuestros ataques, procederemos a desactivarlas.


\paragraph{Address Space Randomization.}
Tanto Ubuntu como otros sistemas basados en Linux, usan la randomización de los espacios de memoria (address space randomization), esto hace que las direcciones de memoria tanto en el heap como en el stack sean aleatorias, lo que ocasiona un problema a la hora de calcular las direcciónes de memoria para nuestro ataque ya que contar con estas de antemano es fundamental para que el ataque sea exitoso. 
A continuación se muestra el comando para desactivar esta contramedida:

\begin{lstlisting}
$ sudo sysctl -w kernel.randomize_va_space=0
\end{lstlisting}


\paragraph{El Mecanismo de Protección StackGuard.}
Con el objetivo de prevenir buffer overflows, el compilador \texttt{gcc} implementa un mecanismo de seguridad llamado \textit{StackGuard}. Cuando el StackGuard está activado los ataques de buffer overflow no funcionarán. Podemos desactivar esta protección durante el proceso de compilación de nuestro programa usando el parámetro \emph{-fno-stack-protector}.
A continuación se muestra el comando para desactivar esta protección para el archivo \texttt{example.c}:

\begin{lstlisting}
$ gcc -m32 -fno-stack-protector example.c
\end{lstlisting}


\paragraph{Non-Executable Stack.} Ubuntu solía permitir stacks ejecutables pero esto ha cambiado. La imagen de los programas binarios (y sus librerías compartidas) deben de indicar cuando requieren que el stack sea ejecutable o no, es decir, dentro del encabezado del programa se debe marcar un campo que indica si el stack será o no ejecutable. Este proceso es hecho de forma automática por {\tt gcc} (en sus versiones más recientes), por defecto los stacks son marcados como no ejecutables.
Para poder modificar esto, al momento de compilar un programa se debe hacer de la siguiente forma:

\begin{lstlisting}
For executable stack:
$ gcc -m32 -z execstack  -o test test.c

For non-executable stack:
$ gcc -m32 -z noexecstack  -o test test.c
\end{lstlisting}


Dado que el objetivo de este laboratorio es mostrar que la protección de non-executable stack no es infalible, debería de compilar su programa usando el parámetro {\tt "-z noexecstack"}.


\paragraph{Configurando \texttt{/bin/sh}.} En Ubuntu 20.04, la shell \texttt{/bin/sh} tiene un link simbólico que apunta a la shell \texttt{/bin/dash}.
La shell \texttt{dash} tiene una protección que evita ser ejecutada en un proceso 
\setuid. Si \texttt{dash} es ejecutada en un proceso \setuid, esta hace el cambio del effective user ID al real user ID del proceso que la está ejecutando, eliminando privilegios innecesarios.
Dado que nuestro programa vulnerable es un programa \setuid y nuestro ataque se vale de la función \texttt{system()} para correr el comando de nuestra elección. Esta función no correrá directamente nuestro comando sino que invocará a \texttt{/bin/sh} para realizar esta tarea, por ende será \texttt{/bin/dash} quién eliminirá los privilegios antes de la ejecución del comando a través de la protección built-in anteriormente mencionada, esto hará que nuestro ataque sea más difícil de lograr. Para desactivar esta protección, se debe de crear un link simbólico en la shell \texttt{/bin/sh} hacia otra shell que no tenga esta contramedida.
En nuestra Máquina Virtual Ubuntu 16.04, hemos instalado otra shell llamada \texttt{zsh} que se usará de reemplazo en lugar de \texttt{dash}:

\begin{lstlisting}
$ sudo ln -sf /bin/zsh /bin/sh
\end{lstlisting}

La protección implementada por \texttt{dash} puede ser evadida. Lo haremos en una tarea posterior.



% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{El Programa Vulnerable}
\label{sec:vulnerable_program}

\begin{lstlisting}[caption={The vulnerable program (\texttt{retlib.c})}]
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifndef BUF_SIZE
#define BUF_SIZE 12
#endif

int bof(char *str)
{
    char buffer[BUF_SIZE];
    unsigned int *framep;

    // Copy ebp into framep
    asm("movl %%ebp, %0" : "=r" (framep));      

    /* print out information for experiment purpose */
    printf("Address of buffer[] inside bof():  0x%.8x\n", (unsigned)buffer);
    printf("Frame Pointer value inside bof():  0x%.8x\n", (unsigned)framep);

    strcpy(buffer, str);   (*@\reflectbox{\ding{222}} \textbf{buffer overflow!} @*)

    return 1;
}

int main(int argc, char **argv)
{
   char input[1000];
   FILE *badfile;

   badfile = fopen("badfile", "r");
   int length = fread(input, sizeof(char), 1000, badfile);
   printf("Address of input[] inside main():  0x%x\n", (unsigned int) input);
   printf("Input size: %d\n", length);

   bof(input);

   printf("(^_^)(^_^) Returned Properly (^_^)(^_^)\n");
   return 1;
}

// This function will be used in the optional task
void foo(){
    static int i = 1;
    printf("Function foo() is invoked %d times\n", i++);
    return;
}
\end{lstlisting}

El programa anterior tiene una vulnerabilidad de buffer overflow. Este programa empieza leyendo un input de más de \texttt{1000} bytes de un archivo llamado \texttt{badfile}, este pasa los datos a la función \texttt{bof()} que los copia en su buffer interno a través de la función \texttt{strcpy()}.
Debido a que el buffer interno de la función \texttt{bof()} tiene un tamaño mucho más chico que \texttt{1000}, existe una potencial vulnerabilidad de buffer overflow.

Nuestro código será un programa \setuid cuyo dueño es el usuario root, de esta forma si un usuario normal quiere explotar esta vulnerabilidad de buffer overflow, podría obtener una shell con privilegios de root. 
Cabe notar que el programa obtiene los datos de entrada de un archivo llamado \texttt{badfile} el cual es provisto por los usuarios, de esta forma podemos construir un archivo de tal forma que cuando el programa vulnerable copie su contenido al buffer, se ejecute una root shell.


\vspace{0.1in}
\paragraph{Compilación.} 
Lo primero que haremos será compilar el programa, setearlo con el bit de \setuid y hacer al usuario root dueño del mismo.
No olvide incluir los parámetros \texttt{-fno-stack-protector} (para desactivar la protección de Stackguard) y  \texttt{"-z noexecstack"} (para activar la protección non-executable stack).
Hay que aclarar que el cambio de dueño del archivo debe de hacerse antes de activar el bit de \setuid, de otra forma se desactivará este bit.
Todos estos comandos son provistos en el archivo \texttt{Makefile}. 


\begin{lstlisting}
// Note: N should be replaced by the value set by the instructor
$ gcc -m32 -DBUF_SIZE=N -fno-stack-protector -z noexecstack -o retlib retlib.c
$ sudo chown root retlib           
$ sudo chmod 4755 retlib           
\end{lstlisting}


\paragraph{Para Instructores.}
Para evitar que los estudiantes utilicen las soluciones del pasado (o de aquellas
publicado en Internet), los instructores pueden cambiar el
valor para \texttt{BUF\_SIZE} haciendo que los estudiantes compilen el código usando un valor \texttt{BUF\_SIZE} diferente.
Si no se usa un valor determinado para \texttt{-DBUF\_SIZE} en la compilacióon 
su valor por defecto será \texttt{12} (definido en el programa).
Cuando este valor se modifica, el layout del stack  cambiará y la solución será diferente.
Los estudiantes deben de pedir a sus instructores
el valor de \texttt{N}. Se puede establecer el valor de \texttt{N}
en el archivo \texttt{Makefile} y se puede usar un valor para \texttt{N} entre 10 y 800.



% *******************************************
% SECTION
% ******************************************* 
\section{Tareas de Laboratorio}



% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Tarea 1: Encontrar la Direcciónes de las Funciones de \texttt{libc} } 

Cuando se ejecuta un programa en \linux, la librería \texttt{libc} es cargada en memoria. Cuando el address randomization está desactivado, para el programa en cuestión el espacio de direcciones en donde se carga la librería es siempre el mismo (para diferentes programas, el espacio de direcciones donde se carga \texttt{libc} puede variar).
Por lo tanto, podemos encontrar fácilmente la dirección de \texttt{system()} usando una herramienta de debugging como \texttt{gdb}. Es decir, podemos debuguear
el programa \texttt{retlib}. Aunque el programa sea \setuid y su dueño sea el usuario root, con la única exepción que los privilegio se eliminarán (es decir, el effective user ID será el mismo que el real user ID).
Dentro de \texttt{gdb}, necesitamos correr el programa una sóla vez de otra forma el código de la librería no será cargado, esto lo haremos usando el comando \texttt{run}.
Como se ve a continuación se uso el comando \texttt{p} (o \texttt{print}) para mostrar en pantalla la dirección en memoria de las funciones \texttt{system()} y de \texttt{exit()} (la cual la necesitaremos más adelante).


\begin{lstlisting}
$ touch badfile
$ gdb -q retlib     (*@\reflectbox{\ding{217}} Use "Quiet" mode@*)
Reading symbols from ./retlib...
(No debugging symbols found in ./retlib)
gdb-peda$ break main
Breakpoint 1 at 0x1327
gdb-peda$ run
......
Breakpoint 1, 0x56556327 in main ()
gdb-peda$ p system
$1 = {<text variable, no debug info>} (*@\textbf{0xf7e12420}@*) <system>
gdb-peda$ p exit
$2 = {<text variable, no debug info>} (*@\textbf{0xf7e04f80}@*) <exit>
gdb-peda$ quit
\end{lstlisting}

Debe de notar que aunque se trate del mismo programa, si decidimos desactivar el bit \setuid, puede ocurrir que la librería \texttt{libc} no sea cargada en el mismo espacio de direcciones.


\paragraph{Corriendo \texttt{gdb} en modo batch.} Si prefiere correr \texttt{gdb} en modo batch, puede poner los siguientes comandos \texttt{gdb} dentro de un archivo y ejecutar \texttt{gdb} en conjunción con estos comandos:


\begin{lstlisting}
$ cat gdb_command.txt
break main
run
p system
p exit
quit
$ gdb -q -batch -x gdb_command.txt ./retlib
...
Breakpoint 1, 0x56556327 in main ()
$1 = {<text variable, no debug info>} 0xf7e12420 <system>
$2 = {<text variable, no debug info>} 0xf7e04f80 <exit>
\end{lstlisting}
 



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 2: Insertando la cadena de la shell en la memoria}

Nuestra estrategia de ataque es hacer un salto (jump) a la función \texttt{system()} y ejecutar un comando arbitrario. Dado que queremos obtener una shell, nuestro objetivo es que la función \texttt{system()} ejecute el programa \texttt{"/bin/sh"}. Además se debe poner en memoria la cadena que representa el comando \texttt{"/bin/sh"} por lo que tendremos que conocer su dirección (esta dirección debe de ser pasado a la función \texttt{system()}). Existen varias formas de lograr esto, para esta tarea hemos elegido un método que usa variables de entorno.
Los estudiantes pueden probar con otros métodos si lo desean.  

Cuando ejecutamos un programa desde una shell, la shell crea un proceso hijo para ejecutar ese programa y todas las variables que son exportadas en la shell, son heredadas por ese proceso hijo que crea al ejecutar ese nuevo programa, es decir el proceso hijo hereda las variables de entornos exportadas por la shell padre.
Esto nos permite insertar cadenas en el espacio de direcciones del proceso hijo de manera sencilla.
Procederemos a definir una nueva variable shell llamada \texttt{MYSHELL}, dentro de ella pondremos la cadena \texttt{"/bin/sh"}. 
A continuación usando los siguientes comandos podremos verificar que la cadena esta presente en el proceso hijo y es mostrada en pantalla por el comando \texttt{env} que corre dentro del contexto del mismo.

\begin{lstlisting}
$ export MYSHELL=/bin/sh
$ env | grep MYSHELL
MYSHELL=/bin/sh
\end{lstlisting}

Usaremos la dirección de memoria de esta variable como argumento para la llamada a {\tt system()}. La dirección de esta variable puede ser encontrada usando el siguiente programa: 

\begin{lstlisting}
void main(){
   char* shell =  getenv("MYSHELL");
   if (shell) 
      printf("%x\n", (unsigned int)shell);
}
\end{lstlisting}

Compile el código anterior dentro de un binario llamado \texttt{prtenv}. 
Si el address randomization está desactivado, la dirección de memoria de la variable mostrada por \texttt{prtenv} deberá de coincidir por la que se muestra en el programa vulnerable \texttt{retlib}. Puede verificar ubicando el código mostrado anteriormente dentro de \texttt{retlib.c}. 
Sin embargo tenga en cuenta que la longitud del nombre de programa hace la diferencia, es por eso que elejimos 6 caracteres para \texttt{prtenv} como para 
\texttt{retlib}, ambos nombres deben de tener la misma longitud.



% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Tarea 3: Lanzando el Ataque}

Estamos listos para generar el contenido de nuestro archivo \texttt{badfile}.
Dado que nuestro contenido incluye datos en binario (por ejemplo: las direcciones de las funciones de \texttt{libc}), podemos usar Python para construir el contenido.
A continuación hemos provisto un código genérico con las partes esenciales que deben de ser completadas por ud.


\begin{lstlisting}
#!/usr/bin/env python3
import sys

# Fill content with non-zero values
content = bytearray(0xaa for i in range(300))

X = 0
sh_addr = 0x00000000       # The address of "/bin/sh"
content[X:X+4] = (sh_addr).to_bytes(4,byteorder='little')

Y = 0
system_addr = 0x00000000   # The address of system()
content[Y:Y+4] = (system_addr).to_bytes(4,byteorder='little')

Z = 0
exit_addr = 0x00000000     # The address of exit()
content[Z:Z+4] = (exit_addr).to_bytes(4,byteorder='little')

# Save content to a file
with open("badfile", "wb") as f:
  f.write(content)
\end{lstlisting}
 
Necesita encontrar tres direcciones de memoria y los valores para \texttt{X}, \texttt{Y}, y \texttt{Z}. 
Si los valores no son los correctos, el ataque fallará. En el informe de laboratorio deberá de explicar como es que obtuvo los valores para {\tt X}, {\tt Y} y {\tt Z}. Explique su razonamiento o si decide utilizar un enfoque de prueba y error, muestre sus pruebas.


\paragraph{Nota sobre \texttt{gdb}.} Si usa \texttt{gdb} para encontrar los valores para \texttt{X}, \texttt{Y}, y \texttt{Z}. Debe saber que el comportamiento de \texttt{gdb} en Ubuntu 20.04 es un tanto diferente al comportamiento que tiene en Ubuntu 16.04. Para ser más preciso, después de establecer el break point en la función \texttt{bof}, en el momento en que \texttt{gdb} se detiene dentro de \texttt{bof()}, este lo hace antes que el registro \texttt{ebp} apunte al stack frame actual, por lo que si se muestra el valor de \texttt{ebp} en este punto, obtendremos el valor \texttt{ebp} del caller y no el valor de \texttt{ebp} de \texttt{bof}. Para solucionar esto debemos de tipear \texttt{next} para que se ejecuten unas cuantas instrucciones más y se detenga una vez que el registro \texttt{ebp} apunte al stack frame de la función \texttt{bof()}.
La segunda edición del libro de SEED está basada en Ubuntu 16.04, por lo que no tiene este último paso de \texttt{next}.


\paragraph{Primera Variación del Ataque:}
Es necesaria la función \texttt{exit()}? Por favor repita el ataque sin incluir la dirección de esta función dentro del archivo \texttt{badfile}. Escriba las observaciones en el informe de laboratorio.


\paragraph{Segunda Variación del Ataque:} 
Después de que su ataque sea exitoso, cambie el nombre el archivo \texttt{retlib} y asegúrese que la longitud del nombre sea diferente a la actual. Por ejemplo puede cambiarlo a \texttt{newretlib}. Repita el ataque (sin cambiar el contenido del archivo {\tt badfile}). 
Tuvo un ataque exitoso o falló? Si falló explique el porque.

% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 4: Evadir la Contramedida de la Shell}

The purpose of this task is to launch the return-to-libc attack after 
the shell's countermeasure is enabled. 
Before doing Tasks 1 to 3, we relinked \texttt{/bin/sh} to \texttt{/bin/zsh},
instead of to \texttt{/bin/dash} (the original setting). This is because some shell programs, such 
as \texttt{dash} and \texttt{bash}, have a countermeasure that automatically 
drops privileges when they are executed in a \setuid process. In this task, we 
would like to defeat such a countermeasure, i.e., we would like to get a root shell even though
the \texttt{/bin/sh} still points to \texttt{/bin/dash}.   
Let us first change the symbolic link back:

\begin{lstlisting}
$ sudo ln -sf /bin/dash /bin/sh
\end{lstlisting}

Although \texttt{dash} and \texttt{bash} both drop the \setuid privilege,
they will not do that if they are invoked with the \texttt{-p} option. When
we return to the \texttt{system} function, this function invokes \texttt{/bin/sh}, 
but it does not use the \texttt{-p} option. Therefore, the \setuid
privilege of the target program will be dropped. If there is a function
that allows us to directly execute \texttt{"/bin/bash -p"}, without going
through the \texttt{system} function, we can still get the root privilege. 

There are actually many libc functions that can do that, such as 
the \texttt{exec()} family  of functions, including \texttt{execl()},
\texttt{execle()}, \texttt{execv()}, etc. Let's take a look at the
\texttt{execv()} function.

\begin{lstlisting}
int execv(const char *pathname, char *const argv[]);
\end{lstlisting}
 
This function takes two arguments, one is the address to the command, the 
second is the address to the argument array for the command. For example, if we 
want to invoke \texttt{"/bin/bash -p"} using \texttt{execv}, we need to 
set up the following:

\begin{lstlisting}
pathname = address of "/bin/bash" 
argv[0]  = address of "/bin/bash"
argv[1]  = address of "-p"
argv[2]  = NULL (i.e., 4 bytes of zero).
\end{lstlisting}
 
From the previous tasks, we can easily get the address of the two involved 
strings. Therefore, if we can construct the \texttt{argv[]} array on the stack, 
get its address, we will have everything that we need to conduct the 
return-to-libc attack. This time, we will return to the \texttt{execv()} function. 

There is one catch here. The value of \texttt{argv[2]} must be zero (an integer zero, 
four bytes). If we put four zeros in our input, \texttt{strcpy()} will terminate
at the first zero; whatever is after that will not be copied into 
the \texttt{bof()} function's buffer. This seems to be a problem, but keep
in mind, everything in your input is already on the stack; they are in
the \texttt{main()} function's buffer. It is not hard to get the 
address of this buffer. To simplify the task, we already let the 
vulnerable program print out that address for you. 

Just like in Task 3, you need to construct your input, so when the \texttt{bof()}
function returns, it returns to \texttt{execv()}, which fetches from the stack
the address of the \texttt{"/bin/bash"} string and the address of the \texttt{argv[]} 
array. You need to prepare everything on the stack, so when \texttt{execv()}
gets executed, it can execute \texttt{"/bin/bash -p"} and give you the root shell. 
In your report, please describe how you construct your input. 



% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Tarea 5 (Opcional): Programación Orientada al retorno (Return-Oriented Programming)}

There are many ways to solve the problem in Task 4. 
Another way is to invoke \texttt{setuid(0)} before 
invoking \texttt{system()}. The \texttt{setuid(0)} call sets both real user ID and  
effective user ID to 0, turning the process into a non-\setuid one (it still has 
the root privilege). This approach requires us to chain two functions
together. The approach was generalized to chaining multiple functions together, and 
was further generalized to chain multiple pieces of code together. 
This led to the Return-Oriented Programming (ROP). 

Using ROP to solve the problem in Task 4 is quite sophisticated, 
and it is beyond the scope of this lab. However, we do want to
give students a taste of ROP, asking them 
to work on a special case of ROP.
In the \texttt{retlib.c} program, there is a function called \texttt{foo()}, which 
is never called in the program. That function is intended for this task. Your job is 
to exploit the buffer-overflow problem in the program, so when the program
returns from the \texttt{bof()} function, it invokes \texttt{foo()} 10 times, before
giving you the root shell. In your lab report, you need to describe how your 
input is constructed.  Here is what the results will look like. 

\begin{lstlisting}
$ ./retlib
...
Function foo() is invoked 1 times
Function foo() is invoked 2 times
Function foo() is invoked 3 times
Function foo() is invoked 4 times
Function foo() is invoked 5 times
Function foo() is invoked 6 times
Function foo() is invoked 7 times
Function foo() is invoked 8 times
Function foo() is invoked 9 times
Function foo() is invoked 10 times
bash-5.0#   (*@\reflectbox{\ding{222}} Got root shell! @*)
\end{lstlisting}
 
\paragraph{Guidelines.} Let's review what we did in Task 3. We constructed the 
data on the stack, such that when the program returns 
from \texttt{bof()}, it jumps to the \texttt{system()} function, and 
when \texttt{system()} returns, the program jumps to the \texttt{exit()} function.  
We will use a similar strategy here. Instead of jumping to \texttt{system()} 
and \texttt{exit()}, we will construct the data on the stack, such that
when the program returns from \texttt{bof}, it returns  
to \texttt{foo}; when \texttt{foo} returns, it returns to another \texttt{foo}.
This is repeated for 10 times. When the 10th \texttt{foo} returns, it returns 
to the \texttt{execv()} function to give us the root shell.  



\paragraph{Further readings.} What we did in this task is just a special case of ROP.
You may have noticed that the \texttt{foo()} function does not take any
argument. If it does, invoking it 10 times will become signficantly more 
complicated. A generic ROP technique allows you to invoke any number of functions
in a sequence, allowing each function to have multiple arguments. 
The SEED book (2nd edition) provides detailed instructions on how to 
use the generic ROP technique to solve the problem in Task 4. It involves 
calling \texttt{sprintf()} four times, followed by an invocation of 
\texttt{setuid(0)}, before invoking \texttt{system("/bin/sh")} to give 
us the root shell. The method is quite complicated and takes 15 pages 
to explain in the SEED book.



% *******************************************
% SECTION
% ******************************************* 
\section{Guiás: Entiendo el mecanismo de la llamada a una función}


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Entendiendo el Stack Layout}

To know how to conduct Return-to-libc attacks, we need to 
understand how stacks work.  We use a small C program to understand 
the effects of a function invocation on the stack. More detailed 
explanation can be found in the SEED book and SEED lecture. 


\begin{lstlisting}
/* foobar.c */
#include<stdio.h>
void foo(int x)
{
  printf("Hello world: %d\n", x);
}

int main()
{
  foo(1);
  return 0;
}
\end{lstlisting}

We can use {\tt "gcc -m32 -S foobar.c"} to
compile this program to the assembly code.
The resulting file {\tt foobar.s} will look like the following:


\begin{lstlisting}
    ......
  8 foo:
  9         pushl   %ebp
 10         movl    %esp, %ebp
 11         subl    $8, %esp
 12         movl    8(%ebp), %eax   
 13         movl    %eax, 4(%esp)
 14         movl    $.LC0, (%esp)  : string "Hello world: %d\n"
 15         call    printf
 16         leave
 17         ret
    ......
 21 main:
 22         leal    4(%esp), %ecx
 23         andl    $-16, %esp
 24         pushl   -4(%ecx)
 25         pushl   %ebp
 26         movl    %esp, %ebp
 27         pushl   %ecx
 28         subl    $4, %esp
 29         movl    $1, (%esp)
 30         call    foo
 31         movl    $0, %eax
 32         addl    $4, %esp
 33         popl    %ecx
 34         popl    %ebp
 35         leal    -4(%ecx), %esp
 36         ret
\end{lstlisting}
 


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Calling and entering {\tt foo()}}

Let us concentrate on the stack while calling {\tt foo()}. We can ignore the stack
before that. Please note that line numbers instead of instruction addresses are
used in this explanation. 



\begin{figure}[htb]
	\centering
	\includegraphics[width=0.95\textwidth]{\retFigs/enter_leave_foo.pdf}
	\caption{Entering and Leaving {\tt foo()}}
	\label{fig:enter_leave_foo}
\end{figure}


\begin{itemize}
\item \textbf{Line 28-29:}:
These two statements push the value $1$, i.e. the argument to the {\tt foo()}, 
into the stack. This operation increments {\tt \%esp} by four. The stack
after these two statements is depicted in Figure~\ref{fig:enter_leave_foo}(a).

\item \textbf{Line 30: \texttt{call foo}}: 
The statement pushes the address of the next instruction that 
immediately follows the {\tt call} statement into the 
stack (i.e the return address), and then jumps to the 
code of {\tt foo()}. 
The current stack is depicted in Figure~\ref{fig:enter_leave_foo}(b).

\item \textbf{Line 9-10}:
The first line of the function {\tt foo()} pushes {\tt \%ebp} into
the stack, to save the previous frame pointer. The second
line lets {\tt \%ebp} point to the current frame. The current stack 
is depicted in Figure~\ref{fig:enter_leave_foo}(c). 

\item \textbf{Line 11: \texttt{subl \$8, \%esp}}:
The stack pointer is modified to allocate space (8 bytes) for 
local variables and the two arguments passed to {\tt printf}. 
Since there is no local variable in function {\tt foo}, the
8 bytes are for arguments only. 
See Figure~\ref{fig:enter_leave_foo}(d). 

\end{itemize}


\subsection{Leaving {\tt foo()}}

Now the control has passed to the function {\tt foo()}. Let us see what happens
to the stack when the function returns.

\begin{itemize}
\item \textbf{Line 16: \texttt{leave}}: This
instruction implicitly performs two instructions (it was a macro
in earlier x86 releases, but was made into an instruction later):
\begin{verbatim}
    mov  %ebp, %esp
    pop  %ebp
\end{verbatim}
The first statement releases the stack space allocated for the function; 
the second statement recovers the previous frame pointer. 
The current stack is depicted in Figure~\ref{fig:enter_leave_foo}(e). 

\item \textbf{Line 17: \texttt{ret}}: This instruction simply pops the return 
address out of the stack, and then jump to the return address.
The current stack is depicted in Figure~\ref{fig:enter_leave_foo}(f).

\item \textbf{Line 32: \texttt{addl \$4, \%esp}}: Further restore the stack by
releasing more memories allocated for {\tt foo}. 
As you can see that the stack is now in exactly the same state as it was
before entering the function {\tt foo} (i.e., before line 28). 
\end{itemize}



% *******************************************
% SECTION
% *******************************************
\section{Informe de Laboratorio}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/submission}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% *******************************************
% SECTION
% *******************************************
\section*{Agradecimientos}

\input{\commonfolder/acknowledgments}


\end{document}

