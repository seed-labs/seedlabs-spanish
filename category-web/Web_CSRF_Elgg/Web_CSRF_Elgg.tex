%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Copyright by Wenliang Du.                                       %%
%%  This work is licensed under the Creative Commons                %%
%%  Attribution-NonCommercial-ShareAlike 4.0 International License. %%
%%  To view a copy of this license, visit                           %%
%%  http://creativecommons.org/licenses/by-nc-sa/4.0/.              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\commonfolder}{../../common-files}
\newcommand{\webcommon}{../Web_Common}

\input{\commonfolder/header}
\input{\commonfolder/copyright}


\lhead{\bfseries SEED Labs -- Laboratorio de CSRF}

\begin{document}

\begin{center}
{\LARGE Laboratorio de Cross-Site Request Forgery (CSRF)}
\vspace{0.1in}\\
{\Large (Web Application: {\tt Elgg})}
\end{center}

\seedlabcopyright{2006 - 2020}



% *******************************************
% SECTION
% ******************************************* 
\section{Descripción General}


El objetivo de este laboratorio, es ayudar a que los estudiantes entiendan el ataque de Cross-Site Request Forgery (CSRF). Un ataque de CSRF involucra un usuario víctima, un sitio de confianza y un sitio malicioso. La víctima tene una sesión válida en un sitio de confiana mientras que por otro lado visita un sitio malicioso que inyecta un request HTTP malicioso para ese sitio de confianza dentro de la sesión de la víctima.

En este laboratorio, los estudiantes usarán una aplicación web de red social para realizar ataques CSRF. La aplicación web se llama \texttt{Elgg} y ha sido instalada en nuestra Máquina Virtual. 
\texttt{Elgg} contiene contramedidas para prevenir ataques CSRF, pero las hemos desactivado para poder realizar los ataques.
Este laboratorio cubre los siguientes tópicos:


\begin{itemize}[noitemsep]
 \item Ataque de Cross-Site Request Forgery 
 \item Contramedidas para CSRF: Secret token y Same-site cookie
 \item Requests HTTP GET y POST
 \item JavaScript and Ajax
\end{itemize}


\paragraph{Lecturas.}
Para una cobertura más detallada en ataques CSRF puede consultar:

\begin{itemize}
\item Capítulo 10 del libro de SEED, \seedbook
\end{itemize}


\paragraph{Entorno de Laboratorio.} 
\seedenvironmentB 
\nodependency



% *******************************************
% SECTION
% *******************************************
\section{Configuración del Entorno de Laboratorio}

En este laboratorio, usaremos tres sitios web.
El primero será nuestro aplicativo web vulnerable Elgg y cuya URL es \url{www.seed-server.com}. El segundo será el sitio malicioso que va a ser usado para el ataque y cuya URL es \url{www.attacker32.com}. El tercero será el sitio usado para las tareas de defensa y su hostname es \url{www.example32.com}.
Usaremos contenedores para configurar el entorno de laboratorio.

% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Setup del Contenedor y sus Comandos}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/container/setup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{La Aplicación Web Elgg}

En este laboratorio usaremos una aplicación web de red social llamada Elgg.
Esta aplicación está instalada y configurada en las imágenes de nuestros contenedores. 
Usaremos dos contenedores, el primero será el encargado de correr el servidor web  (\texttt{10.9.0.5}) y el segundo será el encargado de correr el servidor de base de datos MySQL (\texttt{10.9.0.6}). 
Las direcciones IPs para ambos contenedores están hardcodeadas en múltiples lugares de los archivos de configuración del proyecto, por lo tanto se recomienda no cambiarlos en el archivo \texttt{docker-compose.yml}

\vspace{0.1in}
\paragraph{El Contenedor de Elgg.}
La aplicación web Elgg está hosteada usando un servidor web Apache.
La configuración del servidor está dentro del archivo \texttt{apache\_elgg.conf} dentro del directorio de la imagen Elgg.
Este archivo especifica la URL del sitio web y el directorio donde reside el código fuente de la aplicación web.

\begin{lstlisting}
<VirtualHost *:80>
     DocumentRoot /var/www/elgg
     ServerName   www.seed-server.com
     <Directory /var/www/elgg>
          Options FollowSymlinks
          AllowOverride All
          Require all granted
     </Directory>
</VirtualHost>
\end{lstlisting}

\paragraph{El Contenedor de Ataque.}
Usaremos otro contenedor para la máquina que será la atacante (\texttt{10.9.0.105}) y hosteará un sitio malicioso.
La configuración apache para este sitio web se muestra a continuación:

\begin{lstlisting}
<VirtualHost *:80>
     DocumentRoot /var/www/attacker
     ServerName   www.attacker32.com
</VirtualHost>
\end{lstlisting}
 
Debido a que necesitamos crear páginas web dentro de este contenedor, hemos montado un directorio en la Máquina Virtual Host (\texttt{Labsetup/attacker}) dentro del directorio del contenedor ubicado en \texttt{/var/www/attacker} que es el directorio usado por nuestro archivo configuración de Apache. A su vez las páginas web ubicadas dentro del directorio \texttt{attacker} en la Máquina Virtual, serán hosteadas en el sitio web del atacante. Hemos puesto un código genérico dentro de este directorio.

\paragraph{Configuración DNS.}
Accederemos a nuestro sitio Elgg, nuestro sitio malicioso y el sitio de defensa usando sus URLs.
Lo primero que hay que hacer es mapear los nombres de dominio del servidor web con sus IPs. Para ello deberá agregar las siguientes entradas en el archivo \texttt{/etc/hosts}.
Para poder modificar este archivo ud. debe contar con privilegios de root (usando \texttt{sudo}):

\begin{lstlisting}
10.9.0.5        www.seed-server.com
10.9.0.5        www.example32.com
10.9.0.105      www.attacker32.com
\end{lstlisting}


\vspace{-0.1in}
% MySQL database
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\webcommon/mysql}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\vspace{-0.1in}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\webcommon/elgg_accounts}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% *******************************************
% SECTION
% ******************************************* 
\section{Tareas del Laboratorio: Ataques}


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 1: Inspeccionando Request HTTP.}

Para realizar ataques CSRF, necesitamos capturar Requests HTTP.
En este laboratorio necesitaremos crear Requests HTTP. 
Para observar como luce un Request HTTP válido en Elgg, debemos ser capaces de capturar y analizar dichos requests.
Para este propósito usaremos un add-on para Firefox llamado \texttt{"HTTP Header Live"}. Antes de empezar el laboratorio, el estudiante debería estar familiarizado con esta herramienta.
Las instrucciones de como utilizarla están descriptas en esta sección (\S~\ref{web:sec:httpheaderlive}). En su informe de laboratorio, por favor identifique los parámetros usados en esos requests, si es que existen.


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 2: Usando Request HTTP GET para el ataque CSRF}

Para esta tarea, necesitamos usar dos usuarios en nuestra aplicación de red social Elgg: Alice y Samy. Samy quiere ser amigo de Alice, pero Alice rechaza su petición de amistad. Samy decide usar un ataque cd CSRF para ser amigo de Alice. Esto lo logra enviando una URL a Alice (por email o por un posteo en Elgg); Alice visita la URL que apunta al sitio de Samy: \texttt{www.attacker32.com}.
Haga de cuenta que ud. ess Samy, describa como puede hacer una página de tal forma que cuando Alice la visite sea agregada a la lista de amigos de Samy (asumiendo que Alice tiene una sesión activa en Elgg).


Para lograr esto, neceistamos identificar como luce el Request HTTP original de Add-Friend para agregar un amigo. Podemos usar \texttt{"HTTP Header Live"} para llevar a cabo la investigación.
En esta tarea, no está permitido escribir código JavaScript para hacer el ataque CSRF. Su objetivo es lanzar un ataque exitoso tan pronto Alice visite la página web, sin que Alice haga un sólo click en la página (pista: puede usar el tag {\tt img}, que automáticamente lanza un Request HTTP GET).

Elgg implementa contramedidas para defenderse contra ataques CSTF. En el Request HTTP Add-Friend, puede advertir que cada request incluye dos parámetros extraños llamados \texttt{\_\_elgg\_ts} y  \texttt{\_\_elgg\_token}. Estos parámetros son usados como contramedida, si ambos no contienen valores válidos, el request no será validado por Elgg.
Para este laboratorio, hemos desactivado esta protección y no hay necesidad de incluirlos en los requests que se van a falsificar.


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 3: Usando Request HTTP POST para el ataque CSRF}

Después de agregar a Alice como amiga, Samy quiere hacer algo más. Samy quiere que Alice que ponga ``Samy is my Hero'' en su perfil de esta forma todo el mundo podrá verlo. Para lograr esto Samy planea usar un ataque CSRF.

Una forma de hacerlo es postear un mensaje en la cuenta Elgg de Alice, con la esperanza que Alice visite este sitio que será el sitio malicioso de Samy es decir \url{www.attacker32.com} donde se va a lanzar el ataque CSRF.

El objetivo de su ataque es modificar el perfil de la víctima. En particular el atacante necesita falsificar un request para así modificar la información del perfil de la víctima en Elgg. Elgg permite que lo usuarios modifiquen sus perfiles. Si loos usuarios quieren hacerlo, ellos visitan su página de perfil en Elgg, completan un formulario y lo envían a través de un Request POST por medio del server-side script {\tt /profile/edit.php} que se encarga de hacer el cambio y procesar la información.

El server-side script {\tt edit.php} acepta tanto requests HTTP GET como POST, puede usar el mismo truco de la Tarea 1 para hacer este ataque.
Sin embargo, en esta tarea ud. debe usar un request POST.
Así mismo, ud. como atacante debe falsificar un request HTTP POST desde el navegador de la víctima cuando esta visite el sitio malicioso.
Los atacantes necesitan conocer la estructura de dicho request. Puede conocer esta estructura, es decir sus parámetros, haciendo cambios en su perfil y monitoreando el request resultando usando \texttt{"HTTP Header Live"}.
Lo que se observe puede ser algo similar a lo que se muestra a continuación, a diferencia de los requests HTTP {\tt GET} que ubican sus parámetros en la URL, em los requests HTTP {\tt POST} los parámetros son incluídos en el cuerpo del mensaje (vea el contenido mostrado a continuación ubicado entre los símbolos \ding{80})

\begin{lstlisting}
http://www.seed-server.com/action/profile/edit

POST /action/profile/edit HTTP/1.1
Host: www.seed-server.com
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:23.0) ...
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: http://www.seed-server.com/profile/elgguser1/edit
Cookie: Elgg=p0dci8baqrl4i2ipv2mio3po05
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 642
__elgg_token=fc98784a9fbd02b68682bbb0e75b428b&__elgg_ts=1403464813  (*@\ding{80}@*) 
&name=elgguser1&description=%3Cp%3Iamelgguser1%3C%2Fp%3E
&accesslevel%5Bdescription%5D=2&briefdescription= Iamelgguser1
&accesslevel%5Bbriefdescription%5D=2&location=US
......                                                              (*@\ding{80}@*)
\end{lstlisting}

Después de entender la estructura del request, necesita generar un request desde su página web de ataque usando código JavaScript.
Para simplificar esta tarea, hemos provisto un código genérico a cual partir del cual se puede generar el ataque CSRF que se quiere lanzar desde el sitio web malicioso. Este es un código de ejemplo y necesita modificarlo para que funcione en su ataque.


\begin{lstlisting}
<html>
<body>
<h1>This page forges an HTTP POST request.</h1>
<script type="text/javascript">

function forge_post()
{
    var fields;

    // The following are form entries need to be filled out by attackers. 
    // The entries are made hidden, so the victim won't be able to see them.
    fields += "<input type='hidden' name='name' value='****'>";
    fields += "<input type='hidden' name='briefdescription' value='****'>";
    fields += "<input type='hidden' name='accesslevel[briefdescription]' 
                                    value='2'>";                         (*@\ding{192}@*)
    fields += "<input type='hidden' name='guid' value='****'>";

    // Create a <form> element.
    var p = document.createElement("form");
	 
    // Construct the form
    p.action = "http://www.example.com";
    p.innerHTML = fields;
    p.method = "post";
	 
    // Append the form to the current page.
    document.body.appendChild(p);
	 
    // Submit the form
    p.submit();
}

	
// Invoke forge_post() after the page is loaded.
window.onload = function() { forge_post();}
</script>
</body>
</html>
\end{lstlisting}

En la línea  Line~\ding{192}, el valor \texttt{2} establece el nivel de acceso público de un campo en particular.
Esto es necesario de otra forma, el nivel de acceso será puesto como privado por defecto lo que hara que otros usuarios no puedan verlo. 
Cabe aclarar que al hacer copy and paste del código en el archivo PDF, muy a menudo, las comillas dobles y en especial las comillas simples, pueden convertirse en símbolos diferentes que parecen similares. Esta situación causará errores en el código, así que tenga en cuenta este escenario. Cuando esto suceda, elimínelos y escriba manualmente esos símbolos.

\paragraph{Preguntas.}
Además de describir su ataque de forma detallada, deberá de responder las siguientes preguntas en su informe de laboratorio:

\begin{itemize}
   \item \textbf{Pregunta 1}: El request falsificado necesita el user id de Alice (guid) para funcionar de manera correcta. Si Boby elije a Alice como víctima antes de hacer el ataque, puede encontrar diversas formas para obtener este id. Boby no conoce el password de Alice en Elgg, por lo tanto no puede loguearse como ella para obtener esta informacióon. Por favor explique como Boby puede resolver este problema.

   \item \textbf{Pregunta 2:} Si Boby quisiera ejecutar el ataque sobre cualquier persona que visite su página maliciosa, estariamos en un escenario donde Boby no sabe quién está visitando su página de antemano. Dada esta situación ¿Puede lanzar el ataque CSRF y modificar el perfil de la víctima visitante? Por favor describa esta situación.
\end{itemize}


% *******************************************
% SECTION
% *******************************************
\section{Tareas de Laboratorio: Defensa} 

No es difícil defenderse contra ataques CSSRF. Inicialmente, la mayoría de las aplicaciones usan un token secreto (secret token) en su páginas y por medio del chequeo de la presencia de este token en un request, pueden verificar si se trata de un request same-site o un request cross-site. Esto es llamado protección de  \textit{secret token}.
Recientemente la mayoría de los navegadores han implementado un mecanismo llamado\textit{SameSite cookie}, cuya intención es simplificar la implementación de medidas de defensa en contra de ataques CSRF.
Haremos unos experimentos usando ambos métodos. 


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 4: Activando las Contramedidas en Elgg} 

To defend against CSRF attacks, web applications can embed a secret token
in their pages. All the requests coming from these pages must carry this 
token, or they will be considered as a cross-site request, and will
not have the same privilege as the same-site requests. 
Attacker will not be able to get this secret token, so their requests
are easily identified as cross-site requests. 


Elgg uses this secret-token approach as its 
built-in countermeasures to defend against CSRF attacks. 
We have disabled the countermeasures to make the attack work. 
Elgg embeds two parameters
{\tt\_\_elgg\_ts} and {\tt\_\_elgg\_token} in the request.
The two parameters are added to the HTTP message body for the POST requests and to the URL
string for the HTTP GET requests. The server will validate them
before processing a request. 


\paragraph{Embedding secret token and timestamp to web pages.}
Elgg adds security token and timestamp to all the HTTP requests. 
The following HTML code is present in all the forms where user action is required. 
These are two hidden fields; when the form is submitted, these
two hidden parameters are added to the request:

\begin{lstlisting}
<input type = "hidden" name = "__elgg_ts" value = "" />
<input type = "hidden" name = "__elgg_token" value = "" />
\end{lstlisting}

Elgg also assign the values of the security token and timestamp to JavaScript variables, 
so they can be easily accessed by the JavaScript code on the same page.

\begin{lstlisting}
elgg.security.token.__elgg_ts;
elgg.security.token.__elgg_token;
\end{lstlisting}


The secret token and timestamp are added to Elgg's web pages by the 
\path{vendor/elgg/elgg/views/default/input/securitytoken.php} 
module. The code snippet below shows how they are dynamically 
added to web pages.

\begin{lstlisting}
$ts = time();
$token = elgg()->csrf->generateActionToken($ts);

echo elgg_view('input/hidden', ['name' => '__elgg_token', 'value' => $token]);
echo elgg_view('input/hidden', ['name' => '__elgg_ts', 'value' => $ts]);
\end{lstlisting}


\paragraph{Secret token generation.}
Elgg's security token is a hash value (md5 message digest) of the site 
secret value (retrieved from database),
timestamp, user session ID and random generated session string. 
The code below shows the secret token generation in Elgg 
(in \path{vendor/elgg/elgg/engine/classes/Elgg/Security/Csrf.php}).


\begin{lstlisting}
/**
 * Generate a token from a session token (specifying the user), 
 * the timestamp, and the site key.
 */
public function generateActionToken($timestamp, $session_token = '') {
  if (!$session_token) {
          $session_token = $this->session->get('__elgg_session');
          if (!$session_token) {
                  return false;
          }
  }

  return $this->hmac
          ->getHmac([(int) $timestamp, $session_token], 'md5')
          ->getToken();
}
\end{lstlisting}


\paragraph{Secret token validation.}
The elgg web application validates the generated token and timestamp to
defend against the CSRF attack.  Every user action calls the 
\texttt{validate} function inside \texttt{Csrf.php}, and this function validates the tokens.
If tokens are not present or invalid, the action will be denied and the
user will be redirected. In our setup, we added 
a \texttt{return} at the beginning of this function, essentially
disabling the validation.

\begin{lstlisting}
public function validate(Request $request) {
   (*@\textbf{return;}@*) // Added for SEED Labs (disabling the CSRF countermeasure)

   $token = $request->getParam('__elgg_token');
   $ts = $request->getParam('__elgg_ts');
   ... (code omitted) ...
}
\end{lstlisting}



\paragraph{Task: Turn on the countermeasure.}
To turn on the countermeasure, get into the Elgg container, 
go to the \path{/var/www/elgg/vendor/elgg/elgg/engine/classes/Elgg/Security} 
folder, remove the \texttt{return} statement from \texttt{Csrf.php}.
A simple editor called \texttt{nano} is available from inside the 
container.  After making the change, 
repeat the attack again, and see whether your attack will
be successful or not. 
Please point out the secret tokens in the captured HTTP requests.
Please explain why
the attacker cannot send these secret tokens in the CSRF attack; what
prevents them from finding out the secret tokens from the web page?   

\textbf{It should be noted (important)} that when we launch the edit-profile attack
while the countermeasure is enabled, the failed attempt will
cause the attacker's page to be reloaded, which will
trigger the forged POST request again. This will lead to another 
failed attempt, so the page will be reloaded again and 
another forged POST request will be sent out. This endless loop
will slow down your computer. Therefore, after verifying that 
the attack failed, kill the tab to stop the endless loop. 



% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Tarea 5: Experimentando con la Contramedida SameSite Cookie} 

Most browsers have now implemented a mechanism called SameSite cookie, 
which is a property associated with cookies. When sending out 
requests, browsers will check this property, and decide whether 
to attach the cookie in a cross-site request. A web application can
set a cookie as SameSite if it does not want the cookie to be 
attached to cross-site requests. For example, they can mark
the session ID cookie as SameSite, so no cross-site request
can use the session ID, and will therefore not be able to 
launch CSRF attacks. 


To help students get an idea on how the SameSite cookies can
help defend against CSTF attacks, we have created a website
called \url{www.example32.com} on one of the containers. Please 
visit the following URL (the hostname is already mapped 
to \texttt{10.9.0.5} in the \texttt{/etc/hosts} file; if you are 
not using the SEED VM, you should add this mapping to your machine): 

\begin{lstlisting}
URL: http://www.example32.com/
\end{lstlisting}

Once you have visited this website once, three cookies will be 
set on your browser, \texttt{cookie-normal}, \texttt{cookie-lax},
and \texttt{cookie-strict}. As indicated by the name,
the first cookie is just a normal one, the second and third cookies
are samesite cookies of two different types (\texttt{Lax} and \texttt{Strict}
types). We have designed two sets of experiments to see 
which cookies will be attached when you send an HTTP request
back to the server. Typically, all the cookies belonging to the server
will be attached, but this is not the case if a cookie is a samesite type. 


Please follow the links for the two experiments. Link A points to a page 
on \url{example32.com}, while Link B points to a page 
on \url{attacker32.com}. Both pages are identical (except for the background
color), and they both send three different types of requests to
\url{www.example32.com/showcookies.php}, which
simply displays the cookies sent by the browser. By looking 
at the display results, you can tell which cookies were sent 
by the browser. Please do the following: 


\begin{itemize}
\item Please describe what you see and explain why some cookies are 
not sent in certain scenarios. 
 
\item Based on your understanding, please describe how the SameSite
cookies can help a server detect whether a request 
is a cross-site or same-site request. 

\item Please describe how you would use
the SameSite cookie mechanism to help Elgg defend against CSRF attacks. 
You only need to describe general ideas, and there is no need to 
implement them. 
\end{itemize}


\paragraph{Bonus points.} Although it is not required, students
are encouraged to modify the Elgg application, so they
can use the samesite cookie mechanism to defend against
CSRF attacks. We recommend instructors to give bonus points 
to the students who can do this. Students should check with 
their instructors regarding the bonus points.


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\section{Guías}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\webcommon/Web_Dev_Tools}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% *******************************************
% SECTION
% ******************************************* 
\section{Informe de Laboratorio}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/submission}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% *******************************************
% SECTION
% *******************************************
\section*{Agradecimientos}

\input{\commonfolder/acknowledgments}


\end{document}



