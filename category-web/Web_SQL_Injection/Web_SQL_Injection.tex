%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Copyright by Wenliang Du.                                       %%
%%  This work is licensed under the Creative Commons                %%
%%  Attribution-NonCommercial-ShareAlike 4.0 International License. %%
%%  To view a copy of this license, visit                           %%
%%  http://creativecommons.org/licenses/by-nc-sa/4.0/.              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\commonfolder}{../../common-files}
\newcommand{\webcommon}{../Web_Common}

\input{\commonfolder/header}
\input{\commonfolder/copyright}



\lhead{\bfseries SEED Labs -- Laboratorio de Inyección SQL}

\newcommand{\sqlFigs}{./Figs}


\begin{document}


\begin{center}
{\LARGE Laboratorio de Inyección SQL }
\end{center}

\seedlabcopyright{2006 - 2020}


% *******************************************
% SECTION
% ******************************************* 
\section{Descripción General}

Una Inyección SQL es una técnica de inyección de código que explota vulnerabilidades entre la interfaz de un aplicación web y su servidor de base de datos. Esta vulnerabilidad se presenta cuando el input de un usuario que viaja de la aplicación web hacia el servidor back-end que conecta con la base de datos, no es validado de forma correcta.

Muchas aplicaciones web toman el input de los usuarios para construir consultas SQL para obtener información de la base de datos. A su vez las aplicaciones web usan consultas SQL para guardar información en la base de datos. Todas estas son prácticas comunes en el desarrollo de las aplicaciones web. Cuando una consulta SQL no es construida con cuidado, se pueden dar vulnerabilidades de Inyección SQL.
Las Inyecciones SQL son uno de los ataques más comunes en aplicaciones web.

En este laboratorio, hemos creado una aplicación web vulnerable a un ataque de Inyección SQL. Esta aplicación incluye los errores más comunes que cometen los desarrolles web a la hora de construir aplicaciones.
El objetivo de los estudiantess será encontrar formas para explotar estas vulnerabilidades usando Inyecciones SQL, demostrar el daño que puede causar este tipo de atauqe y especializarse en las técnicas que pueden ayudar a mitigar, prevenir y evitar este tipo de ataques.
Este laboratorio cubre los siguientes tópicos:

\begin{itemize}[noitemsep]
\item Declaraciones SQL: \texttt{SELECT} y \texttt{UPDATE}
\item Inyección SQL
\item Declaraciones Preparadas
\end{itemize}



\paragraph{Lecturas.}
Para una cobertura más detallada en Inyección SQL puede consultar:

\begin{itemize}
\item Capítulo 12 del libro de SEED, \seedbook
\end{itemize}

\paragraph{Entorno de Laboratorio.} 
\seedenvironmentB 
\nodependency


% *******************************************
% SECTION
% ******************************************* 
\section{Configuración del Entorno de Laboratorio}

Para este laboratorio hemos desarrollado una aplicación web y usaremos contenedores para configurarla. Usaremos dos contenedores, uno para la aplicación web y el otro para el servidor de base de datos para la aplicación.
La dirección IP del contenedor para la aplicación web es \texttt{10.9.0.5} y su la URL de la misma será la siguiente:

\begin{lstlisting}
http://www.seed-server.com
\end{lstlisting}

Necesitamos mapear el hostname con la dirección IP del contenedor. Por favor agregue la siguiente entrada en el archivo  \texttt{/etc/hosts}. Necesita privilegios de root para poder editar este archivo (debe usar \texttt{sudo}).
Puede ser que ya tenga agregada esta entrada de laboratorios anteriores. Si esta entrada tiene una dirección IP diferente, la entrada errónea debe de ser borrada.s

\begin{lstlisting}
10.9.0.5        www.seed-server.com
\end{lstlisting}
 

% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Setup del Contenedor y sus Comandos}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/container/setup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% MySQL database
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\webcommon/mysql}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% -------------------------------------------
% SUBSECTION
% -------------------------------------------
\subsection{Sobre la Aplicación Web} 

La aplicación web que hemos creado, es un simple gestor de empleados.
Los empleados pueden ver y actualizar su información personal a través de esta aplicación.
Dentro de la aplicación existen principalmente dos roles:
{\tt Administrator} que es un rol privilgiado que puede manejar la información de todos los empleados.
{\tt Employee} es un rol común y corriente que puede ver o actualizar su propia información personal. La información de los empleados se muestra en la Tabla
\ref{table:database}.

\begin{table}[htb]
\caption{Database}
\label{table:database}
\centering
\begin{adjustbox}{max width=\textwidth}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|}
\hline
Name & Employee ID  & Password  &Salary  &Birthday  &SSN &Nickname &Email &Address &Phone\# \\
\hline
Admin 	& 99999       & seedadmin  &400000  &3/5   &43254314	& & & &\\
Alice 	& 10000       & seedalice  &20000   &9/20  &10211002	& & & &\\
Boby 	& 20000       & seedboby   &50000   &4/20  &10213352	& & & &\\
Ryan    & 30000       & seedryan   &90000   &4/10  &32193525	& & & &\\
Samy 	& 40000	      & seedsamy   &40000   &1/11  &32111111 	& & & &\\
Ted     & 50000	      & seedted    &110000  &11/3  &24343244	& & & &\\
\hline
\end{tabular}
\end{adjustbox}
\end{table}
 



% *******************************************
% SECTION
% ******************************************* 
\section{Tareas de Laboratorio}



% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 1: Conociendo las Declaraciones SQL}
\label{ssec:MySQLConsole}

El objetivo de este ataque es familiarizarse con los comandos SQL jugando con la base de datos provista. Los datos usados por nuestra aplicación web está guardada en una base de datos MYSQL que está hosteada en nuestro contenedor MySQL.
Hemos creado una base de datos llamada \texttt{sqllab\_users}, que contiene una tabla cuyo nombre es {\tt credential}. Esta tabla guarda la información personal (eid, password, salario, ssn,etc) de cada uno de los empleados. En esta Tarea, la idea es que ud. juegue un poco con la base de datos y vaya familiarizándose con las consultas SQL.

Por favor obtenga una shell en el contenedor MySQL (vea el manual del contenedor para más instrucciones; este manual está en sitio oficial del laboratorio).
Use el comando \texttt{mysql} que es el cliente para conectarse a la base de datos y para poder interactuar con la misma desde la shell.
El usuario es {\tt root} y el password es {\tt dees}. 

	
\begin{lstlisting}
// Inside the MySQL container
# mysql -u root -pdees 
\end{lstlisting}

Después de loguearse, puede crear una base de datoss nueva o cargar una ya existente. Comoo ya hemos creado una base de datos llamada \texttt{sqllab\_users}, solamente necesita cargarla, para hacerlo deberá de usar el comando \texttt{use}.
Para listar las tablas que componen esta base de datos puede usar el comando  \texttt{show tables} que mostrará todas las tablas de la base de datos seleccionada.

\begin{lstlisting}
mysql> use sqllab_users;
Database changed
mysql> show tables;
+------------------------+
| Tables_in_sqllab_users |
+------------------------+
| credential             |
+------------------------+
\end{lstlisting}

Después de correr estos comandos, va a necesitar usar un comando SQL para mostrar toda la información personal de la empleada Alice. Por favor provea screenshots de sus resultados.

% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 2: Inyección SQL en la Declaración SELECT} 

La Inyección SQL básicamente es una técnica a través de la cual un atacante puede ejecutar su propia declaración SQL maliciosa generalmente referida como payload malicioso. Por medio de este payload, los atacantes pueden robar información de la base de datos de la víctima; aún peor, pueden realizar cambios en la base de datos. Nuestra aplicación web tiene vulnerabilidades de Inyecciones SQL, que emulan los errores más comunes que comenten los desarrolladores web.

Para esta tarea, usaremos la página de login de \url{www.seed-server.com}.
La página muestra se muestra en la Figura \ref{sql:fig:login}.
Está pide al usuario ingresar su ussuario y su password.
La autenticación en la aplicación esta dada por estos dos datos, solamente los empleados que tengan un usuario y password válido podrán ingresar al sistema.
Su tarea como attacante es loguearse dentro de la aplicación sin conocer las credenciales del empleado. 


\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.7\textwidth]{\sqlFigs/login.jpg}
\end{center}
\caption{The Login page}
\label{sql:fig:login}
\end{figure}
 
Para ayudarlo a realizar esta tarea, explicaremos como es que funciona la implementación del mecanismo de autenticación en la aplicación. El código PHP que se encarga de realizar la autenticación está en el archivo \texttt{unsafe\_home.php} dentro del directorio \path{/var/www/SQL_Injection}.
El siguiente fragmento de código muestra como los usuarios son autenticados.

\begin{lstlisting}
$input_uname = $_GET['username'];
$input_pwd = $_GET['Password'];
$hashed_pwd = sha1($input_pwd);
...
$sql = "SELECT id, name, eid, salary, birth, ssn, address, email, 
               nickname, Password
        FROM credential
        WHERE name= '$input_uname' and Password='$hashed_pwd'";
$result = $conn -> query($sql);

// The following is Pseudo Code 
if(id != NULL) {
  if(name=='admin') {
     return All employees information;
  } else if (name !=NULL){
    return employee information;
  }
} else {
  Authentication Fails;
}
\end{lstlisting}

La declaración SQL mostrada en el código, selecciona la información personalUid, name, salary,ssn,etc) de un empleado  de la tabla {\tt credential}. Esta declaración SQL usa dos variables \texttt{input\_uname} y \texttt{hashed\_pwd}, donde \texttt{input\_uname} contiene el valor de la cadena tipeada por el usuario en la página de login, mientras que \texttt{hashed\_pwd} contiene el hash \texttt{sha1} del password tipeado por el usuario. El programa se encarga de chequear si existe algún registro que coincida con el username y password ingresado; si hay una coincidencia entonces el usuario será autenticado y se le dará su información correspondiente, de lo contrario la autenticación fallará.


\paragraph{Tarea 2.1: Ataque de Inyección SQl desde la página web.}
En esta tarea, su objetivo es loguearse en la aplicación web como administrador, de esta forma podrá ver la información de todos los empleados. Asumimos que ud. conoce el usuario del administrador el cual es {\tt admin} pero no conoce su password. Necesita decidir que ingresar como valor en los campos \texttt{Username} y \texttt{Password} para lograr un ataque exitoso.
	


\paragraph{Tarea 2.2: Ataque de Inyección SQL desde la consola.}  
En esta tarea, debe repetir lo hecho en la Tarea 2.1 pero debe hacerlo sin usar la página web. Puede usar las herramientas de la línea de comandos como puede ser \texttt{curl}, que nos sirve para enviar requests HTTP.
Cabe mencionar que si quiere incluir múltiples parametros en sus requests HTTP, necesita ponerlos en la URL dentro de un par de comillas de simples; de otra forma los caracteres especiales susados para separar los parámaetros (como \texttt{\&}) serán interpretados por la shell de una forma errónea y cambiándole el significado a lo que es la consulta dentro del aplicativo que hace los requests HTTP. El siguiente ejemplo muestra como enviar un request HTTP GET hacia nuestra aplicación web, usando dos parámetros (\texttt{username} y \texttt{Password}):

\begin{lstlisting}
$ curl 'www.seed-server.com/unsafe_home.php?username=alice&Password=11'
\end{lstlisting}

Si quiere incluir caracteres especiales en los campos de \texttt{username} o \texttt{Password}, es necesario que los codifique de forma apropiada o pueden cambiar el significado de su request. Si quiere incluir una comilla simple en esos campos, debería de usar \texttt{\%27}; si quiere incluir un espacio en blanco debería de usar \texttt{\%20}. En esta tarea necesita usar este tipo de codificación para enviar requests HTTP usando \texttt{curl}.


\paragraph{Tarea 2.3: Agregando una nueva declaración SQL.} 
En los ataques anteriores, solamente podemos extraer información de la base de datos; sería mucho mejor si pudieramos modificar la base de datos usando la misma vulnerabilidad en la página de login. Una idea es usar una Inyección SQL que corra dos declaraciones SQL en una sola, siendo al segunda una declaración update o delete. En SQL el punto y coma (;) es usado para separar dos declaraciones SQL. Por favor trate de correr dos declaraciones SQL usando la página de login.

Existe una contramedida para prevenir que se puedan correr dos declaraciones SQL en este ataque. Por favor use el libro de SEED o algún recurso de Internet para descubrir cual es esta contramedida y vuelque su descubrimiento en el informe del laboratorio.


% -------------------------------------------
% SUBSECTION
% ------------------------------------------- 
\subsection{Tarea 3: Inyección SQL en la Declaración UPDATE} 

If a SQL injection vulnerability happens to an UPDATE statement, the damage will be more
severe, because attackers can use the vulnerability to modify databases. 
In our Employee Management application, there is an Edit Profile page~(Figure~\ref{sql:fig:edit}) 
that allows employees to
update their profile information, including nickname, email, address, phone number, and
password. To go to this page, employees need to log in first. 


When employees update their information through the Edit Profile page, the
following SQL UPDATE query will be executed. The PHP code implemented in
{\tt unsafe\_edit\_backend.php} file is used to update employee's profile
information. The PHP file is located in the {\tt /var/www/SQLInjection}
directory.


\begin{lstlisting}
$hashed_pwd = sha1($input_pwd);
$sql = "UPDATE credential SET
	nickname='$input_nickname',
	email='$input_email',
	address='$input_address',
	Password='$hashed_pwd',
	PhoneNumber='$input_phonenumber'
	WHERE ID=$id;";
$conn->query($sql);
\end{lstlisting}
 

\begin{figure}[htb]
\begin{center}
  \includegraphics[width=0.6\textwidth]{\sqlFigs/editprofile.jpg}
\end{center}
\caption{The Edit-Profile page}
\label{sql:fig:edit}
\end{figure}
 


\paragraph{Tarea 3.1: Modificar su propio salario.}  
As shown in the Edit Profile page,
employees can only update their nicknames, emails, addresses, phone numbers, and
passwords; they are not authorized to change their salaries.  
Assume that you (Alice) are a disgruntled employee, and your boss Boby did not 
increase your salary this year. You want to increase your own salary 
by exploiting the SQL injection vulnerability in
the Edit-Profile page. Please demonstrate how you can achieve that.
We assume that you do know that salaries are stored in 
a column called \texttt{salary}.


\paragraph{Tarea 3.2: Modificar el salario de otras personas.}
After increasing your own salary, you decide to punish your boss Boby. You want to reduce his
salary to 1 dollar. Please demonstrate how you can achieve that. 



\paragraph{Tarea 3.3: Modificar el password de otras personas.}
After changing Boby's salary, you are still disgruntled, so you
want to change Boby's password to something that you know, and then you can log into his account
and do further damage. Please demonstrate how you can achieve that.
You need to demonstrate that you can 
successfully log into Boby's account using the new
password.  One thing worth mentioning here is that the database stores the hash value of
passwords instead of the plaintext password string. You can again look at
the {\tt unsafe\_edit\_backend.php} code to see how password is being stored. It
uses SHA1 hash function to generate the hash value of password. 




\subsection{Tarea 4: Contramedida --- Declaraciones Preparadas} 

The fundamental problem of the SQL injection vulnerability is the failure to
separate code from data. When constructing a SQL statement, the program
(e.g. PHP program) knows which part is data and which part is code.
Unfortunately, when the SQL statement is sent to the database, the boundary
has disappeared; the boundaries that the SQL interpreter sees may be
different from the original boundaries that was set by the developers.
To solve this problem, it is important to ensure that the view
of the boundaries are consistent in the server-side code and in the
database.  The most secure way is to use 
\textit{prepared statement}. 

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{\sqlFigs/PreparedStatement.pdf}
\caption{Prepared Statement Workflow}
\label{sql:fig:preparedstatement}
\end{figure}


To understand how prepared statement prevents SQL injection, 
we need to understand what happens when SQL server receives a query. 
The high-level workflow of how queries are executed is shown in Figure~\ref{sql:fig:preparedstatement}.
In the compilation step, queries first go through the parsing and normalization phase, 
where a query is checked against the syntax and semantics. 
The next phase is the compilation phase where keywords~(e.g. SELECT, FROM, UPDATE, etc.) 
are converted into a format understandable to machines. 
Basically, in this phase, query is interpreted.
In the query optimization phase, the number of different plans are considered to 
execute the query,  out of which the best optimized plan is chosen. 
The chosen plan is store in the cache, so 
whenever the next query comes in, 
it will be checked against the content in the cache; if it's already present in the cache,
the parsing, compilation and query optimization phases will be skipped. 
The compiled query is then passed to the execution phase 
where it is actually executed.


Prepared statement comes into the picture after the compilation but before the execution step. 
A prepared statement will go through the compilation step, and be turned into
a pre-compiled query with empty placeholders for data. To run this pre-compiled query,
data need to be provided, but these data will not go through the compilation step; instead,
they are plugged directly into the pre-compiled query, and are sent to the execution engine.
Therefore, even if there is SQL code inside the data, without going through the compilation
step, the code will be simply treated as part of data, without any special meaning.  
This is how prepared statement prevents SQL injection attacks.


Here is an example of how to write a prepared statement in PHP.  We use a SELECT statement in
the following example.  We show how to use prepared statement to rewrite the code that is
vulnerable to SQL injection attacks.


\begin{lstlisting}
$sql = "SELECT name, local, gender  
        FROM USER_TABLE 
        WHERE id = $id AND password ='$pwd' ";
$result = $conn->query($sql)
\end{lstlisting}

The above code is vulnerable to SQL injection attacks. 
It can be rewritten to the following


\begin{lstlisting}
$stmt = $conn->prepare("SELECT name, local, gender
                        FROM USER_TABLE 
                        WHERE id = ? and password = ? ");
// Bind parameters to the query
$stmt->bind_param("is", $id, $pwd);
$stmt->execute();
$stmt->bind_result($bind_name, $bind_local, $bind_gender);
$stmt->fetch();
\end{lstlisting}


Using the prepared statement mechanism, we divide the process of sending
a SQL statement to the database into two steps.  
The first step is to only send the code part, i.e., a SQL statement without 
the actual the data. This is the prepare step. As we can see from the 
above code snippet, the actual data are replaced by question
marks (?).  After this step, we then send the data to the database using 
{\tt bind\_param()}.
The database will treat everything sent in this step only as 
data, not as code anymore. It binds the data to the corresponding
question marks of the prepared statement. 
In the {\tt bind\_param()} method, the first argument {\tt "is"} indicates
the types of the parameters: \texttt{"i"} means  
that the data in {\tt \$id} has the integer type,
and \texttt{"s" } means that the data in {\tt \$pwd} has the string type.


\paragraph{Tarea.} In this task, we will use the prepared statement mechanism to 
fix the SQL injection vulnerabilities. For the sake of simplicity, we 
created a simplified program inside the \texttt{defense} folder. We 
will make changes to the files in this folder. 
If you point your browser to the following URL, you will see a page similar
to the login page of the web application. This page allows you to query an 
employee's information, but you need to provide the correct 
user name and password. 


\begin{lstlisting}
URL: http://www.seed-server.com/defense/
\end{lstlisting}

The data typed in this page will be sent to the 
server program \texttt{getinfo.php}, which 
invokes a program called \texttt{unsafe.php}. 
The SQL query inside this PHP program 
is vulnerable to SQL injection attacks. Your job is modify the SQL 
query in \texttt{unsafe.php} using the prepared statement, so
the program can defeat SQL injection attacks.
Inside the lab setup folder, the \texttt{unsafe.php} program is 
in the \path{image_www/Code/defense} folder. You can directly 
modify the program there. After you are done, you need
to rebuild and restart the container, or the changes will not
take effect. 

You can also modify the file while the container is running.
On the running container, the \texttt{unsafe.php} program is 
inside \path{/var/www/SQL_Injection/defense}. 
The downside of this
approach is that in order to keep the docker image small,
we have only installed a very simple text editor called \texttt{nano}
inside the container. It should be sufficient for simple editing.
If you do not like this editor, you can always use \texttt{"apt install"} to install
your favoriate command-line editor inside the container. For example,
for people who like \texttt{vim}, you can do the following:

\begin{lstlisting}
# apt install -y vim 
\end{lstlisting}

This installation will be discarded after the container is shutdown and destroyed.
If you want to make it permanent, add the installation command to the \texttt{Dockerfile} 
inside the \path{image_www} folder. 
 


\section{Guías}
\label{sec:guidelines}

\paragraph{Test SQL Injection String.}
In real-world applications, it may be hard to check whether your SQL injection attack contains
any syntax error, because usually servers do not return this kind of error messages. 
To conduct your investigation, you can copy the SQL statement from php source code to the MySQL console. 
Assume you have the following SQL statement, and the injection string is {\tt ' or 1=1;\#}. 

\begin{lstlisting}
SELECT * from credential 
WHERE name='$name' and password='$pwd';
\end{lstlisting}

You can replace the value of {\tt \$name} with the
injection string and test it using the MySQL console. 
This approach can help you construct a syntax-error 
free injection string before launching the real attack. 



% *******************************************
% SECTION
% ******************************************* 
\section{Informe del Laboratorio}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{\commonfolder/submission}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% *******************************************
% SECTION
% *******************************************
\section*{Agradecimientos}

\input{\commonfolder/acknowledgments}

\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





% This part is removed 
\begin{comment}
\paragraph{Escaping Special Characters using magic\_quotes\_gpc}

You will get to know that SQL Injection attack is possible because of attacker can use some
special character to alter the existing SQL queries.  In the PHP code, if a data variable is a
string type, it needs to be enclosed within a pair of single quote (').  For example, in the
SQL query listed above, we have used {\tt name = `\$user'}.  The single quote symbol
surrounding {\tt \$user} basically “tries” to separate the data in the {\tt \$user} variable
from the code.  Unfortunately, this separation will fail if the content of {\tt \$user}
variable include any single quote.  Therefore, we need a mechanism to tell the database that
the single quote in {\tt \$user} should be treated as a part of the data, not like the special
character in SQL.  All we need to do is to add a backslash (\textbackslash) before the single
quote, which will prevent us to alter any existing SQL query.  PHP provides a mechanism to
automatically add a backslash before single-quote ('), double quote ("), backslash
(\textbackslash), and NULL characters.  If this mechanism is turned on, all of these characters
in the user inputs will be automatically escaped.  This mechanism is known as magical quotes
and generally refer by the value of {\tt magic\_quotes\_gpc}.

 
Please note that, magic\_quotes\_gpc feature has been DEPRECATE as of 5.3.0 and REMOVED as of
PHP 5.4.0.  The PHP version installed in SEEDUbuntu VM is 5.3.5, so you can still play with
this. The reasons why it is removed is described below:

\begin{itemize}
\item Portability: Assuming it to be on, or off, affects portability.
Most code has to use a function called {\tt get\_magic\_quotes\_gpc()} to check for this,
and code accordingly.

\item Performance and Inconvenience: Not all user inputs are used
for SQL queries, so mandatory escaping all data not only affects
performance, but also become annoying when some data are not
supposed to be escaped.
\end{itemize}

\end{comment}
